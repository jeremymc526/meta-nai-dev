diff --git a/arch/arm/mach-zynq/Kconfig b/arch/arm/mach-zynq/Kconfig
index 557bfe7..087424d 100644
--- a/arch/arm/mach-zynq/Kconfig
+++ b/arch/arm/mach-zynq/Kconfig
@@ -30,6 +30,22 @@ config XILINX_PREFETCH
 	  in many cases. This may not always be the best performance depending on
 	  the usage.
 
+config NAI_XILINX_QSPI_RESET_WR
+	bool "Reset QPSI before software reset"
+	help
+	  This option enables the NAI workround for a bootrom error after software
+	  reset with 32MB QSPI flash.
+
+config NAI_XILINX_QSPI_RESET_WR_GPIO_7
+	bool "Use GPIO 7 to reset QSPI chip"
+	help
+	  select GPIO 7 to reset QSPI chip
+
+config NAI_XILINX_QSPI_RESET_WR_GPIO
+	int
+	default 7 if NAI_XILINX_QSPI_RESET_WR_GPIO_7
+	default 9
+
 endmenu
 
 endif
diff --git a/arch/arm/mach-zynq/slcr.c b/arch/arm/mach-zynq/slcr.c
index a838f6e..00c49c6 100644
--- a/arch/arm/mach-zynq/slcr.c
+++ b/arch/arm/mach-zynq/slcr.c
@@ -20,6 +20,8 @@
 #include <linux/of_address.h>
 #include <linux/regmap.h>
 #include <linux/clk/zynq.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
 #include "common.h"
 
 /* register offsets */
@@ -42,6 +44,27 @@
 void __iomem *zynq_slcr_base;
 static struct regmap *zynq_slcr_regmap;
 
+#ifdef CONFIG_NAI_XILINX_QSPI_RESET_WR
+static void nai_zynq_qspi_reset(void) {
+	//Note: 5/16/2017 The QSPI reset GPIO# is set in the kernel config
+	u32 qspiRstpin = CONFIG_NAI_XILINX_QSPI_RESET_WR_GPIO;
+	int ret = 0;
+
+	ret = gpio_request(qspiRstpin, "QSPIReset");
+	if (ret) {
+		pr_err("Unable to request GPIO %d \n", qspiRstpin);
+		return;
+	}
+	gpio_direction_output(qspiRstpin, 1);
+
+	gpio_set_value(qspiRstpin, 0);
+	udelay(1000);
+	gpio_set_value(qspiRstpin, 1);
+
+	pr_debug("Reset QSPI %d\n", qspiRstpin);
+}
+#endif /*CONFIG_NAI_XILINX_QSPI_RESET_WR*/
+
 /**
  * zynq_slcr_write - Write to a register in SLCR block
  *
@@ -110,6 +133,10 @@ int zynq_slcr_system_restart(struct notifier_block *nb,
 			     unsigned long action, void *data)
 {
 	u32 reboot;
+	
+#ifdef CONFIG_NAI_XILINX_QSPI_RESET_WR
+	nai_zynq_qspi_reset();
+#endif
 
 	/*
 	 * Clear 0x0F000000 bits of reboot status register to workaround
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index cb53391..ca37723 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -214,6 +214,14 @@ config AHCI_QORIQ
 	  onboard AHCI SATA.
 
 	  If unsure, say N.
+	  
+config AHCI_IPROP
+	tristate "IntelliProp AHCI SATA support"
+	help
+	  This option enables support for IntelliProp AHCI Serial ATA
+	  controllers.
+
+	  If unsure, say N.
 
 config SATA_FSL
 	tristate "Freescale 3.0Gbps SATA support"
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index 8daec3e..18c8866e 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_AHCI_ST)		+= ahci_st.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_TEGRA)	+= ahci_tegra.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_XGENE)	+= ahci_xgene.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_QORIQ)	+= ahci_qoriq.o libahci.o libahci_platform.o
+obj-$(CONFIG_AHCI_IPROP)	+= ahci_iprop.o libahci.o libahci_platform.o
 
 # SFF w/ custom DMA
 obj-$(CONFIG_PDC_ADMA)		+= pdc_adma.o
diff --git a/drivers/ata/ahci_iprop.c b/drivers/ata/ahci_iprop.c
new file mode 100644
index 0000000..dc6b73f
--- /dev/null
+++ b/drivers/ata/ahci_iprop.c
@@ -0,0 +1,100 @@
+/*
+ * IPROP AHCI SATA platform driver
+ * Copyright 2014 NAI, Inc.
+ *
+ * based on the AHCI SATA platform driver by Jeff Garzik and Anton Vorontsov
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/gfp.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/libata.h>
+#include <linux/ahci_platform.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/export.h>
+#include "ahci.h"
+
+#define DRV_NAME "iprop-ahci"
+
+static const struct ata_port_info ahci_iprop_port_info = {
+	.flags          = AHCI_FLAG_COMMON,
+	.pio_mask       = ATA_PIO4,
+	.udma_mask      = ATA_UDMA6,
+	.port_ops       = &ahci_platform_ops,
+};
+
+static struct scsi_host_template ahci_iprop_platform_sht = {
+	AHCI_SHT(DRV_NAME),
+};
+
+static int ahci_iprop_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ahci_host_priv *hpriv;
+	int rc;
+
+	hpriv = ahci_platform_get_resources(pdev);
+	if (IS_ERR(hpriv))
+		return PTR_ERR(hpriv);
+
+	rc = ahci_platform_enable_resources(hpriv);
+	if (rc)
+		return rc;
+
+	of_property_read_u32(dev->of_node,
+			     "ports-implemented", &hpriv->force_port_map);
+
+	rc = ahci_platform_init_host(pdev, hpriv, &ahci_iprop_port_info,
+				     &ahci_iprop_platform_sht);
+	if (rc)
+		ahci_platform_disable_resources(hpriv);
+	
+	return rc;
+}
+
+static SIMPLE_DEV_PM_OPS(ahci_iprop_pm_ops, ahci_platform_suspend,
+			 ahci_platform_resume);
+
+static const struct of_device_id ahci_iprop_of_match[] = {
+	{ .compatible = "IntelliProp,iprop-ahci-1.0" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ahci_iprop_of_match);
+
+static struct platform_driver ahci_iprop_driver = {
+	.probe = ahci_iprop_probe,
+	.remove = ata_platform_remove_one,
+	.shutdown = ahci_platform_shutdown,
+        .driver = {
+		.name = DRV_NAME,
+                .of_match_table = ahci_iprop_of_match,
+                .pm = &ahci_iprop_pm_ops,
+        },
+};
+
+module_platform_driver(ahci_iprop_driver);
+
+MODULE_DESCRIPTION("IProp AHCI SATA platform driver");
+MODULE_AUTHOR("Tony Yang <tyang@naii.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("sata:iprop");
diff --git a/drivers/iio/adc/xilinx-xadc-core.c b/drivers/iio/adc/xilinx-xadc-core.c
index 7c3f778..330ffa9 100644
--- a/drivers/iio/adc/xilinx-xadc-core.c
+++ b/drivers/iio/adc/xilinx-xadc-core.c
@@ -1150,8 +1150,41 @@ static int xadc_parse_dt(struct iio_dev *indio_dev, struct device_node *np,
 			iio_xadc_channels[num_channels] = xadc_channels[reg + 9];
 			iio_xadc_channels[num_channels].channel = num_channels - 1;
 
-			if (of_property_read_bool(child, "xlnx,bipolar"))
+			if (of_property_read_bool(child, "xlnx,bipolar")) {
 				iio_xadc_channels[num_channels].scan_type.sign = 's';
+			}
+			else {
+				/* NAI: added support for extern temperature */
+			}
+
+			/* 
+			 * NAI: added support for extern temperature populated
+			 * IIO chan spec structure for external temp sensor*
+			 */
+			if (of_property_read_bool(child, "nai,ext_temp")) {
+				iio_xadc_channels[num_channels].type = IIO_TEMP;
+				iio_xadc_channels[num_channels].indexed = 1;
+				/*
+				 * TODO: hardcode ext temp sensor iio chan to 1
+				 * iio chan is used by PS internal temp sensor.
+				 */
+				iio_xadc_channels[num_channels].channel = 1;
+				pr_debug("xadc sign = %c\n", iio_xadc_channels[num_channels].scan_type.sign);
+				iio_xadc_channels[num_channels].scan_type.sign = 'u';
+				iio_xadc_channels[num_channels].info_mask_separate =
+					BIT(IIO_CHAN_INFO_RAW) |
+					BIT(IIO_CHAN_INFO_SCALE) |
+					BIT(IIO_CHAN_INFO_OFFSET);
+				iio_xadc_channels[num_channels].info_mask_shared_by_all =
+					BIT(IIO_CHAN_INFO_SAMP_FREQ);
+				iio_xadc_channels[num_channels].event_spec = xadc_temp_events;
+				iio_xadc_channels[num_channels].num_event_specs =
+					ARRAY_SIZE(xadc_temp_events);
+				iio_xadc_channels[num_channels].scan_type.realbits = 12;
+				iio_xadc_channels[num_channels].scan_type.storagebits = 16;
+				iio_xadc_channels[num_channels].scan_type.shift = 4;
+				iio_xadc_channels[num_channels].scan_type.endianness = IIO_CPU;
+			}
 
 			num_channels++;
 		}
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 52ea34e..4cc2a49 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -695,6 +695,22 @@ config LEDS_NIC78BX
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called leds-nic78bx.
+	  
+config LEDS_NAI_PCA9534A
+	tristate "LED support for PCA9534A I2C chip"
+	depends on LEDS_CLASS
+	depends on I2C
+	help
+	  This option enables support for LEDs connected to the PCA9534A
+	  LED driver chip accessed via the I2C bus. Supported
+	  devices include PCA9534A
+	  
+config LEDS_NAI
+       tristate "LED support for NAI SoC boards"
+       depends on LEDS_CLASS
+       help
+         This option enables support for North Atlantic Industries Inc
+	 LEDs on the NAI platform.
 
 comment "LED Triggers"
 source "drivers/leds/trigger/Kconfig"
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 3598045..b9d708e 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -73,6 +73,8 @@ obj-$(CONFIG_LEDS_PM8058)		+= leds-pm8058.o
 obj-$(CONFIG_LEDS_MLXCPLD)		+= leds-mlxcpld.o
 obj-$(CONFIG_LEDS_NIC78BX)		+= leds-nic78bx.o
 obj-$(CONFIG_LEDS_MT6323)		+= leds-mt6323.o
+obj-$(CONFIG_LEDS_NAI)			+= leds-nai.o
+obj-$(CONFIG_LEDS_NAI_PCA9534A)		+= leds-nai-pca9534a.o
 
 # LED SPI Drivers
 obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
diff --git a/drivers/leds/leds-nai-pca9534a.c b/drivers/leds/leds-nai-pca9534a.c
new file mode 100644
index 0000000..df20c90
--- /dev/null
+++ b/drivers/leds/leds-nai-pca9534a.c
@@ -0,0 +1,331 @@
+/*
+ * Copyright 2015 NAI
+ *
+ * Author: ANI <naii@naii.com>
+ *
+ * This file is subject to the terms and conditions of version 2 of
+ * the GNU General Public License.  See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ * LED driver for the PCA9534A I2C LED driver (7-bit slave address 0x38)
+ *
+ * Note that hardware blinking violates the leds infrastructure driver
+ * interface since the hardware only supports blinking all LEDs with the
+ * same delay_on/delay_off rates.  That is, only the LEDs that are set to
+ * blink will actually blink but all LEDs that are set to blink will blink
+ * in identical fashion.  The delay_on/delay_off values of the last LED
+ * that is set to blink will be used for all of the blinking LEDs.
+ * Hardware blinking is disabled by default but can be enabled by setting
+ * the 'blink_type' member in the platform_data struct to 'pca9534a_HW_BLINK'
+ * or by adding the 'nxp,hw-blink' property to the DTS.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/platform_data/leds-nai-pca9534a.h>
+
+
+/* LED select registers determine the source that drives LED outputs */
+#define pca9534a_LED_OFF		0x0	/* LED driver off */
+#define pca9534a_LED_ON		0x1	/* LED driver on */
+#define DEFAULT_ON_LED_STR	"green"
+
+
+enum pca963x_type {
+	pca9534a3,
+};
+
+static const struct i2c_device_id pca9534a_id[] = {
+	{ "pca9534a", pca9534a3 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, pca9534a_id);
+
+enum pca9534a_cmd {
+	BRIGHTNESS_SET,
+	BLINK_SET,
+};
+
+struct pca9534a_chipdef {
+	u8			input_base;
+	u8			output_base;
+	u8			polarity_base;
+	u8			config_base;
+	int			n_port;
+};
+
+static struct pca9534a_chipdef pca9534a_chipdefs[] = {
+	[pca9534a3]{
+		.input_base			= 0x0,
+		.output_base		= 0x1,
+		.polarity_base		= 0x2,
+		.config_base		= 0x3,
+		.n_port				= 8,
+	},
+};
+
+struct pca9534a_led;
+
+struct pca9534a {
+	struct pca9534a_chipdef *chipdef;
+	struct mutex mutex;
+	struct i2c_client *client;
+	struct pca9534a_led *leds;
+};
+
+struct pca9534a_led {
+	struct pca9534a *chip;
+	struct work_struct work;
+	enum led_brightness brightness;
+	struct led_classdev led_cdev;
+	int led_num; /* 0 .. 7 potentially */
+	enum pca9534a_cmd cmd;
+	char name[32];
+};
+
+static int totalLeds = 0;
+
+static void pca9534a_brightness_work(struct pca9534a_led *pca9534a)
+{
+	u8 ledout_addr = pca9534a->chip->chipdef->output_base;
+	u8 ledout = 0;
+	int shift = pca9534a->led_num;
+	u8 mask = 0x1 << shift;
+
+	mutex_lock(&pca9534a->chip->mutex);
+	ledout = i2c_smbus_read_byte_data(pca9534a->chip->client, ledout_addr);
+	
+	switch (pca9534a->brightness) {
+	case LED_FULL:
+		ledout &= ~mask;
+		i2c_smbus_write_byte_data(pca9534a->chip->client, ledout_addr,
+			ledout);
+		break;
+	case LED_OFF:
+		ledout |= mask;
+		i2c_smbus_write_byte_data(pca9534a->chip->client, ledout_addr,
+			ledout);
+		break;
+	default:
+		break;
+	}
+	mutex_unlock(&pca9534a->chip->mutex);
+}
+
+static void pca9534a_work(struct work_struct *work)
+{
+	struct pca9534a_led *pca9534a = container_of(work,
+		struct pca9534a_led, work);
+		
+	switch (pca9534a->cmd) {
+	case BRIGHTNESS_SET:
+		pca9534a_brightness_work(pca9534a);
+		break;
+	default:
+		break;
+	}
+}
+
+static void pca9534a_led_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct pca9534a_led *pca9534a;
+	
+	pca9534a = container_of(led_cdev, struct pca9534a_led, led_cdev);
+
+	pca9534a->cmd = BRIGHTNESS_SET;
+	pca9534a->brightness = value;
+	/*
+	 * Must use workqueue for the actual I/O since I2C operations
+	 * can sleep.
+	 */
+	schedule_work(&pca9534a->work);
+}
+
+static struct pca9534a_platform_data * pca9534a_dt_init(struct i2c_client *client, struct pca9534a_chipdef *chip)
+{
+	struct device_node *np = client->dev.of_node, *child;
+	struct pca9534a_platform_data *pdata;
+	struct led_info *pca9534a_leds;
+	int count;
+
+	count = of_get_child_count(np);
+	if (!count || count > chip->n_port)
+		return ERR_PTR(-ENODEV);
+
+	pca9534a_leds = devm_kzalloc(&client->dev,
+			sizeof(struct led_info) * count, GFP_KERNEL);
+	if (!pca9534a_leds)
+		return ERR_PTR(-ENOMEM);
+
+	for_each_child_of_node(np, child) {
+		struct led_info led;
+		u32 reg;
+		int res;
+
+		res = of_property_read_u32(child, "reg", &reg);
+		if (res != 0)
+			continue;
+		led.name =
+			of_get_property(child, "label", NULL) ? : child->name;
+		led.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+		pca9534a_leds[reg] = led;
+	}
+	pdata = devm_kzalloc(&client->dev,
+			     sizeof(struct pca9534a_platform_data), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->leds.leds = pca9534a_leds;
+	pdata->leds.num_leds = count;
+
+	return pdata;
+}
+
+static const struct of_device_id of_pca9534a_match[] = {
+	{ .compatible = "nai,pca9534a", },
+};
+
+static int pca9534a_probe(struct i2c_client *client,
+					const struct i2c_device_id *id)
+{
+	struct pca9534a *pca9534a_chip;
+	struct pca9534a_led *pca9534a;
+	struct pca9534a_platform_data *pdata;
+	struct pca9534a_chipdef *chip;
+	int i, err;
+	u8 configMask = 0xFF;
+	s8 retData = 0;
+	
+	chip = &pca9534a_chipdefs[id->driver_data];
+	pdata = dev_get_platdata(&client->dev);
+	
+	if (!pdata) {
+		pdata = pca9534a_dt_init(client, chip);
+		if (IS_ERR(pdata)) {
+			dev_warn(&client->dev, "could not parse configuration\n");
+			pdata = NULL;
+		}
+	}
+
+	if (pdata && (pdata->leds.num_leds < 1 ||
+				 pdata->leds.num_leds > chip->n_port)) {
+		dev_err(&client->dev, "board info must claim 1-%d LEDs",
+								chip->n_port);
+		return -EINVAL;
+	}
+
+	pca9534a_chip = devm_kzalloc(&client->dev, sizeof(*pca9534a_chip),
+								GFP_KERNEL);
+	if (!pca9534a_chip)
+		return -ENOMEM;
+	pca9534a = devm_kzalloc(&client->dev, chip->n_port * sizeof(*pca9534a),
+								GFP_KERNEL);
+	if (!pca9534a)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, pca9534a_chip);
+
+	mutex_init(&pca9534a_chip->mutex);
+	pca9534a_chip->chipdef = chip;
+	pca9534a_chip->client = client;
+	pca9534a_chip->leds = pca9534a;
+	
+	/*check if pca9534a chip present*/
+	retData = i2c_smbus_read_byte_data(pca9534a_chip->client, pca9534a_chip->chipdef->polarity_base);
+	if(retData < 0){
+		dev_warn(&client->dev, "pca9534a chip not present 0x%02x \n",retData);
+		return -EINVAL;
+	}
+	
+	for (i = 0; i <  pdata->leds.num_leds; i++) {
+		pca9534a[i].led_num = i;
+		pca9534a[i].chip = pca9534a_chip;
+
+		/* Platform data can specify LED names and default triggers */
+		if (pdata && i < pdata->leds.num_leds) {
+			if (pdata->leds.leds[i].name)
+				snprintf(pca9534a[i].name,
+					 sizeof(pca9534a[i].name), "nai_ext:%s",
+					 pdata->leds.leds[i].name);
+			if (pdata->leds.leds[i].default_trigger)
+				pca9534a[i].led_cdev.default_trigger =
+					pdata->leds.leds[i].default_trigger;
+		}
+
+		pca9534a[i].led_cdev.name = pca9534a[i].name;
+		pca9534a[i].led_cdev.brightness_set = pca9534a_led_set;
+		
+		if(strcmp(pdata->leds.leds[i].name,  DEFAULT_ON_LED_STR) == 0){
+			pca9534a[i].led_cdev.brightness = LED_FULL;
+		}else{
+			pca9534a[i].led_cdev.brightness = LED_OFF;
+		}
+		
+		INIT_WORK(&pca9534a[i].work, pca9534a_work);
+		
+		err = led_classdev_register(&client->dev, &pca9534a[i].led_cdev);
+		if (err < 0)
+			goto exit;
+		
+		configMask &= ~(1 << i);
+		totalLeds = i+1;
+	}
+
+	/*configure gpio to output for availabe leds*/
+	i2c_smbus_write_byte_data(client, chip->config_base, configMask);
+	
+	/*enable/disable leds*/
+	for (i = 0; i <  pdata->leds.num_leds; i++){
+		pca9534a_led_set(&(pca9534a[i].led_cdev), pca9534a[i].led_cdev.brightness);
+	}
+	
+	return 0;
+
+exit:
+	while (i--) {
+		led_classdev_unregister(&pca9534a[i].led_cdev);
+		cancel_work_sync(&pca9534a[i].work);
+	}
+
+	return err;
+}
+
+static int pca9534a_remove(struct i2c_client *client)
+{
+	struct pca9534a *pca9534a = i2c_get_clientdata(client);
+	int i;
+
+	for (i = 0; i < totalLeds; i++) {
+		led_classdev_unregister(&pca9534a->leds[i].led_cdev);
+		cancel_work_sync(&pca9534a->leds[i].work);
+	}
+
+	return 0;
+}
+
+static struct i2c_driver pca9534a_driver = {
+	.driver = {
+		.name	= "leds-pca9534a",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(of_pca9534a_match),
+	},
+	.probe	= pca9534a_probe,
+	.remove	= pca9534a_remove,
+	.id_table = pca9534a_id,
+};
+
+module_i2c_driver(pca9534a_driver);
+
+MODULE_AUTHOR("NAI <nai@naii.com>");
+MODULE_DESCRIPTION("pca9534a LED driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/leds/leds-nai.c b/drivers/leds/leds-nai.c
new file mode 100755
index 0000000..f1b3d2d
--- /dev/null
+++ b/drivers/leds/leds-nai.c
@@ -0,0 +1,248 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+
+/* TODO is the hw blink rate on/off or on then off */
+#define NAI_LED_BLINK_RATE_SLOW_MS      1000
+#define NAI_LED_BLINK_RATE_MEDIUM_MS    250
+#define NAI_LED_BLINK_RATE_FAST_MS      100
+#define NAI_LED_BLINK_RATE_SOLID_MS     0
+
+#define NAI_LED_BASE_OFFSET             0x20
+#define NAI_LED_BASE_ADDR_OFFSET(i)     (NAI_LED_BASE_OFFSET + (i * 4))
+
+#define NAI_LED_BLINK_RATE_MASK         0x00000300
+#define NAI_LED_BLINK_RATE_SOLID        0x00000000
+#define NAI_LED_BLINK_RATE_SLOW         0x00000100
+#define NAI_LED_BLINK_RATE_MEDIUM       0x00000200
+#define NAI_LED_BLINK_RATE_FAST         0x00000300
+
+#define NAI_LED_ONESHOT                 0x00000002
+#define NAI_LED_ENABLE                  0x00000001
+#define NAI_LED_ENABLE_MASK				0x00000001
+
+#define NAI_DRV_NAME_VER				"NAI,led-1.0"
+
+struct nai_led_dev {
+	struct led_classdev cdev;
+	void __iomem        *led_addr;
+};
+
+static void nai_led_set(struct led_classdev *cdev, enum led_brightness b) {
+	struct nai_led_dev *dev;
+	u32 val;
+
+	dev = container_of(cdev, struct nai_led_dev, cdev);
+	if (b != LED_OFF) {
+		/* Ensure LED is enabled, do not modify blink rate */
+		val = ioread32(dev->led_addr);
+		val |= NAI_LED_ENABLE;
+	}
+	else {
+		/* Ensure LED is disabled, clear blink rate (set it to solid) */
+		val = 0;
+	}
+	iowrite32(val, dev->led_addr);
+}
+
+static enum led_brightness nai_led_get(struct led_classdev *cdev) {
+	struct nai_led_dev *dev;
+	u32 val;
+	
+	dev = container_of(cdev, struct nai_led_dev, cdev);
+	val = ioread32(dev->led_addr);
+	val &= NAI_LED_ENABLE_MASK;
+	cdev->brightness = val;
+	
+	return cdev->brightness;
+}
+
+static int nai_led_blink_set(struct led_classdev *cdev,
+			     unsigned long *delay_on,
+			     unsigned long *delay_off) {
+	struct nai_led_dev *dev;
+	u32 rate = 0;
+	u32 blink;
+	u32 val;
+	
+	dev = container_of(cdev, struct nai_led_dev, cdev);
+	
+	/* We do not have separate on/off rates, just use the max */
+	if ( *delay_on )
+		rate = *delay_on;
+	
+	//printk("nai_blink delay_on %ld delay_off %ld rate %d \n",*delay_on, *delay_off, rate);
+	if ((rate > NAI_LED_BLINK_RATE_SOLID_MS) && (rate <= NAI_LED_BLINK_RATE_FAST_MS)) {
+		*delay_on = *delay_off = NAI_LED_BLINK_RATE_FAST_MS;
+		blink = NAI_LED_BLINK_RATE_FAST;
+	}
+	else if((rate > NAI_LED_BLINK_RATE_FAST_MS) && (rate <= NAI_LED_BLINK_RATE_MEDIUM_MS)) {
+		*delay_on = *delay_off = NAI_LED_BLINK_RATE_MEDIUM_MS;
+		blink = NAI_LED_BLINK_RATE_MEDIUM;
+	}
+	else if((rate > NAI_LED_BLINK_RATE_MEDIUM_MS) && (rate <= NAI_LED_BLINK_RATE_SLOW_MS)) {
+		*delay_on = *delay_off = NAI_LED_BLINK_RATE_SLOW_MS;
+		blink = NAI_LED_BLINK_RATE_SLOW;
+	}
+	else {
+		*delay_on = *delay_off = NAI_LED_BLINK_RATE_SOLID_MS;
+		blink = NAI_LED_BLINK_RATE_SOLID;
+	}
+
+	val = ioread32(dev->led_addr);
+	val &= ~NAI_LED_BLINK_RATE_MASK;
+	val |= blink;
+	iowrite32(val, dev->led_addr);
+
+	return 0;
+}
+
+static const struct of_device_id of_nai_leds_match[] = {
+	{ .compatible = NAI_DRV_NAME_VER, },
+	{},
+};
+
+static int nai_led_probe(struct platform_device *pdev) {
+	struct nai_led_dev *pled;
+	struct device_node *pNode, *curr_cNode;
+	void __iomem *base_addr;
+	int ret = 0;
+	int i = 0;
+	int cNodeCount = 0;
+	const char *led_desc;
+	struct resource regs;
+	
+	dev_info(&pdev->dev, "\n");
+	
+	//get the parent node of the compatible device
+	pNode = pdev->dev.of_node;
+	if(!pNode) {
+		dev_err(&pdev->dev, "Unable to find compatible %s in DTB \n", NAI_DRV_NAME_VER);
+		goto err;
+	}
+
+	//find number of LEDS from DTB
+	cNodeCount = of_get_child_count(pNode);
+	//dev_err(&pdev->dev, "Child node # %d \n", cNodeCount);
+	if(!cNodeCount) {
+		dev_err(&pdev->dev, "Unable to find any LED defined in DTB \n");
+		goto err;
+	}
+	
+	pled = devm_kzalloc(&pdev->dev,
+			    sizeof(struct nai_led_dev) * cNodeCount,
+			    GFP_KERNEL);
+	if (!pled) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	
+	for_each_child_of_node(pNode, curr_cNode) {
+		led_desc = of_get_property(curr_cNode, "label", NULL);
+		/*dev_info(&pdev->dev, "LED Desc %s \n", led_desc);*/
+		
+		ret = of_address_to_resource(curr_cNode, 0, &regs);
+		if (ret) {
+			dev_err(&pdev->dev, "%s missing \"reg\" property\n", led_desc);
+			goto err_register;
+		}
+
+		base_addr = devm_ioremap_resource(&pdev->dev, &regs);
+		if (IS_ERR(base_addr)) {
+			dev_err(&pdev->dev, "unable to map %s regs\n", led_desc);
+			ret = PTR_ERR(base_addr);
+			goto err_register;
+		}
+
+		/*dev_info(&pdev->dev, "LED %s BaseAddr %p \n",led_desc, base_addr);*/
+		
+		pled[i].cdev.name = led_desc;
+		pled[i].led_addr = base_addr;
+		pled[i].cdev.brightness_set = nai_led_set;
+		pled[i].cdev.brightness_get = nai_led_get;
+		pled[i].cdev.blink_set = nai_led_blink_set;
+		pled[i].cdev.max_brightness = LED_FULL;
+		pled[i].cdev.brightness = LED_OFF;
+		/* Default to off, blink rate is solid */
+		/* Removed the default OFF state */
+		/*iowrite32(0, pled[i].led_addr);*/
+		
+		ret = led_classdev_register(pdev->dev.parent, &pled[i].cdev);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"Failed to register %s led, err=%d\n",
+				pled[i].cdev.name, ret);
+			goto err_register;
+		}
+		++i;
+	}
+
+	platform_set_drvdata(pdev, pled);
+	
+	return 0;
+
+err_register:
+	while (--i >= 0) {
+		led_classdev_unregister(&pled[i].cdev);
+	}
+	kfree(pled);
+err:
+	return ret;
+}
+
+static int nai_led_remove(struct platform_device *pdev) {
+	struct nai_led_dev *pled = platform_get_drvdata(pdev);
+	struct led_platform_data *pdata  = pdev->dev.platform_data;
+	int i;
+
+	for (i = 0; i < pdata->num_leds; i++) {
+		pled[i].cdev.brightness = LED_OFF;
+		nai_led_set(&pled[i].cdev, pled[i].cdev.brightness);
+		led_classdev_unregister(&pled[i].cdev);
+	}
+	platform_set_drvdata(pdev, NULL);
+	kfree(pled);
+
+	return 0;
+}
+
+static struct platform_driver nai_led_driver = {
+	.driver		= {
+		.name	= NAI_DRV_NAME_VER,
+		.owner	= THIS_MODULE,	
+		.of_match_table = of_match_ptr(of_nai_leds_match),
+	},
+	.probe		= nai_led_probe,
+	.remove		= nai_led_remove,
+};
+
+module_platform_driver(nai_led_driver);
+
+MODULE_AUTHOR("North Atlantic Industries Inc");
+MODULE_DESCRIPTION("LED driver for NAI Board");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index b46e24e..6f359df 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -529,6 +529,25 @@ config XILINX_TRAFGEN
 	  their requirements.
 
 	  If unsure, say N
+	  
+config NAI_MB_FPGA_TOP_CFG
+       tristate "NAI Motherboard TOP FPGA"
+       help
+         This option enables device driver support for reading and writing
+	 to motherboard fpga registers from the ARM on the motherboard.
+
+config NAI_SERDES
+       tristate "NAI SERDES"
+       help
+         This option enables device deriver support for reading and writing
+	 to modules from the PS on the motherboard.
+
+#config NAI_EP_SHRM
+#	tristate "NAI end-point share memory driver"
+#       help
+#         This ia NAI board specific device driver. 
+#         This device driver supports read/write to share block of congtiguous memory 
+#         between NAI SBC via PCIe/VME/cPCI 
 
 source "drivers/misc/jesd204b/Kconfig"
 source "drivers/misc/c2port/Kconfig"
@@ -543,4 +562,7 @@ source "drivers/misc/mic/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
 source "drivers/misc/echo/Kconfig"
 source "drivers/misc/cxl/Kconfig"
+source "drivers/misc/nai-pci-device/Kconfig"
+source "drivers/misc/nai-ep-shrm/Kconfig"
+source "drivers/misc/nai-generic-i2c/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 7cea0d5..b039f2d 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -59,6 +59,12 @@ obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_ASPEED_LPC_CTRL)	+= aspeed-lpc-ctrl.o
 obj-$(CONFIG_ASPEED_LPC_SNOOP)	+= aspeed-lpc-snoop.o
 obj-$(CONFIG_PCI_ENDPOINT_TEST)	+= pci_endpoint_test.o
+obj-$(CONFIG_NAI_SERDES)	+= nai-serdes.o
+nai-serdes-objs			:= nai_serdes_utils.o nai_serdes_oper.o nai_serdes_config.o nai_serdes.o
+obj-$(CONFIG_NAI_MB_FPGA_TOP_CFG)	+= nai_mb_fpga_top_cfg.o
+obj-$(CONFIG_NAI_PCI_DEVICE)	+= nai-pci-device/
+obj-$(CONFIG_NAI_GENERIC_I2C)	+= nai-generic-i2c/
+obj-$(CONFIG_NAI_EP_SHRM)	+= nai-ep-shrm/
 
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_core.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_bugs.o
diff --git a/drivers/misc/eeprom/at24.c b/drivers/misc/eeprom/at24.c
index 764ff5df..8b7382c 100644
--- a/drivers/misc/eeprom/at24.c
+++ b/drivers/misc/eeprom/at24.c
@@ -162,6 +162,8 @@ struct at24_data {
 				AT24_FLAG_SERIAL |
 				AT24_FLAG_READONLY) },
 	{ "24c64",	AT24_DEVICE_MAGIC(65536 / 8,	AT24_FLAG_ADDR16) },
+	{ "24cl64",	AT24_DEVICE_MAGIC(65536 / 8,
+				AT24_FLAG_ADDR16 | AT24_FLAG_FRAM) },
 	{ "24cs64",	AT24_DEVICE_MAGIC(16,
 				AT24_FLAG_ADDR16 |
 				AT24_FLAG_SERIAL |
@@ -753,6 +755,7 @@ static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	at24->nvmem_config.dev = &client->dev;
 	at24->nvmem_config.read_only = !writable;
 	at24->nvmem_config.root_only = true;
+	at24->nvmem_config.fram = chip.flags & AT24_FLAG_FRAM ? true : false;
 	at24->nvmem_config.owner = THIS_MODULE;
 	at24->nvmem_config.compat = true;
 	at24->nvmem_config.base_dev = &client->dev;
@@ -770,8 +773,9 @@ static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		goto err_clients;
 	}
 
-	dev_info(&client->dev, "%u byte %s EEPROM, %s, %u bytes/write\n",
+	dev_info(&client->dev, "%u byte %s %s, %s, %u bytes/write\n",
 		chip.byte_len, client->name,
+		chip.flags & AT24_FLAG_FRAM ? "FRAM" : "EEPROM",
 		writable ? "writable" : "read-only", at24->write_max);
 	if (use_smbus == I2C_SMBUS_WORD_DATA ||
 	    use_smbus == I2C_SMBUS_BYTE_DATA) {
diff --git a/drivers/misc/nai-ep-shrm/Kconfig b/drivers/misc/nai-ep-shrm/Kconfig
new file mode 100644
index 0000000..30e5a31
--- /dev/null
+++ b/drivers/misc/nai-ep-shrm/Kconfig
@@ -0,0 +1,8 @@
+menu "NAI EP SHRM Support"
+ config NAI_EP_SHRM
+	tristate "NAI end-point share memory driver"
+        help
+          This ia NAI board specific device driver.
+          This device driver supports read/write to share block of congtiguous memory
+          between NAI SBC via PCIe/VME/cPCI
+endmenu
diff --git a/drivers/misc/nai-ep-shrm/Makefile b/drivers/misc/nai-ep-shrm/Makefile
new file mode 100644
index 0000000..8794418
--- /dev/null
+++ b/drivers/misc/nai-ep-shrm/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_NAI_EP_SHRM)       += nai-ep-shrm.o
diff --git a/drivers/misc/nai-ep-shrm/nai-ep-shrm.c b/drivers/misc/nai-ep-shrm/nai-ep-shrm.c
new file mode 100644
index 0000000..d09a854
--- /dev/null
+++ b/drivers/misc/nai-ep-shrm/nai-ep-shrm.c
@@ -0,0 +1,825 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+//#define pr_fmt(fmt) "%s:%d:: " fmt, KBUILD_MODNAME,  __LINE__
+#define pr_fmt(fmt) "NAI %s:%s:%d::" fmt, strrchr(__FILE__,'/'), __func__, __LINE__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <asm/uaccess.h>
+#include <asm/barrier.h>
+
+#include "nai-ep-shrm.h"
+
+//#define DEBUG_SHRM
+
+#define DRV_NAME             		"nai-ep-shrm"
+#define DRV_VER              		"v1.0"
+
+
+#define FPGA_PCIE_DDR_MAP_OFFSET       	0x00000000
+#define FPGA_PCIE_DDR_MSK_OFFSET       	0x00000004
+#define FPGA_VME_CPCI_DDR_MAP_OFFSET   	0x00000000
+#define FPGA_VME_CPCI_DDR_MSK_OFFSET   	0x00000004
+
+
+#define IRQ_2_BIT_SHIFT                	2
+#define MOD7_BIT0_IRQ_BIT_SHIFT        	28
+
+
+/* TODO: Get memory alloc size from DTB */
+/* if 1M, Failed To Allocated Contiguous Memory for CFP_KERNEL flag */
+#define MEM_ALLOC_SIZE                 	4 * 1024 * 1024 
+#define DDR_SHRM_MASK                  	1 * 1024 * 1024 - 1
+#define EP_SHRM_MINOR                  	0
+
+struct ep_shrm_drv {
+   	/* Kernel virtual base address of the ring memory. */
+   	void __iomem        *fpga_pcie_ddr_base_addr;
+   	void __iomem        *fpga_vme_cpci_ddr_base_addr;
+   	void __iomem        *fpga_irq_clr;
+   	void __iomem        *fpga_mod7_vec_addr;
+   	void __iomem        *fpga_mod7_steer_addr;
+   	void __iomem        *fpga_mod7_ack_irq;
+   	void                *virt_addr;
+	void	  	    *phy_addr; 
+  	void                *kern_buf;
+   	char                cdev_name[16];
+   	unsigned int        cdev_major;
+   	unsigned int        cdev_minor;
+   	struct device       *parent;
+   	struct class        *ep_shrm_sysfs_class;   /* Sysfs class */
+   	struct device       *ep_shrm_sysfs_device;  /* Sysfs device */
+   	struct cdev         cdev;
+   	int                 irq;
+   	unsigned char       ackirqsteer;
+   	unsigned int        opened;
+   	atomic_t            counter;
+   	size_t              mem_size;
+   	dma_addr_t          dma;
+   	spinlock_t          rx_lock;
+   	wait_queue_head_t   rx_waitq;
+};
+
+struct ep_shrm_sysfs_entry {
+  	struct kobj_attribute kobj_attr;
+   	struct ep_shrm_drv    *drv;
+   	int                   genIrq;
+};
+
+static const char driver_name[] = DRV_NAME;
+static DEFINE_MUTEX(minors_lock);
+
+
+static void printk_hex_info(unsigned char* hex_info, unsigned int info_size) {
+   	const int column_num = 16;
+	/* including 2 bytes hex num and 1 byte field delimiter ',' */
+   	const int element_size = 3;
+	/* sizeof(int) is used for last str delimiter '\0' and mem alignment */
+   	char work_buf[element_size * column_num + sizeof(int)];
+   	unsigned int i;
+
+   	memset(work_buf, 0, sizeof(work_buf));
+   	for (i = 0; i < info_size; i++) {
+      		sprintf(work_buf + ((i * element_size) % (column_num * element_size)),
+			"%02x,", hex_info[i]);
+      		if ((i == (info_size - 1)) || ((i + 1) % column_num == 0)) {
+         		printk(KERN_INFO "%s\n", work_buf);
+         		memset(work_buf, 0, sizeof(work_buf));
+      		}
+   	}
+}
+
+static void gen_ack_irq(struct ep_shrm_sysfs_entry *entry) {
+   
+   	struct ep_shrm_sysfs_entry *priv = entry;
+   	unsigned int ret = 0;
+   
+   	/* we are using reserved module 7 to trigger IRQ over cPCI/PCIe/VME */
+   	/* trigger ack irq */
+   	/* TODO: vector data is not been use, hardward code to bit0 */
+   	/* set up module 7 bit0 vector */
+   	iowrite32(0, priv->drv->fpga_mod7_vec_addr);
+   	/* set up module 7 bit0 steering */
+   	iowrite32(priv->drv->ackirqsteer, priv->drv->fpga_mod7_steer_addr);
+   	/* trigger module 7 bit0 ack irq */
+   	ret = ioread32(priv->drv->fpga_mod7_ack_irq);
+   	ret |= (1 << MOD7_BIT0_IRQ_BIT_SHIFT);
+   	iowrite32(ret, priv->drv->fpga_mod7_ack_irq);
+   
+  	return;
+}
+
+static ssize_t gen_irq_store (struct kobject *kobj, struct kobj_attribute *attr,
+			      const char *buf, size_t count) {
+   	int irqgen;
+   	struct ep_shrm_sysfs_entry *entry;
+   	int ret;
+
+   	entry = container_of(attr, struct ep_shrm_sysfs_entry, kobj_attr);
+
+   	ret = kstrtoint(buf, 0, &irqgen);
+   
+   	if (ret)
+     	 	return ret;
+   
+   	irqgen = !!irqgen;
+
+   	if (irqgen == entry->genIrq)
+      		return count;
+
+   	if (irqgen > 0) {
+      		gen_ack_irq(entry);
+   	}
+
+   	entry->genIrq = irqgen;
+
+   	return count;
+}
+
+static struct kobj_attribute int_genirq_attribute = {
+      .attr = { .name = "genirq", .mode = 0222 },
+      .store = gen_irq_store,
+};
+
+static int ep_shrm_open(struct inode *inode, struct file *filp) {
+   	struct ep_shrm_drv *drv = container_of(inode->i_cdev,
+		struct ep_shrm_drv, cdev);
+	int err = 0;
+
+   	filp->private_data = drv;
+
+   	mutex_lock(&minors_lock);
+   
+   	/* TODO: Currently we only allow one I/O open */
+   	if (drv->opened >= 1) {
+      		err = -EBUSY;
+      		goto error;
+   	}
+   
+   	if (drv->opened <= 0) {
+      		drv->kern_buf = kzalloc(drv->mem_size, GFP_KERNEL);
+      		if(!drv->kern_buf) {
+         		printk("Failed to allocated kern buf \n");
+		        err = -ENOMEM;
+         		goto error;
+      		}   
+   	}
+   
+   	drv->opened++;
+error:
+	mutex_unlock(&minors_lock);      
+   
+  	return err;
+}
+
+static int ep_shrm_release(struct inode *inode, struct file *filp) {
+   	struct ep_shrm_drv *drv = filp->private_data;
+   
+   	mutex_lock(&minors_lock);
+   
+   	if((drv->opened == 1) && drv->kern_buf)
+         	kfree(drv->kern_buf);
+
+   	if(drv->opened > 0)
+      		drv->opened--;
+   
+   	mutex_unlock(&minors_lock);
+   
+   	return 0;
+}
+
+static loff_t ep_shrm_llseek(struct file *filp, loff_t off, int whence) {
+   	struct ep_shrm_drv *drv = filp->private_data;
+   	loff_t absolute = -1;
+
+   	/*printk("ep_shrm_llseek offset %llx\n",off);*/
+   
+   	mutex_lock(&minors_lock);   
+   
+   	switch (whence) {
+     	case SEEK_SET:
+         	absolute = off;
+         	break;
+
+      	case SEEK_CUR:
+         	absolute = filp->f_pos + off;
+         	break;
+
+      	case SEEK_END:
+         	absolute = drv->mem_size + off;
+         	break;
+
+      	default:
+      		absolute = -EINVAL;
+     		goto error;
+   	}
+
+   	if ((absolute < 0) || (absolute >= drv->mem_size)) {
+      		absolute = -EINVAL;
+     		goto error;
+   	}
+
+   	filp->f_pos = absolute;
+
+   	/*printk("ep_shrm_llseek offset %llx\n", filp->f_pos);*/
+error:
+   	mutex_unlock(&minors_lock);   
+   	return absolute;
+}
+
+static ssize_t ep_shrm_read(struct file *filp, char __user *buf,
+		            size_t count, loff_t *ppos) {
+   	struct ep_shrm_drv *drv = filp->private_data;
+   	int err = 0;
+   	ssize_t okcount = 0;
+   	loff_t offset = *ppos;
+   
+   	mutex_lock(&minors_lock);   
+#ifdef DEBUG_SHRM
+//pr_info("file name:\"%s\",minor:%d\n",filp->f_path.dentry->d_iname,iminor(filp->f_path.dentry->d_inode));
+#endif
+   	/* Ensure we are starting at a valid location */
+   	if ((*ppos < 0) || 
+       	    (*ppos > (drv->mem_size - 1)) || 
+      	    (!drv->kern_buf)) {
+      		err = -EFAULT;
+      		goto error;
+   	}
+   
+   	/* Ensure not reading past end of the image */
+   	if (*ppos + count > drv->mem_size) {
+      		okcount = drv->mem_size - *ppos;
+   	}
+   	else {
+      		okcount = count;
+   	}
+      
+   	offset = *ppos;
+
+   	memcpy_fromio(drv->kern_buf, drv->virt_addr+offset, okcount);
+
+   	err = copy_to_user(buf, drv->kern_buf, okcount);
+	
+	// Hardware memory barrier
+	mb();
+	if (err) {
+      		okcount = 0;
+   	}
+   	else {
+       		*ppos += okcount;
+   	}
+
+   	mutex_unlock(&minors_lock);
+   
+   	return err ? -EFAULT : okcount;
+error:
+   	mutex_unlock(&minors_lock);
+   	return err;
+}
+
+static ssize_t ep_shrm_write(struct file *filp, const char __user *buf,
+			     size_t count, loff_t *ppos) {
+   	struct ep_shrm_drv *drv = filp->private_data;
+   	int err = 0;
+   	ssize_t okcount = 0;
+   	loff_t offset = *ppos;
+#ifdef DEBUG_SHRM
+   pr_info("file name:\"%s\",minor:%d\n",filp->f_path.dentry->d_iname,iminor(filp->f_path.dentry->d_inode));
+#endif
+   	mutex_lock(&minors_lock);
+   
+   	/* Ensure we are starting at a valid location */
+   	if ((*ppos < 0) || 
+      	    (*ppos > (drv->mem_size - 1)) || 
+     	    (!drv->kern_buf)) {
+      		err = -EFAULT;
+      		goto error;
+   	}
+      
+   	/* Ensure not reading past end of the image */
+   	if (*ppos + count > drv->mem_size) {
+      		okcount = drv->mem_size - *ppos;
+   	}
+   	else {
+      		okcount = count;
+   	}
+
+   	/* on failure, set the len to 0 to return empty packet to the device */
+	err = copy_from_user(drv->kern_buf, buf, okcount);
+   	if (err) {
+      		okcount = 0;
+   	}
+   	else {
+       		*ppos+=okcount;
+   	}
+   
+   	memcpy_toio(drv->virt_addr+offset, drv->kern_buf, okcount);
+   	mb();
+	mutex_unlock(&minors_lock);
+   
+   	return err ? -EFAULT : okcount;
+error:
+   	mutex_unlock(&minors_lock);   
+   	return err;
+}
+
+static unsigned int ep_shrm_poll(struct file *filp, poll_table *wait) {
+   	struct ep_shrm_drv *drv = filp->private_data;
+   	unsigned int mask = 0;
+   
+   	poll_wait(filp, &drv->rx_waitq, wait);
+   
+   	if(atomic_read(&drv->counter)) {
+      		mask = POLLIN | POLLRDNORM;
+      		atomic_set(&drv->counter, 0);
+   	}
+   
+   	/*TODO: Do we need to return timeout poll to user app*/
+   	return mask;
+}
+
+static void ep_shrm_clr_irq(struct ep_shrm_drv *data) {
+   	struct ep_shrm_drv *drv = data;
+   	u32 clear_irq_data = 0; 
+   
+   	/*clear FPGA2PS irq 2*/
+   	clear_irq_data |= (1 << IRQ_2_BIT_SHIFT);
+   	iowrite32(clear_irq_data, drv->fpga_irq_clr);   
+   
+  	return;
+}
+
+static irqreturn_t ep_shrm_isr(int irq, void *data) {
+   	struct ep_shrm_drv *drv = data;
+   
+   	spin_lock(&drv->rx_lock);
+   
+   	/*inc count*/
+   	atomic_inc(&drv->counter);
+   
+   	/*wakeup waiting event*/
+   	wake_up_interruptible(&drv->rx_waitq);
+
+   	/*clear irq*/
+   	ep_shrm_clr_irq(drv);
+   
+   	spin_unlock(&drv->rx_lock);
+      
+   	return IRQ_HANDLED;
+}
+
+static int ep_shrm_dtb(struct ep_shrm_drv *drv) {
+   	int result = 0;
+   	int irq = 0;
+   	unsigned char ackirqsteer = 0;
+   	struct device_node *parentnode, *childnode;
+   	struct ep_shrm_drv *privdrv = drv; 
+   	void __iomem *tmp;
+   
+   	parentnode = of_find_compatible_node(NULL, NULL, "nai,nai-ep-shrm-v0.1");	
+   
+   	if (!parentnode) {
+      		dev_warn(privdrv->parent, "failed to find dt file\n");
+      		result = -EAGAIN;
+      		goto err_dtb_parent;
+   	}
+   
+   	/* read master slot from dtb property */
+   	result = of_property_read_u8(parentnode, "ack-irq-steer", &ackirqsteer);
+   	if (result < 0) {
+      		dev_warn(privdrv->parent, "failed to find ack-irq-steer\n");
+      		result = -EAGAIN;
+      		goto err_dtb_ack_steer;
+   	}
+   
+   	privdrv->ackirqsteer = ackirqsteer;
+      
+   	/* get IRQ */
+   	irq = irq_of_parse_and_map(parentnode, 0);
+   
+   	if (irq == 0) {
+      		dev_warn(privdrv->parent, "failed to find IRQ in dtb\n");
+      		result = -EAGAIN;
+      		goto err_dtb_irq;
+   	}
+   
+   	privdrv->irq = irq;
+      
+   	/* request irq  */
+   	result = request_irq(privdrv->irq, ep_shrm_isr, IRQF_SHARED, DRV_NAME, privdrv);
+   	if (result) {
+      		dev_warn(privdrv->parent, "Failed to allocate request irq\n");
+      		goto err_req_irq;
+   	}
+      
+   	/* map fpga register */
+   	childnode = of_get_child_by_name(parentnode, "pcie_ddr_base");
+   	if (childnode != NULL) {
+       		tmp = of_iomap(childnode, 0);
+   
+       		if (!tmp) {
+          		dev_warn(privdrv->parent, "failed iomap pcie_ddr_base\n");
+          		result = -ENOMEM;
+          		goto err_dtb_iomap_pcie_ddr_base;
+       		}
+        	privdrv->fpga_pcie_ddr_base_addr = tmp;
+   	}
+  	else {
+        	privdrv->fpga_pcie_ddr_base_addr = NULL;
+   	}
+#ifdef DEBUG_SHRM
+	pr_info("privdrv->fpga_pcie_ddr_base_addr=0x%p\n",
+		privdrv->fpga_pcie_ddr_base_addr);
+#endif
+   	/* map fpga register */
+   	childnode = of_get_child_by_name(parentnode, "vme_cpci_ddr_base");
+   	if (childnode != NULL) {
+       		tmp = of_iomap(childnode, 0);
+      
+       		if (!tmp) {
+           		dev_warn(privdrv->parent, "failed iomap vme_cpci_ddr_base\n");
+           		result = -ENOMEM;
+           		goto err_dtb_iomap_vme_cpci_ddr_base;
+       		}
+   
+       		privdrv->fpga_vme_cpci_ddr_base_addr = tmp;
+   	}
+   	else {
+       		privdrv->fpga_vme_cpci_ddr_base_addr = NULL;
+   	}
+#ifdef DEBUG_SHRM
+	pr_info("privdrv->fpga_vme_cpci_ddr_base_addr=0x%p\n",
+	      	privdrv->fpga_vme_cpci_ddr_base_addr);
+#endif
+   	/* map fpga register */          
+   	childnode = of_get_child_by_name(parentnode, "fpga_irq_clear_reg");
+      
+   	tmp = of_iomap(childnode, 0);
+   
+   	if (!tmp) {
+      		dev_warn(privdrv->parent, "failed iomap fpga_irq_clear_reg\n");
+      		result = -ENOMEM;
+      		goto err_dtb_iomap_fpga_irq_clear_reg;
+   	}
+   
+   	privdrv->fpga_irq_clr = tmp;
+   
+   	/* map fpga register */          
+   	childnode = of_get_child_by_name(parentnode,"fpga_mod7_vec_addr");
+      
+   	tmp = of_iomap(childnode,0);
+   
+   	if (!tmp) {
+      		dev_warn(privdrv->parent, "failed iomap fpga_mod7_vec_addr\n");
+      		result = -ENOMEM;
+      		goto err_dtb_iomap_fpga_mod7_vec_addr;
+   	}
+   
+   	privdrv->fpga_mod7_vec_addr = tmp;
+   
+   	/* map fpga register */          
+   	childnode = of_get_child_by_name(parentnode, "fpga_mod7_steer_addr");
+      
+   	tmp = of_iomap(childnode,0);
+   
+   	if (!tmp) {
+      		dev_warn(privdrv->parent, "failed iomap fpga_mod7_steer_addr\n");
+      		result = -ENOMEM;
+      		goto err_dtb_iomap_fpga_mod7_steer_addr;
+  	}
+   
+   	privdrv->fpga_mod7_steer_addr = tmp;
+   
+   	/* map fpga register */          
+   	childnode = of_get_child_by_name(parentnode, "fpga_mod7_ack_irq");
+      
+   	tmp = of_iomap(childnode,0);
+   
+   	if (!tmp) {
+      		dev_warn(privdrv->parent, "failed iomap fpga_mod7_ack_irq\n");
+      		result = -ENOMEM;
+      		goto err_dtb_iomap_fpga_mod7_ack_irq;
+   	}
+   
+   	privdrv->fpga_mod7_ack_irq = tmp;
+   
+   	return 0;
+   
+err_dtb_iomap_fpga_mod7_ack_irq:
+   	iounmap(privdrv->fpga_mod7_steer_addr);
+err_dtb_iomap_fpga_mod7_steer_addr:
+   	iounmap(privdrv->fpga_mod7_vec_addr);   
+err_dtb_iomap_fpga_mod7_vec_addr:
+   	iounmap(privdrv->fpga_irq_clr);   
+err_dtb_iomap_fpga_irq_clear_reg:
+   	iounmap(privdrv->fpga_vme_cpci_ddr_base_addr);   
+err_dtb_iomap_vme_cpci_ddr_base:
+   	iounmap(privdrv->fpga_pcie_ddr_base_addr);
+err_dtb_iomap_pcie_ddr_base:
+   	free_irq(privdrv->irq, privdrv);
+err_req_irq:   
+err_dtb_irq:
+err_dtb_ack_steer:
+err_dtb_parent:
+   	return result;
+}
+
+static int init_sysfs(struct platform_device *pdev, struct ep_shrm_drv *drv) {
+   	struct kobject *kobj;
+   	struct ep_shrm_sysfs_entry *entry;
+   	int err;
+   
+   	kobj = kobject_create_and_add("irq", &pdev->dev.kobj);
+   
+   	if(!kobj)
+      		return -ENOMEM;
+   
+   	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+   
+   	if (!entry)
+      		return -ENOMEM;
+   
+   	entry->genIrq = 0;
+   	entry->drv = drv;
+   	entry->kobj_attr = int_genirq_attribute;
+   	err = sysfs_create_file(kobj, &entry->kobj_attr.attr);
+   	if (err) {
+      		kfree(entry);
+      	return err;
+   	}
+
+   	return 0;
+}
+
+static const struct file_operations ep_shrm_fops =
+{
+   .owner =   THIS_MODULE,
+   .open =    ep_shrm_open,
+   .release = ep_shrm_release,
+   .read =    ep_shrm_read,
+   .write =   ep_shrm_write,
+   .poll =    ep_shrm_poll,
+   .llseek =  ep_shrm_llseek,
+};
+
+static int ep_shrm_probe(struct platform_device *pdev) {
+   	int result = 0;
+   	struct device *privdev = &pdev->dev;
+   	struct ep_shrm_drv *drv = NULL;
+   	void *virt_addr_ptr;
+   	phys_addr_t phys_base_addr;
+   	dev_t dev;
+
+   	dev_info(&pdev->dev, "\n");
+
+   	/* Allocate and initialize device */
+   	drv = kzalloc(sizeof(struct ep_shrm_drv), GFP_KERNEL);
+   	if (!drv) {
+      		result = -ENOMEM;
+      		goto err_drv;
+   	}
+   
+   	drv->parent = privdev;
+   
+   	/* get dtb config */
+   	result = ep_shrm_dtb(drv);
+   	if (result < 0) {
+      		dev_warn(&pdev->dev, "Failed to allocate process dtb\n");
+      		goto err_ep_shrm_dtb;
+   	}
+
+   	/* int spin lock */
+   	spin_lock_init(&drv->rx_lock);
+   	/* init wait queue  */
+   	init_waitqueue_head(&drv->rx_waitq);
+   
+   	/* TODO: hard code total memory size  */
+   	drv->mem_size = MEM_ALLOC_SIZE;
+   
+   	/* Allocate contiguous physical memory */   
+   	virt_addr_ptr = dma_zalloc_coherent(&pdev->dev, drv->mem_size,
+					    &(drv->dma), GFP_KERNEL);
+
+   	if (!virt_addr_ptr) {
+      		dev_err(&pdev->dev, "Failed To Allocated Contiguous Memory.\n");
+		pr_err("Failed To Allocated Contiguous Memory.\n");
+      		result = -ENOMEM;
+      		goto err_allocate_mem;
+   	}
+
+   	if (dma_set_mask_and_coherent(&pdev->dev,DMA_BIT_MASK(32))) {
+      		pr_warn("not suitable DMA available for DMA_BIT_MASK(32)0x%llx!!!!\n",
+			DMA_BIT_MASK(32));
+   	}
+
+   	if (dma_set_mask_and_coherent(&pdev->dev,DMA_BIT_MASK(64))) {
+      		pr_warn("not suitable DMA available for DMA_BIT_MASK(64)0x%llx!!!!\n",
+			DMA_BIT_MASK(64));
+   	}
+
+   
+   	drv->virt_addr = virt_addr_ptr;
+   
+   	/* get phys address */
+   	phys_base_addr = virt_to_phys(virt_addr_ptr);          
+	drv->phy_addr = phys_base_addr; 
+#ifdef DEBUG_SHRM
+   	/*dev_info(&pdev->dev, "virt addr 0x%08x \n",(unsigned int)(drv->virt_addr));*/
+	pr_info("virt addr 0x%p\n",drv->virt_addr);
+   	/*dev_info(&pdev->dev, "phy addr 0x%08x \n",phys_base_addr);*/
+	pr_info("phy addr 0x%p!!!!\n",phys_base_addr);
+#endif   
+   	/* set memory start address and mask to FPGA register */
+   	/* for the DDR in the ARM core on the ARM board */
+  	if (drv->fpga_vme_cpci_ddr_base_addr) {
+      		iowrite32((u32)drv->dma,
+           		  (drv->fpga_vme_cpci_ddr_base_addr + FPGA_VME_CPCI_DDR_MAP_OFFSET));
+
+       		iowrite32(DDR_SHRM_MASK,
+           		  (drv->fpga_vme_cpci_ddr_base_addr + FPGA_VME_CPCI_DDR_MSK_OFFSET));
+#ifdef DEBUG_SHRM
+		pr_info("virt_to_phys(drv->fpga_vme_cpci_ddr_base_addr)=0x%08x,"
+			"drv->fpga_vme_cpci_ddr_base_addr=0x%p\n",
+			virt_to_phys(drv->fpga_vme_cpci_ddr_base_addr),
+			drv->fpga_vme_cpci_ddr_base_addr);
+#endif
+   	}
+   	else {
+        	pr_info("cPCI_VME not configured\n");
+   	}
+ 
+   	if(drv->fpga_pcie_ddr_base_addr) { 
+       		/* for the DDR in the ARM core on the Intel board and 79G5 */
+       		iowrite32((u32)drv->dma,
+           		  (drv->fpga_pcie_ddr_base_addr + FPGA_PCIE_DDR_MAP_OFFSET));
+
+       		iowrite32(DDR_SHRM_MASK,
+           		  (drv->fpga_pcie_ddr_base_addr + FPGA_PCIE_DDR_MSK_OFFSET));
+#ifdef DEBUG_SHRM
+		pr_info("virt_to_phys(drv->fpga_pcie_ddr_base_addr)=0x%08x,"
+			"drv->fpga_pcie_ddr_base_addr=0x%p\n",
+			virt_to_phys(drv->fpga_pcie_ddr_base_addr),
+			drv->fpga_pcie_ddr_base_addr);
+#endif
+   	}
+   	else {
+       		pr_info("PCIe not configured"); 
+   	}
+	
+	/* Memset memory */
+   	memset(virt_addr_ptr,0,drv->mem_size);
+   	
+	/* Allocate a char dev  */
+   	result = alloc_chrdev_region(&dev, 0, 1, driver_name);
+   	if (result) {
+      		dev_warn(&pdev->dev, "Failed to allocate char device\n");
+      		goto err_alloc_chrdev;
+   	}
+
+   	drv->cdev_major = MAJOR(dev);
+   	drv->cdev_minor = EP_SHRM_MINOR;
+   
+   	cdev_init(&drv->cdev, &ep_shrm_fops);
+   	drv->cdev.owner = THIS_MODULE;
+
+   	result = cdev_add(&drv->cdev, MKDEV(drv->cdev_major, drv->cdev_minor), 1);
+   	if (result) {
+      		dev_err(&pdev->dev, "chardev registration failed\n");
+      		goto err_add_cdev;
+   	}
+                    
+   	/* Create sysfs class - on udev systems this creates the dev files */
+   	drv->ep_shrm_sysfs_class = class_create(THIS_MODULE, driver_name);
+   	if (IS_ERR(drv->ep_shrm_sysfs_class))
+   	{
+      		dev_err(&pdev->dev, "Error creating class.\n");
+      		result = PTR_ERR(drv->ep_shrm_sysfs_class);
+      		goto err_sysfs_class;
+   	}
+   
+   	sprintf(drv->cdev_name, "%s-%u", driver_name, EP_SHRM_MINOR);
+   	dev_info(&pdev->dev, "dev_name:%s, major:%u, minor:%u\n",
+		 drv->cdev_name, drv->cdev_major, drv->cdev_minor);
+   	dev = MKDEV(drv->cdev_major, drv->cdev_minor);
+   
+   	/* create sysfs device entry */
+   	drv->ep_shrm_sysfs_device = device_create(drv->ep_shrm_sysfs_class, 
+		&pdev->dev, dev, NULL, drv->cdev_name);
+   
+   	if (IS_ERR(drv->ep_shrm_sysfs_device)) {
+      		dev_info(&pdev->dev, "Error creating sysfs device\n");
+      		result = PTR_ERR(drv->ep_shrm_sysfs_device);
+      		goto err_sysfs_device;
+   	}            
+   
+   	init_sysfs(pdev, drv);
+   
+   	/* set dev opened only allow single user app to access this driver */
+   	drv->opened = 0;
+   
+   	platform_set_drvdata(pdev, drv);
+   
+   	return 0;
+
+err_sysfs_device:
+   	class_destroy(drv->ep_shrm_sysfs_class);      
+err_sysfs_class:
+   	cdev_del(&drv->cdev);
+err_add_cdev:
+   	unregister_chrdev(drv->cdev_major,driver_name);
+err_alloc_chrdev:
+   	dma_free_coherent(&pdev->dev, drv->mem_size, drv->virt_addr, drv->dma);
+err_allocate_mem:
+err_ep_shrm_dtb:
+   	kfree(drv);
+err_drv:
+   	return result;
+}
+
+static int ep_shrm_remove(struct platform_device *pdev) {
+   	struct ep_shrm_drv *drv = platform_get_drvdata(pdev);
+
+   	platform_set_drvdata(pdev, NULL);
+
+   	class_destroy(drv->ep_shrm_sysfs_class);      
+
+   	cdev_del(&drv->cdev);
+pr_info("un reg dev:%s-%d\n",driver_name,drv->cdev_major);
+   	unregister_chrdev(drv->cdev_major,driver_name);
+
+   	free_irq(drv->irq, drv);
+
+   	dma_free_coherent(&pdev->dev, drv->mem_size, drv->virt_addr, drv->dma);
+
+   	kfree(drv);
+
+   	return 0;
+}
+
+static const struct of_device_id of_ep_shrm_match[] = {
+   { .compatible = "nai,nai-ep-shrm-v0.1" },
+   { },
+};
+
+MODULE_DEVICE_TABLE(of, of_ep_shrm_match);
+
+static struct platform_driver ep_shrm_platdrv = {
+    	.driver = {
+      		.name  = DRV_NAME,
+      		.owner = THIS_MODULE,
+      		.of_match_table = of_match_ptr(of_ep_shrm_match)
+    	},
+   	.probe    = ep_shrm_probe,
+   	.remove   = ep_shrm_remove,
+};
+
+static int __init nai_ep_shrm_init(void) {
+   	return platform_driver_register(&ep_shrm_platdrv);
+}
+
+
+static void __exit nai_ep_shrm_exit(void) {
+   	platform_driver_unregister(&ep_shrm_platdrv);
+}
+
+/* subsys_initcall() can only be used by a built-in (statically linked) module.
+ * module_init can be used by either built-in or loadable modules.
+ */
+subsys_initcall(nai_ep_shrm_init);
+module_exit(nai_ep_shrm_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("naii@naii.com>");
+MODULE_DESCRIPTION("NAI share memory end-point");
diff --git a/drivers/misc/nai-ep-shrm/nai-ep-shrm.h b/drivers/misc/nai-ep-shrm/nai-ep-shrm.h
new file mode 100644
index 0000000..44648ba
--- /dev/null
+++ b/drivers/misc/nai-ep-shrm/nai-ep-shrm.h
@@ -0,0 +1,20 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAI_EP_SHRM_H__
+#define __NAI_EP_SHRM_H__
+#endif /* __NAI_EP_SHRM_H__ */
diff --git a/drivers/misc/nai-generic-i2c/Kconfig b/drivers/misc/nai-generic-i2c/Kconfig
new file mode 100644
index 0000000..60eb2ba
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/Kconfig
@@ -0,0 +1,15 @@
+menu "NAI GENERIC I2C"
+
+config NAI_GENERIC_SMBUS
+	tristate "NAI devices Over SMBUS"
+	depends on I2C
+        default y
+	help
+	  This option enables generic i2c devices Over SMBUS
+
+config NAI_GENERIC_I2C
+	tristate "NAI devices Over I2C"
+	depends on NAI_GENERIC_SMBUS
+	help
+	  This option enables generic i2c devices Over I2C
+endmenu
diff --git a/drivers/misc/nai-generic-i2c/Makefile b/drivers/misc/nai-generic-i2c/Makefile
new file mode 100644
index 0000000..984a171
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_NAI_GENERIC_SMBUS)	+= nai_generic_smbus.o
+nai_generic_smbus-objs          := nai_smbus.o shared_utils.o shared_smbus.o
+
+## This module needs shared_utils.o, which is compiled in nai_generic_smbus.ko,
+## so nai_generic_i2c.ko depends on nai_generic_smbus.ko
+obj-$(CONFIG_NAI_GENERIC_I2C)   += nai_generic_i2c.o
+nai_generic_i2c-objs            := nai_i2c.o shared_i2c.o #in here CANNOT add shared_utils.o
\ No newline at end of file
diff --git a/drivers/misc/nai-generic-i2c/nai_generic_i2c.c b/drivers/misc/nai-generic-i2c/nai_generic_i2c.c
new file mode 100644
index 0000000..49eb3b5
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/nai_generic_i2c.c
@@ -0,0 +1,666 @@
+/* =========================================================================
+ *
+ * Copyright (c) 2013 North Atlantic Industries, Inc.  All Rights Reserved.
+ *
+ * Author: North Atlantic Industries, Inc.
+ *
+ * SubSystem: I2C Generic Device Driver to handle generic I2C I/O on Linux kernel 2.6.x
+ *
+ * FileName: nai_generic_i2c.c
+ *
+ * History:
+ * 02-23-2017 JinH
+ *   fixed -EBUSY(-16) error to drive the new NAI Power Supply in which the error -ENXIO(-6) was fixed.
+ *
+ * 11-29-2016 JinH first release
+ * ==========================================================================*/
+
+#include <linux/init.h>
+#define pr_fmt(fmt) "NAI %s:%s:%d::" fmt, KBUILD_MODNAME, __func__, __LINE__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#if (KERNEL_VERSION(2,6,18) > LINUX_VERSION_CODE)
+#include <linux/config.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/cdev.h>
+#include <asm/ioctl.h>
+#include <asm/irq.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 3, 0)
+#include <asm/switch_to.h>
+#else
+#include <asm/system.h>
+#endif
+#include <asm/uaccess.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#include <linux/delay.h>
+
+//#define DEBUG_IT
+
+enum I2C_ADAPTERS
+{
+   I2C_INTEL_PERIPHERAL_ADAPTER,
+   I2C_ZYNQ_PERIPHERAL_ADAPTER,
+   I2C_ADAPTER_NUM
+};
+
+#define PROBE_NAME      "nai-gen-i2c"
+
+#if defined(__x86_64__) || defined(__amd_64__)  || defined(__i386__)
+#define I2C_DEVICE_FILE "i2c-adapter-0"
+#elif defined(__arm__)
+#define I2C_DEVICE_FILE "i2c-adapter-1"
+#endif
+
+#ifdef DEBUG_IT
+static void printk_hex_info(const u8* hex_info,unsigned int info_size)
+{
+   #define COLUMN_NUM 16
+   #define DELIMITER ','
+   #define ELEMENT_SIZE 3  /*including 2 bytes hex num and 1 byte field delimiter ',' or '\n'*/
+   char work_buf[ELEMENT_SIZE*COLUMN_NUM+sizeof(int)/*sizeof(int) is used for last str delimiter '\0' and mem alignment*/];
+   unsigned int i;
+
+   memset(work_buf,0,sizeof(work_buf));
+   for(i=0;i<info_size;i++)
+   {
+      sprintf(work_buf+(i*ELEMENT_SIZE)%(COLUMN_NUM*ELEMENT_SIZE),"%02x%c",hex_info[i],(i==(info_size-1)||(i+1)%COLUMN_NUM==0)?'\n':DELIMITER);
+      if(i==(info_size-1)||(i+1)%COLUMN_NUM==0)
+      {
+         printk(KERN_INFO"%s",work_buf);
+         memset(work_buf,0,sizeof(work_buf));
+      }
+   }
+}
+#endif /* #ifdef DEBUG_IT */
+
+#define MAX_I2C_X_BUF_LEN    32
+#define RETRY_LIMIT 3
+
+struct nai_generic_i2c_driver_data
+{
+   struct cdev c_dev;                   /*make the link from address of struct cdev to address of struct ps4i2c_driver_data*/
+   struct class *generic_i2c_class;     /*device class*/
+   dev_t first;                         /*for the first device number*/
+   struct mutex mutex;
+   struct i2c_adapter *i2c_adapter_ptr;
+   u32    user_cnt;
+};
+
+enum NAI_I2C_RD_FMT_INDX
+{
+   /*I2C_ADAPTER_OFF,*/
+   I2C_RD_ADDR_OFF,
+   I2C_RD_ADDR_EXT_OFF,  /*in case for ten bit chip address*/
+   I2C_RD_CMD_OFF,
+   I2C_RD_RESPONSE_LEN_OFF,
+   I2C_RD_ARGC_OFF,
+   I2C_RD_ARGV_OFF,
+ 
+   NAI_I2C_FMT_INDX_TOTAL
+};
+
+enum NAI_I2C_WR_FMT_INDX
+{
+   I2C_WR_ADDR_OFF,
+   I2C_WR_ADDR_EXT_OFF,  /*in case for ten bit chip address*/
+   I2C_WR_CMD_OFF,
+   I2C_WR_ARGC_OFF,
+   I2C_WR_ARGV_OFF,
+ 
+   NAI_I2C_WR_FMT_INDX_TOTAL
+};
+
+enum I2C_REQ_INDX
+{
+   I2C_REQ_0_OFF,
+   I2C_REQ_1_OFF,
+   I2C_REQ_NUM
+};
+
+static s32 smbus_i2c_read_block
+(
+   struct nai_generic_i2c_driver_data* nai_generic_i2c_driver_data_ptr,
+   const u8* in_buf,
+   u16 in_buf_len,
+   u8* out_buf,
+   u16 out_buf_len
+)
+{
+   struct i2c_client i2c_cli;
+   s32 result = 0;
+   int layer_1_retry_cnt;
+   i2c_cli.adapter = nai_generic_i2c_driver_data_ptr->i2c_adapter_ptr;
+
+   i2c_cli.flags = 0; /*bug fix for sending invalid I2C slave address*/
+
+   /*little-endian*/
+   i2c_cli.addr = in_buf[I2C_WR_ADDR_EXT_OFF];
+   i2c_cli.addr <<= 8;
+   i2c_cli.addr |= in_buf[I2C_WR_ADDR_OFF];
+
+   if ( in_buf[ I2C_RD_ADDR_EXT_OFF ] & 0xFF )
+   {
+      i2c_cli.flags |= I2C_M_TEN;
+   }
+#ifdef DEBUG_IT
+   pr_info("input:\n");printk_hex_info(in_buf,in_buf_len);
+   pr_info("out_buf_len:%d\n",out_buf_len);printk_hex_info(out_buf,out_buf_len);
+#endif
+   if ( in_buf[I2C_RD_ARGC_OFF] == 0 )
+   {
+    /*
+     * error codes are defined in:
+     *Intel:
+     *include/asm-generic/errno-base.h
+     *include/asm-generic/errno.h
+     *include/linux/errno.h
+     *ARM:
+     *include/uapi/linux/errno.h
+     *include/uapi/asm-generic/errno-base.h
+     *include/uapi/asm-generic/errno.h
+     *include/linux/errno.h
+     */
+
+      for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+      {
+         result = i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[I2C_RD_CMD_OFF], in_buf[I2C_RD_RESPONSE_LEN_OFF], out_buf );
+         if( result < 0 )
+         {
+            if ( result == -EBUSY )
+            {
+               pr_err("tried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02x,%d) err:%d\n",layer_1_retry_cnt+1,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_RESPONSE_LEN_OFF],result);
+               msleep( 1 );
+            }
+            else
+            {
+               pr_err("i2c_smbus_read_i2c_block_data(0x%x,0x%02x,%d) err:%d\n",i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_RESPONSE_LEN_OFF],result);
+              /*
+               * Not -EBUSY err, retry cannot fix the error in i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[I2C_RD_CMD_OFF], in_buf[I2C_RD_RESPONSE_LEN_OFF], out_buf ).
+               * break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+               */
+              break;
+            }
+           
+         }
+         else
+         {
+#ifdef DEBUG_IT
+            pr_info("i2c_smbus_read_i2c_block_data read %d bytes\n",result);printk_hex_info(out_buf,in_buf[I2C_RD_RESPONSE_LEN_OFF]);
+#endif
+            if ( layer_1_retry_cnt > 0 )
+            {
+               pr_err("recovered -EBUSY after retried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02x,%d)\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_RESPONSE_LEN_OFF]);
+            }
+            break; /* break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ ) */
+         }
+      }
+   }
+   else
+   {
+     for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+     {
+        result = i2c_smbus_write_i2c_block_data( &i2c_cli, in_buf[I2C_RD_CMD_OFF], in_buf[I2C_RD_ARGC_OFF]+1, &in_buf[I2C_RD_ARGC_OFF] );
+#ifdef DEBUG_IT
+        pr_info("write to I2C bus 0x%02x:\n",in_buf[I2C_RD_CMD_OFF]);printk_hex_info(&in_buf[I2C_RD_ARGC_OFF],in_buf[I2C_RD_ARGC_OFF]+1);
+#endif
+        if ( result == 0 )
+        {
+           int layer_2_retry_cnt;
+           for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ )
+           {
+              result = i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[I2C_RD_CMD_OFF], in_buf[I2C_RD_RESPONSE_LEN_OFF], out_buf ); 
+              if ( result < 0 )
+              {
+                 if ( result == -EBUSY )
+                 {
+                   /*
+                    * The error -EBUSY is generated before reading real I2C device in the func "static int i801_check_pre(struct i801_priv *priv)" in file "i2c-i801.c" in INTEL uP.
+                    * The driver "i2c-cadence.c" does not generate -EBUSY in ARM uP.
+                    * Therefore Reading I2C device twice will not happen, so retry op should not confuse the PS4.
+                    */
+                    pr_err("tried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02xx,%d,out_buf) err %d\n",layer_2_retry_cnt+1,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_RESPONSE_LEN_OFF],result);
+                    msleep( 1 );
+                 }
+                 else
+                 {
+                    pr_err("i2c_smbus_read_i2c_block_data(0x%x,0x02x%x,%d,out_buf) err %d\n",i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_RESPONSE_LEN_OFF],result);
+                    /*
+                     * Not -EBUSY err, retry cannot fix the error in i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[I2C_RD_CMD_OFF], in_buf[I2C_RD_RESPONSE_LEN_OFF], out_buf ).
+                     * break for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ )
+                     */
+                    break;
+                 }
+              }
+              else
+              {
+#ifdef DEBUG_IT
+                 pr_info("read %d bytes:\n",result);printk_hex_info(out_buf,in_buf[I2C_RD_RESPONSE_LEN_OFF]);
+#endif
+                 if ( layer_2_retry_cnt > 0 )
+                 {
+                    pr_err("recovered -EBUSY after retried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02xx,%d,out_buf)\n",layer_2_retry_cnt,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_RESPONSE_LEN_OFF]);
+                 }
+
+                 result = in_buf[I2C_RD_RESPONSE_LEN_OFF];
+                 /*
+                  * Successfull finished i2c_smbus_read_i2c_block_data(&i2c_cli,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_RESPONSE_LEN_OFF],out_buf).
+                  * break for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ )
+                  */
+                 break;
+              }
+           } /* for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ ) */
+
+           if ( layer_1_retry_cnt > 0 )
+           {
+              pr_err("recoverd -EBUSY after tried %d, write to i2c addr 0x%x for in_buf[I2C_RD_CMD_OFF]=0x%02x,in_buf[I2C_RD_ARGV_OFF]=0x%02x\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_ARGV_OFF]);
+           }
+
+           break; /*!!!VERY IMPORTANT!!! break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )*/
+        }
+        else
+        {
+           if ( result == -EBUSY )
+           {
+              pr_err("tried %d, write to i2c addr 0x%x for in_buf[I2C_RD_CMD_OFF]=0x%02x,in_buf[I2C_RD_ARGV_OFF]=0x%02x errno=%d\n",layer_1_retry_cnt+1,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_ARGV_OFF],result);
+              msleep( 1 );
+           }
+           else
+           {
+              pr_err("write to i2c addr 0x%x for in_buf[I2C_RD_CMD_OFF]=0x%02x,in_buf[I2C_RD_ARGV_OFF]=0x%02x errno=%d\n",i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_ARGV_OFF],result);
+              /*
+               * Not -EBUSY err, retry cannot fix the error in i2c_smbus_write_i2c_block_data(&i2c_cli,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_RD_ARGC_OFF]+1,&in_buf[I2C_RD_ARGC_OFF]).
+               * break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+               */
+              break;
+           }
+        }
+     } /*for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )*/
+  } 
+  return result;
+}
+
+static s32 smbus_i2c_write_block
+(
+   struct nai_generic_i2c_driver_data* nai_generic_i2c_driver_data_ptr,
+   const u8* in_buf,
+   u16 in_buf_len
+)
+{
+   s32 result = -1;
+   int layer_1_retry_cnt;
+   struct i2c_client i2c_cli;
+   i2c_cli.adapter = nai_generic_i2c_driver_data_ptr->i2c_adapter_ptr;
+
+   i2c_cli.flags=0; /*bug fix for sending invalid I2C slave address*/
+
+   /*little-endian*/
+   i2c_cli.addr = in_buf[I2C_WR_ADDR_EXT_OFF];
+   i2c_cli.addr <<= 8;
+   i2c_cli.addr |= in_buf[I2C_WR_ADDR_OFF];
+
+   if ( in_buf[ I2C_WR_ADDR_EXT_OFF ] & 0xFF )
+   {
+      i2c_cli.flags |= I2C_M_TEN;
+   }
+#ifdef DEBUG_IT
+   pr_info("in_buf:\n");printk_hex_info(in_buf,in_buf_len);
+#endif
+   for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+   {
+      result = i2c_smbus_write_i2c_block_data( &i2c_cli, in_buf[I2C_WR_CMD_OFF], in_buf[I2C_WR_ARGC_OFF], &in_buf[I2C_WR_ARGV_OFF] );
+      if ( result == 0 )
+      {
+#ifdef DEBUG_IT
+         pr_info("wr cmd 0x%x ok with para:\n",in_buf[I2C_WR_CMD_OFF]);printk_hex_info(&in_buf[I2C_WR_ARGV_OFF],in_buf[I2C_WR_ARGC_OFF]);
+#endif
+         if ( layer_1_retry_cnt > 0 )
+         {
+            pr_err("recovered after tried %d, i2c_smbus_write_i2c_block_data(0x%x,0x%02x,0x%02x,%02x)\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_WR_ARGC_OFF],in_buf[I2C_WR_ARGV_OFF]);
+         }
+         result = in_buf[I2C_WR_ARGC_OFF];
+         break; /*VERY IMPORTANT !!! break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )*/
+      }
+      else
+      {
+         if ( result == -EBUSY )
+         {
+            pr_err("tried %d, i2c_smbus_write_i2c_block_data(0x%x,0x%02x,0x%02x,%02x),errno=%d\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_WR_ARGC_OFF],in_buf[I2C_WR_ARGV_OFF],result);
+            msleep( 1 );
+         }
+         else
+         {
+            pr_err("i2c_smbus_write_i2c_block_data(0x%x,0x%02x,0x%02x,%02x),errno=%d\n",i2c_cli.addr,in_buf[I2C_RD_CMD_OFF],in_buf[I2C_WR_ARGC_OFF],in_buf[I2C_WR_ARGV_OFF],result);
+            /*
+             * Not -EBUSY err, retry cannot fix the error in i2c_smbus_write_i2c_block_data( &i2c_cli, in_buf[I2C_WR_CMD_OFF], in_buf[I2C_WR_ARGC_OFF], &in_buf[I2C_WR_ARGV_OFF] ); 
+             * break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ ) 
+             */
+            break;
+         }
+      }
+   }
+   return result;
+}
+
+static int i2c_open(struct inode *inode, struct file *filp)
+{
+   int status = 0;
+   /*
+    * setup filp->private_data for other funcs such as file_operations.read, file_operations.write and file_operations.ioctl to access
+    * fields in struct nai_generic_i2c_driver_data
+    */
+   filp->private_data=(struct nai_generic_i2c_driver_data*)container_of(inode->i_cdev,struct nai_generic_i2c_driver_data,c_dev);
+#ifdef DEBUG_IT
+   pr_info("nai_generic_i2c_driver_data vir_addr=0x%p\n",filp->private_data);
+#endif
+
+   mutex_lock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+   if ( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt == 0 )
+   {
+#if defined(__x86_64__) || defined(__amd_64__)  || defined(__i386__)
+      ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr=i2c_get_adapter(I2C_INTEL_PERIPHERAL_ADAPTER);
+#elif defined(__arm__)
+      ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr=i2c_get_adapter(I2C_ZYNQ_PERIPHERAL_ADAPTER);
+#endif
+
+      if ( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr == NULL )
+      {
+#if defined(__x86_64__) || defined(__amd_64__)  || defined(__i386__)
+         pr_err("can't Attach I2C Adapter %d\n",I2C_INTEL_PERIPHERAL_ADAPTER);
+#elif defined(__arm__)
+         pr_err("can't Attach I2C Adapter %d\n",I2C_ZYNQ_PERIPHERAL_ADAPTER);
+#endif
+         status = -ENODEV; /*no such device, include/uapi/asm-generic/errno-base.h*/
+         goto done;
+      }
+#ifdef DEBUG_IT
+      if ( i2c_check_functionality( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr, I2C_FUNC_SMBUS_PEC ) )
+      {
+         pr_info("PEC set\n");
+      }
+      else
+      {
+         pr_info("PEC not set\n");
+      }
+#endif
+      ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt++;
+   }
+
+done:
+   mutex_unlock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+
+   return status ;
+}
+
+static int i2c_close(struct inode *i, struct file *filp)
+{
+   /* not safe in multi processor, set it to 0 only opened dev cnt is 0 */
+   mutex_lock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+   ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt--;
+   if ( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt == 0 )
+   {
+      i2c_put_adapter(((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr);
+
+#ifdef DEBUG_IT
+      pr_info("nai_generic_i2c_driver_data vir_addr=0x%p\n",filp->private_data);
+#endif
+   }
+   mutex_unlock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+   return 0;
+}
+
+static ssize_t i2c_read(struct file *filp, char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=4;
+   struct nai_generic_i2c_driver_data *private_data_ptr=filp->private_data;
+   
+   uint8_t in_buf[MAX_I2C_X_BUF_LEN];
+   uint8_t out_buf[MAX_I2C_X_BUF_LEN];
+
+   memset(out_buf,0,sizeof(out_buf));
+   memset(in_buf,0,sizeof(in_buf));
+   mutex_lock(&private_data_ptr->mutex);
+
+   if ( len < I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF] )
+   {
+      pr_err("error input format\n");
+      result = -EINVAL;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("len: %d\n",len);
+#endif
+   if(copy_from_user(in_buf,usr_buf,I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF]))
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("nai_generic_i2c_driver_data vir_addr=0x%p,input len %d:\n",private_data_ptr,len);printk_hex_info(in_buf,I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF]);
+#endif
+
+   if ( ( result = smbus_i2c_read_block( private_data_ptr, in_buf,I2C_RD_ARGV_OFF+in_buf[I2C_RD_ARGC_OFF],out_buf,in_buf[I2C_RD_RESPONSE_LEN_OFF] ) ) != in_buf[I2C_RD_RESPONSE_LEN_OFF] )
+   {
+      pr_err("err in smbus_i2c_read_block() %d\n",result);
+      goto done;
+   }
+
+   if(copy_to_user(usr_buf,out_buf,in_buf[I2C_RD_RESPONSE_LEN_OFF]))
+   {
+      pr_err("err copy_to_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("read result:\n");printk_hex_info(out_buf,in_buf[I2C_RD_RESPONSE_LEN_OFF]);
+#endif
+   result = in_buf[I2C_RD_RESPONSE_LEN_OFF];
+done:
+   mutex_unlock(&private_data_ptr->mutex);
+
+   if( result < 0 )
+      pr_err("result err: %d\n",result);
+
+   return result;
+}
+
+static ssize_t i2c_write(struct file *filp, const char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=0;
+
+   uint8_t in_buf[MAX_I2C_X_BUF_LEN];
+
+   struct nai_generic_i2c_driver_data *private_data_ptr=filp->private_data;
+
+   mutex_lock(&private_data_ptr->mutex);
+   if ( len < I2C_WR_ARGV_OFF+usr_buf[I2C_WR_ARGC_OFF] )
+   {
+      pr_err("len=%zd, I2C_WR_ARGV_OFF=%d,usr_buf[I2C_WR_ARGC_OFF]=%d,error input format\n",len,I2C_WR_ARGV_OFF,usr_buf[I2C_WR_ARGC_OFF]);
+      result = -EINVAL;
+      goto done;
+   }
+
+   if ( copy_from_user(in_buf,usr_buf,I2C_WR_ARGV_OFF+usr_buf[I2C_WR_ARGC_OFF]) )
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("in buf:\n");printk_hex_info(in_buf,I2C_WR_ARGV_OFF+usr_buf[I2C_WR_ARGC_OFF]);
+#endif
+   if ( ( result = smbus_i2c_write_block( private_data_ptr, in_buf,I2C_WR_ARGV_OFF+in_buf[I2C_WR_ARGC_OFF] ) ) != in_buf[I2C_WR_ARGC_OFF] )
+   {
+      pr_err("err in smbus_i2c_write_block() %d\n",result);
+   }
+
+   mutex_unlock(&private_data_ptr->mutex);
+
+done:
+   return result;
+}
+
+static struct file_operations nai_generic_i2c_file_ops =
+{
+   .owner = THIS_MODULE,
+   .open = i2c_open,
+   .release = i2c_close,
+   .read = i2c_read,
+   .write = i2c_write,
+};
+
+static int nai_gen_i2c_driver_probe(struct platform_device *pdev)
+{
+   int ret=0;
+   struct nai_generic_i2c_driver_data *private_data_ptr;
+#ifdef DEBUG_IT
+   pr_info("Probe Device: \"%s\"\n",pdev->name);
+#endif
+   /*
+    * devm_kzalloc() is resource-managed kzalloc(). The memory allocated with resource-managed
+    * functions is associated with the device. When the device is detached from the system or the
+    * driver for the device is unloaded, that memory is freed automatically. It is possible to
+    * free the memory with devm_kfree() if it's no longer needed.
+    * private_data_ptr=devm_kzalloc(&pdev->dev,sizeof(*private_data_ptr),GFP_KERNEL);
+    */
+   private_data_ptr=kzalloc(sizeof(*private_data_ptr),GFP_KERNEL);
+
+   if ( private_data_ptr==NULL )
+   {
+      pr_err("kmalloc(struct nai_generic_i2c_driver_data,GFP_KERNEL) err\n");
+      ret= -ENOMEM;
+      goto err_step_1;
+   }
+
+#ifdef DEBUG_IT
+    pr_info("private_data_ptr vir_addr=0x%p,platform_device addr=0x%p\n",private_data_ptr,pdev);
+#endif
+                                                                 /*check man page, vs register_chrdev*/
+   if ((ret = alloc_chrdev_region(&private_data_ptr->first, 0, 1, "i2c-dev-parent")) < 0)
+   {
+      pr_err("alloc_chrdev_region() err=%d\n",ret);
+      goto err_step_2;
+   }
+
+   if (IS_ERR(private_data_ptr->generic_i2c_class = class_create(THIS_MODULE, I2C_DEVICE_FILE)))
+   {
+      pr_err("class_create() err=%ld\n",PTR_ERR(private_data_ptr->generic_i2c_class));
+      ret=PTR_ERR(private_data_ptr->generic_i2c_class);
+      goto err_step_3;
+   }
+
+   if (IS_ERR(device_create(private_data_ptr->generic_i2c_class, NULL, private_data_ptr->first, NULL, I2C_DEVICE_FILE)))
+   {
+      ret = PTR_ERR(device_create(private_data_ptr->generic_i2c_class, NULL, private_data_ptr->first, NULL, I2C_DEVICE_FILE));
+      pr_err("device_create() err=%d\n",ret);
+      goto err_step_4;
+   }
+
+   cdev_init(&private_data_ptr->c_dev,&nai_generic_i2c_file_ops);
+   if ((ret = cdev_add(&private_data_ptr->c_dev, private_data_ptr->first, 1)) < 0)
+   {
+      pr_err("cdev_add() err=%d\n",ret);
+      goto err_step_5;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("Probe Device: \"%s\",I2C_DEVICE_FILE=\"%s\"\n",pdev->name,I2C_DEVICE_FILE);
+#endif
+   platform_set_drvdata(pdev,private_data_ptr);
+   mutex_init(&private_data_ptr->mutex);
+   return 0;
+
+err_step_5:
+   device_destroy(private_data_ptr->generic_i2c_class, private_data_ptr->first);
+err_step_4:
+   class_destroy(private_data_ptr->generic_i2c_class);
+err_step_3:
+   unregister_chrdev_region(private_data_ptr->first,1);
+err_step_2:
+   kfree(private_data_ptr);
+err_step_1:
+   return ret;
+}
+
+static int nai_gen_i2c_driver_remove(struct platform_device *pdev)
+{
+   struct nai_generic_i2c_driver_data *private_data_ptr=platform_get_drvdata(pdev);
+#ifdef DEBUG_IT
+   pr_info("Remove Device: \"%s\"\n",pdev->name);
+#endif
+   /*without these release resource API calls, kernel panic when the module is removed by rmmod cmd or is re inserted by insmod cmd.*/
+   cdev_del(&private_data_ptr->c_dev);
+   device_destroy(private_data_ptr->generic_i2c_class, private_data_ptr->first);
+   class_destroy(private_data_ptr->generic_i2c_class);
+   unregister_chrdev_region(private_data_ptr->first,1);
+#ifdef DEBUG_IT
+   pr_info("unregistered\n");
+#endif
+   return 0;
+}
+
+static void nai_gen_i2c_device_release(struct device *dev)
+{
+#ifdef DEBUG_IT
+   struct platform_device *derived_dev=container_of(dev,struct platform_device,dev);
+   pr_info("Release Device: \"%s\"\n",derived_dev->name);
+#endif
+}
+
+static struct platform_driver nai_gen_i2c_driver_driver =
+{
+   .driver =
+   {
+      .name = PROBE_NAME, /*The idriver name must match struct platform_device.name*/
+      .owner = THIS_MODULE,
+   },
+   .probe = nai_gen_i2c_driver_probe,
+   .remove = nai_gen_i2c_driver_remove,
+};
+
+static struct platform_device nai_gen_i2c_driver_device =
+{
+   .name = PROBE_NAME, /*The device name must match struct platform_driver.driver.name*/
+   .id = 0,
+   .dev =
+   {
+      .release = nai_gen_i2c_device_release,
+   },
+};
+
+static int __init nai_gen_i2c_driver_init(void)
+{
+#ifdef DEBUG_IT
+   pr_info("Driver test init\n");
+#endif
+   platform_device_register(&nai_gen_i2c_driver_device); /*device is diff from driver*/
+   platform_driver_register(&nai_gen_i2c_driver_driver); /*dirver is diff from device*/
+   return 0;
+}
+
+static void __exit nai_gen_i2c_driver_exit(void)
+{
+#ifdef DEBUG_IT
+   pr_info("Driver Test Exit\n");
+#endif
+   platform_driver_unregister(&nai_gen_i2c_driver_driver);
+   platform_device_unregister(&nai_gen_i2c_driver_device);
+}
+
+module_init(nai_gen_i2c_driver_init);
+module_exit(nai_gen_i2c_driver_exit);
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.40");
diff --git a/drivers/misc/nai-generic-i2c/nai_generic_i2c.h b/drivers/misc/nai-generic-i2c/nai_generic_i2c.h
new file mode 100644
index 0000000..a90ad52
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/nai_generic_i2c.h
@@ -0,0 +1,64 @@
+#ifndef _NAI_GENERIC_I2C_H_
+#define _NAI_GENERIC_I2C_H_
+
+/* This Protocol can be used for both standard and NAI Internal SMBUS read operations.
+ * In standard SMBUS, value in SMBUS_RD_ARGC_OFF is 0 and no data in SMBUS_RD_ARGV_OFF. 
+ */
+enum NAI_SMBUS_RD_FMT_INDX
+{
+   SMBUS_RD_ADDR_OFF,
+   SMBUS_RD_ADDR_EXT_OFF,  /*In case for ten bit chip address*/
+   SMBUS_RD_CMD_OFF,       /*CommandCode in SMBUS Specification BlockRead*/
+   SMBUS_RD_LEN_OFF,       /*ByteCount in SMBUS Specification BlockRead*/
+   SMBUS_RD_ARGC_OFF,      /*In NAI internal protocol, SMBUS_RD_ARGC_OFF includes the size of ByteCount and DataByte[1:N] in SMBUS Specification BlockWrite*/
+   SMBUS_RD_ARGV_OFF,      /*In NAI internal protocol, SMBUS_RD_ARGV_OFF contains ByteCount and DataByte[1:N] in SMBUS Specification BlockWrite*/
+
+   NAI_SMBUS_RD_MGR_HEADER_SZ
+};
+
+/* This Protocol can be used for both standard and NAI Internal SMBUS write operations.
+ * In standard SMBUS, value in SMBUS_WR_DATA_LEN_OFF is written data size.
+ * In standard SMBUS, value(s) in SMBUS_WR_DATA_OFF is/are written data.
+ */
+enum NAI_SMBUS_WR_FMT_INDX
+{
+   SMBUS_WR_ADDR_OFF,
+   SMBUS_WR_ADDR_EXT_OFF,  /*In case for ten bit chip address*/
+   SMBUS_WR_CMD_OFF,       /*CommandCode in SMBUS Specification BlockWrite*/
+   SMBUS_WR_DATA_LEN_OFF,  /*In NAI internal protocol, SMBUS_WR_DATA_LEN_OFF includes the size of ByteCount and DataByte[1:N] in SMBUS Specification BlockWrite*/
+   SMBUS_WR_DATA_OFF,      /*In NAI internal protocol, SMBUS_WR_DATA_OFF contains ByteCount and DataByte[1:N] in SMBUS Specification BlockWrite*/
+
+   NAI_SMBUS_WR_MGR_HEADER_SZ
+};
+
+enum I2C_RD_FMT_INDX
+{
+   /*I2C_ADAPTER_OFF,*/
+   I2C_RD_ADDR_OFF,
+   I2C_RD_ADDR_EXT_OFF,  /*in case for ten bit chip address*/
+   I2C_RD_CMD_OFF,
+   I2C_RD_LEN_LSB_OFF,
+   I2C_RD_LEN_MSB_OFF,
+   I2C_RD_ARGC_OFF,      /*put/add 1 as the parameter count for offset LSB*/
+   I2C_RD_ARGV_OFF,      /*put offset LSB to here*/
+   NAI_I2C_RD_MGR_HEADER_SZ
+};
+
+enum I2C_WR_FMT_INDX
+{
+   I2C_WR_ADDR_OFF,
+   I2C_WR_ADDR_EXT_OFF,      /*in case for ten bit chip address*/
+   I2C_WR_CMD_OFF,           /*put offset MSB byte in here*/
+   I2C_WR_LEN_LSB_OFF,       /*put (whole write data size + 1) LSB in here, 1 to indicate offset LSB*/
+   I2C_WR_LEN_MSB_OFF,       /*put (whole write data size + 1) MSB in here, 1 to indicate offset LSB*/
+   I2C_WR_ARGC_OFF,          /*put/add 1 as the parameter count for offset LSB*/
+   I2C_WR_ARGV_OFF,          /*put offset LSB in first byte then put write data to here*/
+   NAI_I2C_WR_MGR_HEADER_SZ
+};
+
+//#define SUPPORT_I2C_DEVICE_FILE
+
+#define NAI_I2C_SMBUS_RD_WR_MGR_BUF_LEN     32
+#define SMBUS_TRX_BUF_LEN_MAX               I2C_SMBUS_BLOCK_MAX /*I2C_SMBUS_BLOCK_MAX defined by the kernel file "i2c.h"*/
+#define I2C_TRX_BUF_LEN_MAX                 512
+#endif/* _NAI_GENERIC_I2C_H_*/
diff --git a/drivers/misc/nai-generic-i2c/nai_i2c.c b/drivers/misc/nai-generic-i2c/nai_i2c.c
new file mode 100644
index 0000000..fbdcb75
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/nai_i2c.c
@@ -0,0 +1,318 @@
+/* =========================================================================
+ *
+ * Copyright (c) 2013 North Atlantic Industries, Inc.  All Rights Reserved.
+ *
+ * Author: North Atlantic Industries, Inc.
+ *
+ * SubSystem: I2C Generic Device Driver to handle generic I2C I/O on Linux kernel 2.6.x
+ *
+ * FileName: nai_generic_i2c.c
+ *
+ * History:
+ * 02-23-2017 JinH
+ *   fixed -EBUSY(-16) error to drive the new NAI Power Supply in which the error -ENXIO(-6) was fixed.
+ * 11-29-2016 JinH first release
+ * ==========================================================================*/
+
+#include <linux/init.h>
+#define pr_fmt(fmt) "%s:%d>" fmt,strrchr(__FILE__,'/'),__LINE__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#if (KERNEL_VERSION(2,6,18) > LINUX_VERSION_CODE)
+#include <linux/config.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/cdev.h>
+#include <asm/ioctl.h>
+#include <asm/irq.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 3, 0)
+#include <asm/switch_to.h>
+#else
+#include <asm/system.h>
+#endif
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/platform_data/at24.h>
+#include <nai_generic_i2c.h>
+#include "shared_utils.h"
+#include "shared_i2c.h"
+#include "shared_smbus.h"
+
+#define PROBE_NAME        "nai-eeprom-i2c"
+
+#ifdef SUPPORT_I2C_DEVICE_FILE
+#define I2C_DEVICE_FILE   "i2c-adapter-0-i2c"
+#endif/*#ifdef SUPPORT_I2C_DEVICE_FILE*/
+#define SMBUS_DEVICE_FILE "i2c-adapter-0-smbus"
+
+#define NUM_ADDRESSES 2 //TBD for serial num
+
+struct drv_data
+{
+   struct mutex *shared_mutex;
+#ifdef SUPPORT_I2C_DEVICE_FILE
+   /*to create the device /dev/i2c-adapter-0-i2c for future's enhancement*/
+   struct i2c_smbus_drv_data* i2c_drv_data_ptr;
+#endif/*#ifdef SUPPORT_I2C_DEVICE_FILE*/
+   struct i2c_smbus_drv_data* smbus_drv_data_ptr;
+};
+
+static int nai_i2c_smbus_dev_open(struct inode *inode, struct file *filp) //TBD, combine another open func together when Intel board is added
+{
+   int status = 0;
+   /*
+    * setup filp->private_data for other funcs such as file_operations.read, file_operations.write and file_operations.ioctl to access
+    * fields in struct i2c_smbus_drv_data
+    */
+   filp->private_data=(struct i2c_smbus_drv_data*)container_of(inode->i_cdev,struct i2c_smbus_drv_data,c_dev);
+#ifdef DEBUG_IT
+   pr_info("i2c_drv_data vir_addr=0x%p\n",filp->private_data);
+   pr_info("((struct i2c_smbus_drv_data*)(filp->private_data))->mutex_ptr=0x%p\n",((struct i2c_smbus_drv_data*)(filp->private_data))->mutex_ptr);
+   pr_info("file name \"%s\"\n",filp->f_path.dentry->d_iname);
+#endif
+
+   mutex_lock(((struct i2c_smbus_drv_data*)(filp->private_data))->mutex_ptr);
+   if ( ((struct i2c_smbus_drv_data*)(filp->private_data))->user_cnt == 0 )
+   {
+      ((struct i2c_smbus_drv_data*)(filp->private_data))->i2c_adapter_ptr=i2c_get_adapter(I2C_ADAPTER_0);
+
+      if ( ((struct i2c_smbus_drv_data*)(filp->private_data))->i2c_adapter_ptr == NULL )
+      {
+         pr_err("can't Attach I2C Adapter %d\n",I2C_ADAPTER_0);
+         status = -ENODEV; /*no such device, include/uapi/asm-generic/errno-base.h*/
+         goto done;
+      }
+#ifdef DEBUG_IT
+      if ( i2c_check_functionality( ((struct i2c_smbus_drv_data*)(filp->private_data))->i2c_adapter_ptr, I2C_FUNC_SMBUS_PEC ) )
+      {
+         pr_info("PEC set\n");
+      }
+      else
+      {
+         pr_info("PEC not set\n");
+      }
+#endif
+      ((struct i2c_smbus_drv_data*)(filp->private_data))->user_cnt++;
+   }
+
+done:
+   mutex_unlock(((struct i2c_smbus_drv_data*)(filp->private_data))->mutex_ptr);
+
+   return status ;
+}
+
+static int nai_i2c_smbus_dev_close(struct inode *i, struct file *filp)
+{
+   /* not safe in multi processor, set it to 0 only opened dev cnt is 0 */
+   mutex_lock(((struct i2c_smbus_drv_data*)(filp->private_data))->mutex_ptr);
+   ((struct i2c_smbus_drv_data*)(filp->private_data))->user_cnt--;
+   if ( ((struct i2c_smbus_drv_data*)(filp->private_data))->user_cnt == 0 )
+   {
+      i2c_put_adapter(((struct i2c_smbus_drv_data*)(filp->private_data))->i2c_adapter_ptr);
+   }
+
+#ifdef DEBUG_IT
+   pr_info("i2c_drv_data vir_addr=0x%p\n",filp->private_data);
+   pr_info("file name \"%s\"\n",filp->f_path.dentry->d_iname);
+   pr_info("user_cnt=%d\n",((struct i2c_smbus_drv_data*)(filp->private_data))->user_cnt);
+#endif
+   mutex_unlock(((struct i2c_smbus_drv_data*)(filp->private_data))->mutex_ptr);
+   return 0;
+}
+
+#ifdef SUPPORT_I2C_DEVICE_FILE
+static struct file_operations i2c_dev_file_ops =
+{
+   .owner =   THIS_MODULE,
+   .open =    nai_i2c_smbus_dev_open,
+   .release = nai_i2c_smbus_dev_close,
+   .read =    nai_i2c_dev_read,
+   .write =   nai_i2c_dev_write,
+};
+#endif /*#ifdef SUPPORT_I2C_DEVICE_FILE*/
+
+static struct file_operations smbus_dev_file_ops =
+{
+   .owner =   THIS_MODULE,
+   .open =    nai_i2c_smbus_dev_open,
+   .release = nai_i2c_smbus_dev_close,
+   .read =    nai_smbus_dev_read,
+   .write =   nai_smbus_dev_write,
+};
+
+static int nai_gen_i2c_driver_probe(struct platform_device *pdev)
+{
+   int status=0;
+   struct drv_data* drv_data_ptr;
+#ifdef DEBUG_IT
+   pr_info("Probe Device: \"%s\"\n",pdev->name);
+#endif
+
+    drv_data_ptr = kzalloc( sizeof( struct drv_data ), GFP_KERNEL );
+    if( drv_data_ptr == NULL )
+    {
+       status= -ENOMEM;
+       goto err_step_1;
+    }
+
+    drv_data_ptr->shared_mutex = kzalloc( sizeof( struct mutex ), GFP_KERNEL );
+    if( drv_data_ptr->shared_mutex == NULL )
+    {
+       status= -ENOMEM;
+       goto err_step_2;
+    }
+
+    mutex_init(drv_data_ptr->shared_mutex);
+#ifdef SUPPORT_I2C_DEVICE_FILE
+    drv_data_ptr->i2c_drv_data_ptr = create_dev_fs
+    (
+       I2C_DEVICE_FILE,
+       "i2c-dev-parent",
+       &i2c_dev_file_ops,
+       NUM_ADDRESSES,
+       0,/*AT24_FLAG_ADDR16,This flag depends on the chip's capacity and affects i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)*/
+       &status
+    );
+
+    if( drv_data_ptr->i2c_drv_data_ptr == NULL )
+    {
+       goto err_step_3;
+    }
+#ifdef DEBUG_IT
+   pr_info("Probe Device: \"%s\",I2C_DEVICE_FILE=\"%s\"\n",pdev->name,I2C_DEVICE_FILE);
+#endif
+#endif/*#ifdef SUPPORT_I2C_DEVICE_FILE*/
+    drv_data_ptr->smbus_drv_data_ptr = create_dev_fs
+    (
+       SMBUS_DEVICE_FILE,
+       "i2c-dev-parent",
+       &smbus_dev_file_ops,
+       NUM_ADDRESSES,
+       0,
+       &status
+    );
+
+    if( drv_data_ptr->smbus_drv_data_ptr == NULL )
+    {
+       goto err_step_4;
+    }
+#ifdef DEBUG_IT
+   pr_info("Probe Device: \"%s\",SMBUS_DEVICE_FILE=\"%s\"\n",pdev->name,SMBUS_DEVICE_FILE);
+#endif
+#ifdef SUPPORT_I2C_DEVICE_FILE
+   drv_data_ptr->i2c_drv_data_ptr->mutex_ptr = drv_data_ptr->shared_mutex;
+#endif /*#ifdef SUPPORT_I2C_DEVICE_FILE*/
+   drv_data_ptr->smbus_drv_data_ptr->mutex_ptr = drv_data_ptr->shared_mutex;
+
+   platform_set_drvdata(pdev,drv_data_ptr);
+   return 0;
+
+err_step_4:
+#ifdef SUPPORT_I2C_DEVICE_FILE
+    kfree( drv_data_ptr->i2c_drv_data_ptr );
+#endif/*#ifdef SUPPORT_I2C_DEVICE_FILE*/
+#ifdef SUPPORT_I2C_DEVICE_FILE
+err_step_3:
+    kfree( drv_data_ptr->shared_mutex );
+#endif
+err_step_2:
+   kfree(drv_data_ptr);
+err_step_1:
+   return status;
+}
+#if 0
+void static delete_char_dev( struct i2c_smbus_drv_data* i2c_smbus_drv_data_ptr )
+{
+   cdev_del(&i2c_smbus_drv_data_ptr->c_dev);
+   device_destroy(i2c_smbus_drv_data_ptr->generic_i2c_class, i2c_smbus_drv_data_ptr->first);
+   class_destroy(i2c_smbus_drv_data_ptr->generic_i2c_class);
+   unregister_chrdev_region(i2c_smbus_drv_data_ptr->first,1);
+   kfree(i2c_smbus_drv_data_ptr);
+}
+#endif
+static int nai_gen_i2c_driver_remove(struct platform_device *pdev)
+{
+   struct drv_data* drv_data_ptr=platform_get_drvdata(pdev);
+
+   /*without release resource calls, kernel panic when the module is removed by rmmod cmd or is re inserted by insmod cmd.*/
+#ifdef SUPPORT_I2C_DEVICE_FILE
+   delete_char_dev( drv_data_ptr->i2c_drv_data_ptr );
+#endif/*#ifdef SUPPORT_I2C_DEVICE_FILE*/
+   delete_char_dev( drv_data_ptr->smbus_drv_data_ptr );
+
+   mutex_destroy(drv_data_ptr->shared_mutex);
+   kfree(drv_data_ptr->shared_mutex);
+
+   kfree(drv_data_ptr);
+#ifdef DEBUG_IT
+   pr_info("Remove Device: \"%s\"\n",pdev->name);
+   pr_info("unregistered\n");
+#endif
+   return 0;
+}
+
+static void nai_gen_i2c_device_release(struct device *dev)
+{
+#ifdef DEBUG_IT
+   struct platform_device *derived_dev=container_of(dev,struct platform_device,dev);
+   pr_info("Release Device: \"%s\"\n",derived_dev->name);
+#endif
+}
+
+static struct platform_driver nai_gen_i2c_driver_driver =
+{
+   .driver =
+   {
+      .name = PROBE_NAME, /*The idriver name must match struct platform_device.name*/
+      .owner = THIS_MODULE,
+   },
+   .probe = nai_gen_i2c_driver_probe,
+   .remove = nai_gen_i2c_driver_remove,
+};
+
+static struct platform_device nai_gen_i2c_driver_device =
+{
+   .name = PROBE_NAME, /*The device name must match struct platform_driver.driver.name*/
+   .id = 0,
+   .dev =
+   {
+      .release = nai_gen_i2c_device_release,
+   },
+};
+
+static int __init nai_gen_i2c_driver_init(void)
+{
+#ifdef DEBUG_IT
+   pr_info("Driver test init: iomem_resource.start=%u,iomem_resource.end=%u(0x%x)\n",iomem_resource.start,iomem_resource.end,iomem_resource.end);
+#endif
+   platform_device_register(&nai_gen_i2c_driver_device); /*device is diff from driver*/
+   platform_driver_register(&nai_gen_i2c_driver_driver); /*dirver is diff from device*/
+#ifdef DEBUG_IT
+   pr_info("Driver test init: iomem_resource.start=%u,iomem_resource.end=%u(0x%x)\n",iomem_resource.start,iomem_resource.end,iomem_resource.end);
+#endif
+   return 0;
+}
+
+static void __exit nai_gen_i2c_driver_exit(void)
+{
+#ifdef DEBUG_IT
+   pr_info("Driver Test Exit\n");
+#endif
+   platform_driver_unregister(&nai_gen_i2c_driver_driver);
+   platform_device_unregister(&nai_gen_i2c_driver_device);
+}
+
+module_init(nai_gen_i2c_driver_init);
+module_exit(nai_gen_i2c_driver_exit);
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.40");
diff --git a/drivers/misc/nai-generic-i2c/nai_smbus.c b/drivers/misc/nai-generic-i2c/nai_smbus.c
new file mode 100644
index 0000000..29605f8
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/nai_smbus.c
@@ -0,0 +1,533 @@
+/* =========================================================================
+ *
+ * Copyright (c) 2013 North Atlantic Industries, Inc.  All Rights Reserved.
+ *
+ * Author: North Atlantic Industries, Inc.
+ *
+ * SubSystem: I2C Generic Device Driver to handle generic I2C I/O on Linux kernel 2.6.x
+ *
+ * FileName: nai_generic_i2c.c
+ *
+ * History:
+ * 02-23-2017 JinH
+ *   fixed -EBUSY(-16) error to drive the new NAI Power Supply in which the error -ENXIO(-6) was fixed.
+ *
+ * 11-29-2016 JinH first release
+ * ==========================================================================*/
+
+#include <linux/init.h>
+#define pr_fmt(fmt) "%s:%d>" fmt,strrchr(__FILE__,'/'),__LINE__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#if (KERNEL_VERSION(2,6,18) > LINUX_VERSION_CODE)
+#include <linux/config.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/cdev.h>
+#include <asm/ioctl.h>
+#include <asm/irq.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 3, 0)
+#include <asm/switch_to.h>
+#else
+#include <asm/system.h>
+#endif
+#include <linux/uaccess.h>
+#include <asm/uaccess.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#include <linux/delay.h>
+
+#include "nai_generic_i2c.h"
+#include "shared_utils.h"
+#include "shared_smbus.h"
+/*
+ * error codes are defined in:
+ *Intel:
+ *include/asm-generic/errno-base.h
+ *include/asm-generic/errno.h
+ *include/linux/errno.h
+ *ARM:
+ *include/uapi/linux/errno.h
+ *include/uapi/asm-generic/errno-base.h
+ *include/uapi/asm-generic/errno.h
+ *include/linux/errno.h
+ */
+
+//#define DEBUG_IT
+
+#define PROBE_NAME      "nai-gen-i2c"
+
+#if defined(__x86_64__) || defined(__amd_64__)  || defined(__i386__)
+#define I2C_DEVICE_FILE "i2c-adapter-0-smbus"
+#elif defined(__arm__)
+#define I2C_DEVICE_FILE "i2c-adapter-1-smbus"
+#endif
+
+#define MAX_I2C_X_BUF_LEN    32
+
+struct nai_generic_i2c_driver_data
+{
+   struct cdev c_dev;                   /*make the link from address of struct cdev to address of struct ps4i2c_driver_data*/
+   struct class *generic_i2c_class;     /*device class*/
+   dev_t first;                         /*for the first device number*/
+   struct mutex mutex;
+   struct i2c_adapter *i2c_adapter_ptr;
+   u32    user_cnt;
+};
+
+/*
+ * This function is just for supporting NAI Power Supply
+ */
+static s32 nai_smbus_read_block_with_para
+(
+   struct i2c_adapter *i2c_adapter_ptr,
+   const u8* in_buf,
+   u16 in_buf_len,
+   u8* out_buf,
+   u16 out_buf_len
+)
+{
+   struct i2c_client i2c_cli;
+   s32 result = 0;
+   int layer_1_retry_cnt;
+   i2c_cli.adapter = i2c_adapter_ptr;
+
+   i2c_cli.flags = 0; /*bug fix for sending invalid I2C slave address*/
+
+   /*little-endian*/
+   i2c_cli.addr = in_buf[SMBUS_WR_ADDR_EXT_OFF];
+   i2c_cli.addr <<= 8;
+   i2c_cli.addr |= in_buf[SMBUS_WR_ADDR_OFF];
+
+#ifdef DEBUG_IT
+   pr_info("in_buf:");printk_hex_info(in_buf,in_buf_len);
+#endif
+
+   for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+   {
+      result = i2c_smbus_write_i2c_block_data( &i2c_cli, in_buf[SMBUS_RD_CMD_OFF], in_buf[SMBUS_RD_ARGC_OFF], &in_buf[SMBUS_RD_ARGV_OFF] );
+#ifdef DEBUG_IT
+      pr_info("write cmd \"0x%02x\",para_cnt:0x%x:\n",in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_ARGC_OFF]);printk_hex_info(&in_buf[SMBUS_RD_ARGV_OFF],in_buf[SMBUS_RD_ARGC_OFF]);
+#endif
+      if ( result == 0 )
+      {
+         int layer_2_retry_cnt;
+         for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ )
+         {
+            result = i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[SMBUS_RD_CMD_OFF], out_buf_len, out_buf ); 
+            if ( result < 0 )
+            {
+               if ( result == -EBUSY )
+               {
+                 /*
+                  * The error -EBUSY is generated before reading real I2C device in the func "static int i801_check_pre(struct i801_priv *priv)" in file "i2c-i801.c" in INTEL uP.
+                  * The driver "i2c-cadence.c" does not generate -EBUSY in ARM uP.
+                  * Therefore Reading I2C device twice will not happen, so retry op should not confuse the PS4.
+                  */
+                  pr_err("tried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02xx,%d,out_buf) err %d\n",layer_2_retry_cnt+1,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],out_buf_len,result);
+                  msleep( 1 );
+               }
+               else
+               {
+                  pr_err("i2c_smbus_read_i2c_block_data(0x%x,0x02x%x,%d,out_buf) err %d\n",i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],out_buf_len,result);
+                  /*
+                   * Not -EBUSY err, retry cannot fix the error in i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[SMBUS_RD_CMD_OFF], out_buf_len, out_buf ).
+                   * break for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ )
+                   */
+                  break;
+               }
+            }
+            else
+            {
+#ifdef DEBUG_IT
+               pr_info("read %d bytes:\n",result);printk_hex_info(out_buf,in_buf[SMBUS_RD_LEN_OFF]);
+#endif
+               if ( layer_2_retry_cnt > 0 )
+               {
+                  pr_err("recovered -EBUSY after retried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02x,%d,out_buf)\n",layer_2_retry_cnt,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],out_buf_len);
+               }
+
+               result = in_buf[SMBUS_RD_LEN_OFF];
+               /*
+                * Successfull finished i2c_smbus_read_i2c_block_data(&i2c_cli,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_LEN_OFF],out_buf).
+                * break for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ )
+                */
+               break;
+            }
+         } /* for ( layer_2_retry_cnt = 0; layer_2_retry_cnt < RETRY_LIMIT; layer_2_retry_cnt++ ) */
+
+         if ( layer_1_retry_cnt > 0 )
+         {
+            pr_err("recoverd -EBUSY after tried %d, write to i2c addr 0x%x for in_buf[SMBUS_RD_CMD_OFF]=0x%02x,in_buf[SMBUS_RD_ARGV_OFF]=0x%02x\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_ARGV_OFF]);
+         }
+
+         break; /*!!!VERY IMPORTANT!!! break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )*/
+      }
+      else
+      {
+         if ( result == -EBUSY )
+         {
+            pr_err("tried %d, write to i2c addr 0x%x for in_buf[SMBUS_RD_CMD_OFF]=0x%02x,in_buf[SMBUS_RD_ARGV_OFF]=0x%02x errno=%d\n",layer_1_retry_cnt+1,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_ARGV_OFF],result);
+            msleep( 1 );
+         }
+         else
+         {
+            pr_err("write to i2c addr 0x%x for in_buf[SMBUS_RD_CMD_OFF]=0x%02x,in_buf[SMBUS_RD_ARGV_OFF]=0x%02x errno=%d\n",i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_ARGV_OFF],result);
+            /*
+             * Not -EBUSY err, retry cannot fix the error in i2c_smbus_write_i2c_block_data(&i2c_cli,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_ARGC_OFF],&in_buf[SMBUS_RD_ARGV_OFF]).
+             * break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+             */
+            break;
+         }
+      }
+   } /*for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )*/
+
+   return result;
+}
+
+static int nai_smbus_open(struct inode *inode, struct file *filp)
+{
+   int status = 0;
+   /*
+    * setup filp->private_data for other funcs such as file_operations.read, file_operations.write and file_operations.ioctl to access
+    * fields in struct nai_generic_i2c_driver_data
+    */
+   filp->private_data=(struct nai_generic_i2c_driver_data*)container_of(inode->i_cdev,struct nai_generic_i2c_driver_data,c_dev);
+#ifdef DEBUG_IT
+   pr_info("nai_generic_i2c_driver_data vir_addr=0x%p\n",filp->private_data);
+#endif
+
+   mutex_lock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+   if ( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt == 0 )
+   {
+#if defined(__x86_64__) || defined(__amd_64__)  || defined(__i386__)
+      ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr=i2c_get_adapter(I2C_ADAPTER_0);
+#elif defined(__arm__)
+      ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr=i2c_get_adapter(I2C_ADAPTER_1);
+#endif
+
+      if ( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr == NULL )
+      {
+#if defined(__x86_64__) || defined(__amd_64__)  || defined(__i386__)
+         pr_err("can't Attach I2C Adapter %d\n",I2C_ADAPTER_0);
+#elif defined(__arm__)
+         pr_err("can't Attach I2C Adapter %d\n",I2C_ADAPTER_1);
+#endif
+         status = -ENODEV; /*no such device, include/uapi/asm-generic/errno-base.h*/
+         goto done;
+      }
+
+#ifdef DEBUG_IT
+      if ( i2c_check_functionality( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr, I2C_FUNC_SMBUS_PEC ) )
+      {
+         pr_info("PEC set\n");
+      }
+      else
+      {
+         pr_info("PEC not set\n");
+      }
+#endif
+
+      ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt++;
+   }
+
+done:
+   mutex_unlock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+
+   return status ;
+}
+
+static int nai_smbus_close(struct inode *i, struct file *filp)
+{
+   /* not safe in multi processor, set it to 0 only opened dev cnt is 0 */
+   mutex_lock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+   ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt--;
+   if ( ((struct nai_generic_i2c_driver_data*)(filp->private_data))->user_cnt == 0 )
+   {
+      i2c_put_adapter(((struct nai_generic_i2c_driver_data*)(filp->private_data))->i2c_adapter_ptr);
+
+#ifdef DEBUG_IT
+      pr_info("nai_generic_i2c_driver_data vir_addr=0x%p\n",filp->private_data);
+#endif
+   }
+   mutex_unlock(&((struct nai_generic_i2c_driver_data*)(filp->private_data))->mutex);
+   return 0;
+}
+
+static ssize_t nai_smbus_read(struct file *filp, char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=4;
+   struct nai_generic_i2c_driver_data *private_data_ptr=filp->private_data;
+   
+   uint8_t in_buf[MAX_I2C_X_BUF_LEN];
+   uint8_t out_buf[MAX_I2C_X_BUF_LEN];
+
+   memset(out_buf,0,sizeof(out_buf));
+   memset(in_buf,0,sizeof(in_buf));
+   mutex_lock(&private_data_ptr->mutex);
+
+   /*                                   sometime the value just 1 in usr_buf[SMBUS_RD_LEN_OFF] */
+   if ( len < the_max(SMBUS_RD_ARGV_OFF+usr_buf[SMBUS_RD_ARGC_OFF],usr_buf[SMBUS_RD_LEN_OFF]) )
+   {
+      pr_err("read length '%zd'is error.\n",len);
+      result = -EINVAL;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   else
+   {
+      pr_info("SMBUS_RD_ARGV_OFF+usr_buf[SMBUS_RD_ARGC_OFF]:%d,usr_buf[SMBUS_RD_LEN_OFF]:%d,len:%zd\n",SMBUS_RD_ARGV_OFF+usr_buf[SMBUS_RD_ARGC_OFF],usr_buf[SMBUS_RD_LEN_OFF],len);
+   }
+#endif
+   if(copy_from_user(in_buf,usr_buf,SMBUS_RD_ARGV_OFF+usr_buf[SMBUS_RD_ARGC_OFF]))
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("nai_generic_i2c_driver_data vir_addr:0x%p,rd_sz:%lu,rd_mgr_str:\n",private_data_ptr,len);printk_hex_info(in_buf,SMBUS_RD_ARGV_OFF+usr_buf[SMBUS_RD_ARGC_OFF]);
+#endif
+
+   if ( in_buf[SMBUS_RD_ARGC_OFF] == 0 )
+   {
+      result = nai_smbus_read_block( private_data_ptr->i2c_adapter_ptr,in_buf,SMBUS_RD_ARGV_OFF,out_buf,in_buf[SMBUS_RD_LEN_OFF] );
+   }
+   else
+   {
+#ifdef DEBUG_IT
+      pr_info("in_buf[SMBUS_RD_ARGC_OFF:0x%x]:0x%x,in_buf[SMBUS_RD_LEN_OFF:0x%x]:0x%x\n",SMBUS_RD_ARGC_OFF,in_buf[SMBUS_RD_ARGC_OFF],SMBUS_RD_LEN_OFF,in_buf[SMBUS_RD_LEN_OFF]);printk_hex_info(in_buf,SMBUS_RD_ARGV_OFF+in_buf[SMBUS_RD_ARGC_OFF]);
+#endif
+      result = nai_smbus_read_block_with_para( private_data_ptr->i2c_adapter_ptr,in_buf,SMBUS_RD_ARGV_OFF+in_buf[SMBUS_RD_ARGC_OFF],out_buf,in_buf[SMBUS_RD_LEN_OFF] );
+   }
+
+   if ( result != in_buf[SMBUS_RD_LEN_OFF] )
+   {
+      if ( in_buf[SMBUS_RD_ARGC_OFF] == 0 )
+      {
+         pr_err("err %d in nai_smbus_read_block(i2c_addr:0x%x%x,i2c_cmd:0x%x)\n",result,in_buf[SMBUS_RD_ADDR_EXT_OFF],in_buf[SMBUS_RD_ADDR_OFF],in_buf[SMBUS_RD_CMD_OFF]);
+      }
+      else
+      {
+         pr_err("err %d in nai_smbus_read_block_with_para(i2c_addr:0x%x%x,i2c_cmd:0x%x,i2c_cmd_cnt:0x%x)\n",result,in_buf[SMBUS_RD_ADDR_EXT_OFF],in_buf[SMBUS_RD_ADDR_OFF],in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_ARGC_OFF]);
+      }
+      goto done;
+   }
+
+   if(copy_to_user(usr_buf,out_buf,in_buf[SMBUS_RD_LEN_OFF]))
+   {
+      pr_err("err copy_to_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("read result:\n");printk_hex_info(out_buf,in_buf[SMBUS_RD_LEN_OFF]);
+#endif
+   result = in_buf[SMBUS_RD_LEN_OFF];
+done:
+   mutex_unlock(&private_data_ptr->mutex);
+
+   if( result < 0 )
+      pr_err("result err: %d\n",result);
+
+   return result;
+}
+
+static ssize_t nai_smbus_write(struct file *filp, const char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=0;
+
+   uint8_t in_buf[MAX_I2C_X_BUF_LEN];
+
+   struct nai_generic_i2c_driver_data *private_data_ptr=filp->private_data;
+
+   mutex_lock(&private_data_ptr->mutex);
+   if ( len < SMBUS_WR_DATA_OFF+usr_buf[SMBUS_WR_DATA_LEN_OFF] )
+   {
+      pr_err("len=%zd, SMBUS_WR_DATA_OFF=%d,usr_buf[SMBUS_WR_DATA_LEN_OFF]=%d,error input format\n",len,SMBUS_WR_DATA_OFF,usr_buf[SMBUS_WR_DATA_LEN_OFF]);
+      result = -EINVAL;
+      goto done;
+   }
+
+   if ( copy_from_user(in_buf,usr_buf,SMBUS_WR_DATA_OFF+usr_buf[SMBUS_WR_DATA_LEN_OFF]) )
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("in buf:\n");printk_hex_info(in_buf,SMBUS_WR_DATA_OFF+usr_buf[SMBUS_WR_DATA_LEN_OFF]);
+#endif
+   if ( ( result = nai_smbus_write_block( private_data_ptr->i2c_adapter_ptr, in_buf,SMBUS_WR_DATA_OFF+in_buf[SMBUS_WR_DATA_LEN_OFF] ) ) != in_buf[SMBUS_WR_DATA_LEN_OFF] )
+   {
+      pr_err("err in nai_smbus_write_block() %d\n",result);
+   }
+
+   mutex_unlock(&private_data_ptr->mutex);
+
+done:
+   return result;
+}
+
+static struct file_operations nai_generic_i2c_file_ops =
+{
+   .owner = THIS_MODULE,
+   .open = nai_smbus_open,
+   .release = nai_smbus_close,
+   .read = nai_smbus_read,
+   .write = nai_smbus_write,
+};
+
+static int nai_gen_i2c_driver_probe(struct platform_device *pdev)
+{
+   int ret=0;
+   struct nai_generic_i2c_driver_data *private_data_ptr;
+#ifdef DEBUG_IT
+   pr_info("Probe Device: \"%s\"\n",pdev->name);
+#endif
+   /*
+    * devm_kzalloc() is resource-managed kzalloc(). The memory allocated with resource-managed
+    * functions is associated with the device. When the device is detached from the system or the
+    * driver for the device is unloaded, that memory is freed automatically. It is possible to
+    * free the memory with devm_kfree() if it's no longer needed.
+    * private_data_ptr=devm_kzalloc(&pdev->dev,sizeof(*private_data_ptr),GFP_KERNEL);
+    */
+   private_data_ptr=kzalloc(sizeof(*private_data_ptr),GFP_KERNEL);
+
+   if ( private_data_ptr==NULL )
+   {
+      pr_err("kmalloc(struct nai_generic_i2c_driver_data,GFP_KERNEL) err\n");
+      ret= -ENOMEM;
+      goto err_step_1;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("private_data_ptr vir_addr=0x%p,platform_device addr=0x%p\n",private_data_ptr,pdev);
+#endif
+                                                                 /*check man page, vs register_chrdev*/
+   if ((ret = alloc_chrdev_region(&private_data_ptr->first, 0, 1, "i2c-dev-parent")) < 0)
+   {
+      pr_err("alloc_chrdev_region() err=%d\n",ret);
+      goto err_step_2;
+   }
+
+   if (IS_ERR(private_data_ptr->generic_i2c_class = class_create(THIS_MODULE, I2C_DEVICE_FILE)))
+   {
+      pr_err("class_create() err=%ld\n",PTR_ERR(private_data_ptr->generic_i2c_class));
+      ret=PTR_ERR(private_data_ptr->generic_i2c_class);
+      goto err_step_3;
+   }
+
+   if (IS_ERR(device_create(private_data_ptr->generic_i2c_class, NULL, private_data_ptr->first, NULL, I2C_DEVICE_FILE)))
+   {
+      ret = PTR_ERR(device_create(private_data_ptr->generic_i2c_class, NULL, private_data_ptr->first, NULL, I2C_DEVICE_FILE));
+      pr_err("device_create() err=%d\n",ret);
+      goto err_step_4;
+   }
+
+   cdev_init(&private_data_ptr->c_dev,&nai_generic_i2c_file_ops);
+   if ((ret = cdev_add(&private_data_ptr->c_dev, private_data_ptr->first, 1)) < 0)
+   {
+      pr_err("cdev_add() err=%d\n",ret);
+      goto err_step_5;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("Probe Device: \"%s\",I2C_DEVICE_FILE=\"%s\"\n",pdev->name,I2C_DEVICE_FILE);
+#endif
+   platform_set_drvdata(pdev,private_data_ptr);
+   mutex_init(&private_data_ptr->mutex);
+   return 0;
+
+err_step_5:
+   device_destroy(private_data_ptr->generic_i2c_class, private_data_ptr->first);
+err_step_4:
+   class_destroy(private_data_ptr->generic_i2c_class);
+err_step_3:
+   unregister_chrdev_region(private_data_ptr->first,1);
+err_step_2:
+   kfree(private_data_ptr);
+err_step_1:
+   return ret;
+}
+
+static int nai_gen_i2c_driver_remove(struct platform_device *pdev)
+{
+   struct nai_generic_i2c_driver_data *private_data_ptr=platform_get_drvdata(pdev);
+#ifdef DEBUG_IT
+   pr_info("Remove Device: \"%s\"\n",pdev->name);
+#endif
+   /*without these release resource API calls, kernel panic when the module is removed by rmmod cmd or is re inserted by insmod cmd.*/
+   cdev_del(&private_data_ptr->c_dev);
+   device_destroy(private_data_ptr->generic_i2c_class, private_data_ptr->first);
+   class_destroy(private_data_ptr->generic_i2c_class);
+   unregister_chrdev_region(private_data_ptr->first,1);
+#ifdef DEBUG_IT
+   pr_info("unregistered\n");
+#endif
+   return 0;
+}
+
+static void nai_gen_i2c_device_release(struct device *dev)
+{
+#ifdef DEBUG_IT
+   struct platform_device *derived_dev=container_of(dev,struct platform_device,dev);
+   pr_info("Release Device: \"%s\"\n",derived_dev->name);
+#endif
+}
+
+static struct platform_driver nai_gen_i2c_driver_driver =
+{
+   .driver =
+   {
+      .name = PROBE_NAME, /*The idriver name must match struct platform_device.name*/
+      .owner = THIS_MODULE,
+   },
+   .probe = nai_gen_i2c_driver_probe,
+   .remove = nai_gen_i2c_driver_remove,
+};
+
+static struct platform_device nai_gen_i2c_driver_device =
+{
+   .name = PROBE_NAME, /*The device name must match struct platform_driver.driver.name*/
+   .id = 0,
+   .dev =
+   {
+      .release = nai_gen_i2c_device_release,
+   },
+};
+
+static int __init nai_gen_i2c_driver_init(void)
+{
+#ifdef DEBUG_IT
+   pr_info("Driver test init\n");
+#endif
+   platform_device_register(&nai_gen_i2c_driver_device); /*device is diff from driver*/
+   platform_driver_register(&nai_gen_i2c_driver_driver); /*dirver is diff from device*/
+   return 0;
+}
+
+static void __exit nai_gen_i2c_driver_exit(void)
+{
+#ifdef DEBUG_IT
+   pr_info("Driver Test Exit\n");
+#endif
+   platform_driver_unregister(&nai_gen_i2c_driver_driver);
+   platform_device_unregister(&nai_gen_i2c_driver_device);
+}
+
+module_init(nai_gen_i2c_driver_init);
+module_exit(nai_gen_i2c_driver_exit);
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.40");
diff --git a/drivers/misc/nai-generic-i2c/shared_i2c.c b/drivers/misc/nai-generic-i2c/shared_i2c.c
new file mode 100644
index 0000000..c5e67be
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/shared_i2c.c
@@ -0,0 +1,507 @@
+#include <linux/init.h>
+#define pr_fmt(fmt) "%s:%d>" fmt,strrchr(__FILE__,'/'),__LINE__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#if (KERNEL_VERSION(2,6,18) > LINUX_VERSION_CODE)
+#include <linux/config.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/cdev.h>
+#include <asm/ioctl.h>
+#include <asm/irq.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 3, 0)
+#include <asm/switch_to.h>
+#else
+#include <asm/system.h>
+#endif
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/platform_data/at24.h>
+#include <nai_generic_i2c.h>
+#include "shared_utils.h"
+
+#ifdef SUPPORT_I2C_DEVICE_FILE
+#include "shared_i2c.h"
+/******************* nai i2c shared functions begin *******************/
+static ssize_t i2c_read_block
+(
+   struct i2c_smbus_drv_data* i2c_drv_data_ptr,
+   char *buf,
+   uint16_t offset,
+   size_t count
+)
+{
+   struct i2c_msg msg[2];
+   uint8_t msgbuf[2]={0,0};
+   unsigned long timeout, read_time;
+   int status, i=0;
+
+   memset(msg, 0, sizeof(msg));
+
+   if (i2c_drv_data_ptr->chip_access_flags & AT24_FLAG_ADDR16)
+   {
+      msgbuf[i++] = offset >> 8;
+   }
+   msgbuf[i++] = offset;
+
+   if ( count > i2c_drv_data_ptr->io_limit )
+   {
+      count = i2c_drv_data_ptr->io_limit;
+   }
+
+   msg[0].addr = i2c_drv_data_ptr->clients[0]->addr;
+   msg[0].buf = msgbuf;
+   msg[0].len = i;
+
+   msg[1].addr = i2c_drv_data_ptr->clients[0]->addr;
+   msg[1].flags = I2C_M_RD;
+   msg[1].buf = buf;
+   msg[1].len = count;
+
+   timeout = jiffies + msecs_to_jiffies(i2c_drv_data_ptr->write_timeout);
+
+   do
+   {
+      status = i2c_transfer(i2c_drv_data_ptr->clients[0]->adapter, msg, 2);//msg has i2c addr info
+      if (status == 2)
+      {
+         status = count;
+#ifdef DEBUG_IT
+         pr_info("read %zu bytes @off:%d(0x%x) -->status:%d,(jiffies:%lu)\n", count, offset, offset, status, jiffies); printk_hex_info(buf,count);
+#endif
+         return count;
+      }
+      /* REVISIT: at HZ=100, this is sloooow */
+      msleep(1);
+   }
+   while (time_before(read_time, timeout));
+
+   pr_err("time out\n");
+   return -ETIMEDOUT;
+}
+EXPORT_SYMBOL(i2c_read_block);
+
+static int32_t nai_i2c_read_block
+(
+   struct i2c_smbus_drv_data* i2c_drv_data_ptr,
+   const uint8_t* in_buf,
+   uint16_t in_buf_len,
+   uint8_t* out_buf,
+   uint16_t out_buf_len
+)
+{
+   int32_t result = 0, status;
+   loff_t off=in_buf[I2C_RD_CMD_OFF]*256+in_buf[I2C_RD_ARGV_OFF];
+   size_t cnt=in_buf[I2C_RD_LEN_MSB_OFF]*256+in_buf[I2C_RD_LEN_LSB_OFF];
+
+   struct i2c_client client;
+   i2c_drv_data_ptr->clients[0] = &client;
+   build_i2c_client_addr(i2c_drv_data_ptr->clients[0],in_buf);
+#ifdef DEBUG_IT
+   pr_info("client.addr=0x%x\n",i2c_drv_data_ptr->clients[0]->addr);
+#endif
+   i2c_drv_data_ptr->clients[0]->adapter = i2c_drv_data_ptr->i2c_adapter_ptr;
+
+   while ( cnt != 0 )
+   {
+      status = i2c_read_block
+      (
+         i2c_drv_data_ptr,
+         out_buf,
+         off,
+         cnt
+      );
+      if( status <=0 )
+      {
+         if ( result == 0 )
+         {
+            result = status;
+         }
+         break;
+      }
+      out_buf += status;
+      off += status;
+      cnt -= status;
+      result += status;
+   }
+   return result;
+}
+EXPORT_SYMBOL(nai_i2c_read_block);
+
+/*
+ * buf: just only data written to chip.
+ * off: offset the data will be written.
+ * count: data size.
+ */
+static ssize_t i2c_write_block
+(
+   struct i2c_smbus_drv_data* i2c_drv_data_ptr,
+   const uint8_t* buf,
+   uint16_t offset,
+   size_t count
+)
+{
+   ssize_t status = 0;
+   unsigned long timeout,write_time;
+   struct i2c_msg msg;
+   s8 tmp_wr_buf[I2C_TRX_BUF_LEN_MAX];
+   int i=0; 
+
+   memset(tmp_wr_buf, 0, sizeof(tmp_wr_buf));
+   msg.buf = tmp_wr_buf;
+
+   if ( i2c_drv_data_ptr->chip_access_flags & AT24_FLAG_ADDR16 )
+   {
+      msg.buf[i++] = offset >> 8;
+   }
+   msg.buf[i++] = offset;
+
+   if ( count > i2c_drv_data_ptr->io_limit )
+   {
+      count = i2c_drv_data_ptr->io_limit;
+   }
+
+   memcpy(&msg.buf[i], buf, count);
+   msg.len = i + count;
+
+   msg.flags = 0;
+   //msg.addr = i2c_client_ptr->addr;
+   msg.addr = i2c_drv_data_ptr->clients[0]->addr;
+
+   timeout = jiffies + msecs_to_jiffies(i2c_drv_data_ptr->write_timeout);
+   do
+   {
+      write_time = jiffies;
+      status = i2c_transfer(i2c_drv_data_ptr->clients[0]->adapter, &msg, 1);//msg has i2c addr info
+      if (status == 1)
+      {
+         status = count;
+      }
+#ifdef DEBUG_IT
+      pr_info("cli-dev: write %zu@%u --> %zd (%lu)\n",count,offset,status,jiffies);
+#endif 
+      if (status == count)
+      {
+         return count;
+      }
+ 
+      /* REVISIT: at HZ=100, this is sloooow */
+      msleep(1);
+   }
+   while (time_before(write_time, timeout));
+ 
+   return -ETIMEDOUT;
+}
+EXPORT_SYMBOL(i2c_write_block);
+
+static int32_t nai_i2c_write_block
+(
+   struct i2c_smbus_drv_data* i2c_drv_data_ptr,
+   const uint8_t* in_buf,
+   uint16_t in_buf_len
+)
+{
+   int32_t result = 0, status;
+   loff_t off=in_buf[I2C_WR_CMD_OFF]*256+in_buf[I2C_WR_ARGV_OFF];
+   size_t cnt=in_buf[I2C_WR_LEN_MSB_OFF]*256+in_buf[I2C_WR_LEN_LSB_OFF];/*1 is the extra byte for offset LSB*/
+
+   struct i2c_client client;
+   const uint8_t* wr_buf = in_buf+I2C_WR_ARGV_OFF+1;/*1 is the extra byte for offset LSB, already handled by off assignment*/
+   build_i2c_client_addr(&client,in_buf);
+   i2c_drv_data_ptr->clients[0]=&client;
+#ifdef DEBUG_IT
+   pr_info("client.addr=0x%x\n",client.addr);
+   printk_hex_info(wr_buf,in_buf[I2C_WR_LEN_MSB_OFF]*256+in_buf[I2C_WR_LEN_LSB_OFF]);
+#endif
+   i2c_drv_data_ptr->clients[0]->adapter = i2c_drv_data_ptr->i2c_adapter_ptr;
+   while ( cnt != 0 )
+   { 
+      status = i2c_write_block
+               (
+                  i2c_drv_data_ptr,
+                  wr_buf,
+                  off,
+                  cnt
+               );
+      if ( status <= 0 )
+      {
+         if ( result == 0 )
+         {
+           result = status;
+           break;
+         }
+      }
+      wr_buf += status;
+      off += status;
+      cnt -= status;
+      result += status;
+   }
+   return result;
+}
+EXPORT_SYMBOL(nai_i2c_write_block);
+
+ssize_t nai_i2c_dev_read(struct file *filp, char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=4;
+   struct i2c_smbus_drv_data *i2c_drv_data_ptr=filp->private_data;
+   
+#ifdef DEBUG_IT
+   pr_info("len: %d\n",len);
+#endif
+
+   uint8_t in_buf[NAI_I2C_SMBUS_RD_WR_MGR_BUF_LEN];
+   uint8_t out_buf[I2C_TRX_BUF_LEN_MAX];
+
+   memset(out_buf,0,sizeof(out_buf));
+   memset(in_buf,0,sizeof(in_buf));
+
+   mutex_lock(i2c_drv_data_ptr->mutex_ptr);
+
+   if ( len < I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF] )
+   {
+      pr_err("len=%d,I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF]=%d,error input format\n",len,I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF]);
+#ifdef DEBUG_IT
+      printk_hex_info(usr_buf,len);
+#endif
+      result = -EINVAL;
+      goto done;
+   }
+  
+   if(copy_from_user(in_buf,usr_buf,I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF]))
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("i2c_drv_data vir_addr=0x%p,input len %d:\n",i2c_drv_data_ptr,len);printk_hex_info(in_buf,I2C_RD_ARGV_OFF+usr_buf[I2C_RD_ARGC_OFF]);
+#endif
+ 
+   result = nai_i2c_read_block( i2c_drv_data_ptr, in_buf,I2C_RD_ARGV_OFF+in_buf[I2C_RD_ARGC_OFF],out_buf,in_buf[I2C_RD_LEN_MSB_OFF]*256+in_buf[I2C_RD_LEN_LSB_OFF] );
+   if ( result != in_buf[I2C_RD_LEN_MSB_OFF]*256+in_buf[I2C_RD_LEN_LSB_OFF] )
+   {
+      pr_err("err in nai_i2c_read_block() %d\n",result);
+      goto done;
+   }
+
+   if(copy_to_user(usr_buf,out_buf,in_buf[I2C_RD_LEN_MSB_OFF]*256+in_buf[I2C_RD_LEN_LSB_OFF]))
+   {
+      pr_err("err copy_to_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("read result:\n");printk_hex_info(out_buf,in_buf[I2C_RD_LEN_MSB_OFF]*256+in_buf[I2C_RD_LEN_LSB_OFF]);
+#endif
+   result = in_buf[I2C_RD_LEN_MSB_OFF]*256+in_buf[I2C_RD_LEN_LSB_OFF];
+
+done:
+   mutex_unlock(i2c_drv_data_ptr->mutex_ptr);
+
+   if( result < 0 )
+      pr_err("result err: %d\n",result);
+
+   return result;
+}
+EXPORT_SYMBOL(nai_i2c_dev_read);
+
+ssize_t nai_i2c_dev_write(struct file *filp, const char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=0;
+   uint8_t in_buf[NAI_I2C_SMBUS_RD_WR_MGR_BUF_LEN+I2C_TRX_BUF_LEN_MAX];
+
+   struct i2c_smbus_drv_data *i2c_drv_data_ptr=filp->private_data;
+
+   mutex_lock(i2c_drv_data_ptr->mutex_ptr);
+
+   if ( len < I2C_WR_ARGV_OFF+usr_buf[I2C_WR_LEN_MSB_OFF]*256+usr_buf[I2C_WR_LEN_LSB_OFF] )
+   {
+      pr_err("len=%zd, I2C_WR_ARGV_OFF=%d,usr_buf[I2C_WR__MSB_OFF]*256+usr_buf[I2C_WR__LSB_OFF]=%d,error input format\n",len,I2C_WR_ARGV_OFF,usr_buf[I2C_WR_LEN_MSB_OFF]*256+usr_buf[I2C_WR_LEN_LSB_OFF]);
+      result = -EINVAL;
+      goto done;
+   }
+
+   memset(in_buf,0,sizeof(in_buf));
+
+   if ( copy_from_user(in_buf,usr_buf,I2C_WR_ARGV_OFF+usr_buf[I2C_WR_ARGC_OFF]+usr_buf[I2C_WR_LEN_MSB_OFF]*256+usr_buf[I2C_WR_LEN_LSB_OFF]) )
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("in_buf:\n");printk_hex_info(in_buf,I2C_WR_ARGV_OFF+usr_buf[I2C_WR_ARGC_OFF]+usr_buf[I2C_WR_LEN_MSB_OFF]*256+usr_buf[I2C_WR_LEN_LSB_OFF]);
+#endif
+
+   result = nai_i2c_write_block( i2c_drv_data_ptr, in_buf,I2C_WR_ARGV_OFF+usr_buf[I2C_WR_LEN_MSB_OFF]*256+usr_buf[I2C_WR_LEN_LSB_OFF] );
+   if ( result != usr_buf[I2C_WR_LEN_MSB_OFF]*256+usr_buf[I2C_WR_LEN_LSB_OFF] )
+   {
+      pr_err("err in nai_i2c_write_block() %d\n",result);
+   }
+
+done:
+   mutex_unlock(i2c_drv_data_ptr->mutex_ptr);
+
+   return result;
+}
+EXPORT_SYMBOL(nai_i2c_dev_write);
+/******************* nai i2c shared functions end *******************/
+
+/******************* nai i2c serial number read shared functions begin *******************/
+#define AT24CS_SERIAL_SIZE 16
+#define AT24CS_SERIAL_ADDR(addr) (addr + 0x08) /*A Dummy Write, Datasheet Figure 10-1 Device Address in Atmel-8815-SEEPROM-AT24CS01-02-Datasheet.pdf*/
+
+static int at24cs_eeprom_serial_read
+(
+  struct i2c_smbus_drv_data* i2c_drv_data_ptr,
+  uint8_t *buf,
+  unsigned offset,
+  size_t count
+)
+{
+   unsigned long timeout, read_time;
+   struct i2c_client *client;
+   struct i2c_msg msg[2];
+   uint8_t addrbuf[2];
+   int status;
+#ifdef DEBUG_IT
+   int retry_cnt=0;
+#endif
+
+client = i2c_drv_data_ptr->clients[1];
+
+#ifdef DEBUG_IT
+pr_info("here,addr=0x%x,off=%lu,count=%zu\n",client->addr,(long)offset,count);
+#endif
+   memset(msg, 0, sizeof(msg));
+   msg[0].addr = client->addr;
+   msg[0].buf = addrbuf;
+
+   /*
+    * The address pointer of the device is shared between the regular
+    * EEPROM array and the serial number block. The dummy write (part of
+    * the sequential read protocol) ensures the address pointer is reset
+    * to the desired position.
+    */
+#if 0
+   if (at24->chip_access_flags & AT24_FLAG_ADDR16)
+        {
+      /*
+       * For 16 bit address pointers, the word address must contain
+       * a '10' sequence in bits 11 and 10 regardless of the
+       * intended position of the address pointer.
+       */
+      addrbuf[0] = 0x08;
+      addrbuf[1] = offset;
+      msg[0].len = 2; pr_info("not here\n");
+   }
+        else
+#endif
+        {
+      /*
+       * Otherwise the word address must begin with a '10' sequence,
+       * regardless of the intended address.
+       */
+      addrbuf[0] = 0x80 + offset;
+      msg[0].len = 1; pr_info("here:ddrbuf[0]=0x%x\n",addrbuf[0]);
+   }
+
+   msg[1].addr = client->addr; pr_info("msg[1].addr=0x%x\n",msg[1].addr);
+   msg[1].flags = I2C_M_RD;
+   msg[1].buf = buf;
+   msg[1].len = count;
+
+   /*
+    * Reads fail if the previous write didn't complete yet. We may
+    * loop a few times until this one succeeds, waiting at least
+    * long enough for one entire page write to work.
+    */
+   timeout = jiffies + msecs_to_jiffies(i2c_drv_data_ptr->write_timeout);
+#ifdef DEBUG_IT
+   pr_info("write_timeout=%lu\n",i2c_drv_data_ptr->write_timeout);
+#endif
+   do
+   {
+      read_time = jiffies;
+      status = i2c_transfer(client->adapter, msg, 2);
+      if (status == 2)
+      {
+#ifdef DEBUG_IT
+         pr_info("adapter=0x%p,status %d,retry_cnt=%d\n",client->adapter,status,retry_cnt);printk_hex_info(buf,count);
+#endif
+         return count;
+      }
+
+      /* REVISIT: at HZ=100, this is sloooow */
+      msleep(1);
+#ifdef DEBUG_IT
+      pr_info("adapter=0x%p,time out %d\n",client->adapter,++retry_cnt);
+#endif
+   }
+   while (time_before(read_time, timeout));
+
+   return -ETIMEDOUT;
+}
+EXPORT_SYMBOL(at24cs_eeprom_serial_read);
+
+int32_t nai_i2c_read_chip_serial
+(
+   struct i2c_smbus_drv_data* i2c_drv_data_ptr,
+   const uint8_t* in_buf,
+   uint16_t in_buf_len,
+   uint8_t* out_buf,
+   uint16_t out_buf_len
+)
+{
+   int32_t result = 0;
+   loff_t off=in_buf[SMBUS_RD_CMD_OFF];
+   size_t cnt=in_buf[SMBUS_RD_LEN_OFF];
+
+   struct i2c_client client;
+   i2c_drv_data_ptr->clients[0] = &client;
+   build_i2c_client_addr(i2c_drv_data_ptr->clients[0],in_buf);
+#ifdef DEBUG_IT
+   pr_info("client.addr=0x%x\n",i2c_drv_data_ptr->clients[0]->addr);
+#endif
+
+   i2c_drv_data_ptr->clients[1] = i2c_new_dummy
+   (
+     i2c_drv_data_ptr->i2c_adapter_ptr,
+     AT24CS_SERIAL_ADDR(client.addr)
+   );
+
+   if ( i2c_drv_data_ptr->clients[1] == NULL )
+   {
+      pr_err("address 0x%02x unavailable\n", AT24CS_SERIAL_ADDR(client.addr));
+
+      return result = -EADDRINUSE;
+   }
+
+   i2c_drv_data_ptr->clients[1]->adapter = i2c_drv_data_ptr->i2c_adapter_ptr;
+
+   result = at24cs_eeprom_serial_read
+   (
+      i2c_drv_data_ptr,
+      out_buf,
+      off,
+      cnt
+   );
+
+   i2c_unregister_device( i2c_drv_data_ptr->clients[1] );
+
+   return result;
+}
+EXPORT_SYMBOL(nai_i2c_read_chip_serial);
+
+/******************* nai i2c serial number read shared functions end *******************/
+#endif /*#ifdef SUPPORT_I2C_DEVICE_FILE*/
diff --git a/drivers/misc/nai-generic-i2c/shared_i2c.h b/drivers/misc/nai-generic-i2c/shared_i2c.h
new file mode 100644
index 0000000..65da691
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/shared_i2c.h
@@ -0,0 +1,7 @@
+#ifndef _SHARED_I2C_H_
+#define _SHARED_I2C_H_
+
+ssize_t nai_i2c_dev_read(struct file *filp, char __user *usr_buf, size_t len, loff_t *off);
+ssize_t nai_i2c_dev_write(struct file *filp, const char __user *usr_buf, size_t len, loff_t *off);
+
+#endif /*_SHARED_I2C_H_*/
diff --git a/drivers/misc/nai-generic-i2c/shared_smbus.c b/drivers/misc/nai-generic-i2c/shared_smbus.c
new file mode 100644
index 0000000..547a882
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/shared_smbus.c
@@ -0,0 +1,511 @@
+#include <linux/init.h>
+#define pr_fmt(fmt) "%s:%d>" fmt,strrchr(__FILE__,'/'),__LINE__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#if (KERNEL_VERSION(2,6,18) > LINUX_VERSION_CODE)
+#include <linux/config.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/cdev.h>
+#include <asm/ioctl.h>
+#include <asm/irq.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 3, 0)
+#include <asm/switch_to.h>
+#else
+#include <asm/system.h>
+#endif
+#include <linux/uaccess.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+
+#include "nai_generic_i2c.h"
+#include "shared_utils.h"
+#include "shared_smbus.h"
+
+#define UDELAY_VAL 500
+
+#define MULTI_ACCESSING
+
+/******************* nai smbus shared functions begin *******************/
+#ifdef MULTI_ACCESSING
+static ssize_t smbus_read_block
+(
+   struct i2c_client* i2c_cli_ptr,
+   char *buf,
+   uint16_t offset,
+   size_t count
+)
+{
+   int status=0;
+
+   if (count > I2C_SMBUS_BLOCK_MAX)
+   {
+      count = I2C_SMBUS_BLOCK_MAX;
+   }
+
+   status = i2c_smbus_read_i2c_block_data(i2c_cli_ptr, offset, count, buf);
+   if (status == count)
+   {
+#ifdef DEBUG_IT
+      pr_info("I2C_ADDR:0x%X,adp:0x%p,rd:%zu,cmd/off:0x%02x,sts:%d\n",i2c_cli_ptr->addr,i2c_cli_ptr->adapter,count,offset,status);// printk_hex_info(buf,count);
+#endif
+      return count;
+   }
+   else
+   {
+      pr_err("I2C_ADDR:0x%X,err:adp:0x%p,rd:%zu,cmd/off:0x%02x,buf[0]:0x%02x,sts:%d\n",i2c_cli_ptr->addr,i2c_cli_ptr->adapter,count,offset,buf[0],status);// printk_hex_info(buf,count);
+      return status;
+   }
+}
+EXPORT_SYMBOL(smbus_read_block);
+
+int32_t nai_smbus_read_block
+(
+   struct i2c_adapter *i2c_adapter_ptr,
+   const uint8_t* in_buf,
+   uint16_t in_buf_len,
+   uint8_t* out_buf,
+   uint16_t out_buf_len
+)
+{
+   int32_t result = 0, status;
+   uint8_t off=in_buf[SMBUS_RD_CMD_OFF];
+   size_t cnt=in_buf[SMBUS_RD_LEN_OFF];
+   struct i2c_client i2c_cli;
+
+   if(out_buf_len<cnt)
+   {
+      pr_err("wrong fmt,buf_sz:%u<rd_cnt:%zu\n",out_buf_len,cnt);
+      return -ENOEXEC;
+   }
+
+   build_i2c_client_addr(&i2c_cli,in_buf);
+#ifdef DEBUG_IT
+   pr_info("client.addr:0x%x,cnt:0x%x\n",i2c_cli.addr,in_buf[SMBUS_RD_LEN_OFF]);
+#endif
+   i2c_cli.adapter = i2c_adapter_ptr;
+
+   while ( cnt != 0 )
+   {
+      uint32_t retry_cnt;
+
+      for(retry_cnt=0;retry_cnt<RETRY_LIMIT;retry_cnt++)
+      {
+         status = smbus_read_block
+         (
+            &i2c_cli,
+            out_buf,
+            off,
+            cnt
+         );
+
+         if( status > 0 )
+         {
+
+            if(retry_cnt>0)
+            {
+               pr_err("retried %u,recovered -EBUSY|ENXIO rd:%d,cmd/off:0x%02x OK.\n",retry_cnt,status,off);
+            }
+
+            out_buf += status;
+            off += status;
+            cnt -= status;
+            result += status;
+            break;
+         }
+         else if ( status == -EBUSY || status == -ENXIO )
+         { /*some time, PS4 returns -EBUSY, and AT24 EEPROM returns -ENXIO*/
+            pr_err("I2C_ADDR:0x%X,rd_blk err:-EBUSY|ENXIO, retry:%d\n",i2c_cli.addr,retry_cnt+1);
+            udelay( UDELAY_VAL );
+         }
+         else
+         {
+            result = status;
+            pr_err("I2C_ADDR:0x%X,smbus_write_block(...) err:%d",i2c_cli.addr,status);
+            break;/*break for(tetry_cnt=0;tetry_cnt<ETRY_LIMIT;retry_cnt++)*/
+         }
+
+      }/*for(retry_cnt=0;retry_cnt<RETRY_LIMIT;retry_cnt++)*/
+
+      if( status < 0 )
+      {
+         pr_err("I2C_ADDR:0x%X,smbus_read_block(...) err:%d\n",i2c_cli.addr,status);
+         result=status;
+         break;/*break while ( wr_cnt != 0 )*/
+      }
+#ifdef DEBUG_IT
+      else
+      {
+         pr_info("exp %d,rd %d ok\n",in_buf[SMBUS_RD_LEN_OFF],result);
+      }
+#endif
+   }
+
+   return result;
+}
+#else /* !MULTI_ACCESSING */
+s32 nai_smbus_read_block
+(
+   struct i2c_adapter *i2c_adapter_ptr, 
+   const u8* in_buf,
+   u16 in_buf_len,
+   u8* out_buf,
+   u16 out_buf_len
+)
+{
+   struct i2c_client i2c_cli;
+   s32 result = 0;
+   int layer_1_retry_cnt;
+   i2c_cli.adapter = i2c_adapter_ptr;
+
+   i2c_cli.flags = 0; /*bug fix for sending invalid I2C slave address*/
+
+   /*little-endian*/
+   i2c_cli.addr = in_buf[SMBUS_WR_ADDR_EXT_OFF];
+   i2c_cli.addr <<= 8;
+   i2c_cli.addr |= in_buf[SMBUS_WR_ADDR_OFF];
+
+   if ( in_buf[ SMBUS_RD_ADDR_EXT_OFF ] & 0xFF )
+   {
+      i2c_cli.flags |= I2C_M_TEN;
+   }
+#ifdef DEBUG_IT
+   pr_info("input:\n");printk_hex_info(in_buf,in_buf_len);
+#endif
+
+   for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+   {
+      result = i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[SMBUS_RD_CMD_OFF], out_buf_len, out_buf );
+      if( result < 0 )
+      {
+         if ( result == -EBUSY || -ENXIO )
+         { /*some time, PS4 returns -EBUSY, and AT24 EEPROM returns -ENXIO*/
+            pr_err("tried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02x,%d) err:%d\n",layer_1_retry_cnt+1,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_LEN_OFF],result);
+            udelay( UDELAY_VAL );
+         }
+         else
+         {
+            pr_err("i2c_smbus_read_i2c_block_data(0x%x,0x%02x,%d) err:%d\n",i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_LEN_OFF],result);
+           /*
+            * Not -EBUSY/ENXIO err, retry cannot fix the error in i2c_smbus_read_i2c_block_data( &i2c_cli, in_buf[SMBUS_RD_CMD_OFF], out_buf_len, out_buf ).
+            * break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+            */
+            break;
+         }
+      }
+      else
+      {
+#ifdef DEBUG_IT
+         pr_info("i2c_smbus_read_i2c_block_data read %d byte(s)\n",result);printk_hex_info(out_buf,in_buf[SMBUS_RD_LEN_OFF]);
+#endif
+         if ( layer_1_retry_cnt > 0 )
+         {
+            pr_err("recovered -EBUSY|ENXIO after retried %d,i2c_smbus_read_i2c_block_data(0x%x,0x%02x,%d)\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_RD_LEN_OFF]);
+         }
+         break; /* break for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ ) */
+      }
+   }
+
+#ifdef DEBUG_IT
+   pr_info("out_buf with len:%d:\n",out_buf_len);printk_hex_info(out_buf,out_buf_len);
+#endif
+   return result;
+}
+#endif /* MULTI_ACCESSING */
+EXPORT_SYMBOL(nai_smbus_read_block);
+
+ssize_t nai_smbus_dev_read(struct file *filp, char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=4;
+   struct i2c_smbus_drv_data *i2c_drv_data_ptr=filp->private_data;
+
+#ifdef DEBUG_IT
+   pr_info("len: %d\n",len);
+#endif
+
+   uint8_t in_buf[NAI_I2C_SMBUS_RD_WR_MGR_BUF_LEN];
+   uint8_t out_buf[SMBUS_TRX_BUF_LEN_MAX*8];
+
+   memset(out_buf,0,sizeof(out_buf));
+   memset(in_buf,0,sizeof(in_buf));
+
+   mutex_lock(i2c_drv_data_ptr->mutex_ptr); /*mutex is set by fs_ops creater*/
+
+   if ( len < the_max (NAI_SMBUS_RD_MGR_HEADER_SZ,usr_buf[SMBUS_RD_LEN_OFF]) )
+   {
+      pr_err("len=%zd less the max (NAI_SMBUS_RD_MGR_HEADER_SZ=%u,usr_buf[SMBUS_RD_LEN_OFF]=%u,error input format\n",len,NAI_SMBUS_RD_MGR_HEADER_SZ,usr_buf[SMBUS_RD_LEN_OFF]);
+#ifdef DEBUG_IT
+      printk_hex_info(usr_buf,len);
+#endif
+      result = -EINVAL;
+      goto done;
+   }
+
+   if(copy_from_user(in_buf,usr_buf,NAI_SMBUS_RD_MGR_HEADER_SZ))
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("i2c_drv_data vir_addr:0x%p,rd_sz:%d,rd_mgr_str:\n",i2c_drv_data_ptr,len);printk_hex_info(in_buf,NAI_SMBUS_RD_MGR_HEADER_SZ);
+#endif
+
+   if ( ( result = nai_smbus_read_block( i2c_drv_data_ptr->i2c_adapter_ptr, in_buf,the_max(NAI_SMBUS_RD_MGR_HEADER_SZ,in_buf[SMBUS_RD_LEN_OFF]),out_buf,in_buf[SMBUS_RD_LEN_OFF] ) ) != in_buf[SMBUS_RD_LEN_OFF] )
+   {
+      pr_err("I2C_ADDR:0x%X,err in nai_smbus_read_block() %d\n",*((u16*)usr_buf),result);
+      goto done;
+   }
+
+   if(copy_to_user(usr_buf,out_buf,in_buf[SMBUS_RD_LEN_OFF]))
+   {
+      pr_err("err copy_to_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("read result:\n");printk_hex_info(out_buf,in_buf[SMBUS_RD_LEN_OFF]);
+#endif
+   result = in_buf[SMBUS_RD_LEN_OFF];
+
+done:
+   mutex_unlock(i2c_drv_data_ptr->mutex_ptr);
+
+   if( result < 0 )
+   {
+      pr_err("I2C_ADDR:0x%X,result err: %d\n",*((u16*)usr_buf),result);
+   }
+
+   return result;
+}
+EXPORT_SYMBOL(nai_smbus_dev_read);
+
+#ifdef MULTI_ACCESSING
+static int32_t smbus_write_block
+(
+   struct i2c_client* i2c_cli_ptr,
+   const char *buf,
+   unsigned offset,
+   size_t count
+)
+{
+#define ATMEL_AT24_PAGE_WRITE_SIZE    8 /*see the data sheet about Page Write in Atmel AT24CS01 and AT24CS02 Page 10*/
+  
+  int32_t status;
+
+  if (count > I2C_SMBUS_BLOCK_MAX)
+  {
+     count = I2C_SMBUS_BLOCK_MAX;
+  }
+
+  status = i2c_smbus_write_i2c_block_data( i2c_cli_ptr, offset, count, buf );
+
+  if (status == 0)
+  {
+#ifdef DEBUG_IT
+     pr_info("I2C_ADDR:0x%X,adp.:0x%p,wr:%zu,cmd/off:0x%02x,buf[0]:0x%02x,sts:%d\n",i2c_cli_ptr->addr,i2c_cli_ptr->adapter,count,offset,buf[0],status);
+#endif
+     status = count;
+  }
+  else
+  {
+     pr_err("I2C_ADDR:0x%X,err:adp.:0x%p,wr:%zu,cmd/off:0x%02x,buf[0]:0x%02x,sts:%d\n",i2c_cli_ptr->addr,i2c_cli_ptr->adapter,count,offset,buf[0],status);
+  }
+
+  return status;
+}
+EXPORT_SYMBOL(smbus_write_block);
+
+int32_t nai_smbus_write_block
+(
+   struct i2c_adapter *i2c_adapter_ptr,
+   const uint8_t* io_buf,
+   uint16_t io_buf_sz
+)
+{
+   int32_t result = 0, status;
+   uint8_t off=io_buf[SMBUS_WR_CMD_OFF];
+   size_t wr_cnt=io_buf[SMBUS_WR_DATA_LEN_OFF];
+   const uint8_t* wr_buf;
+   struct i2c_client i2c_cli;
+   build_i2c_client_addr(&i2c_cli,io_buf);
+   i2c_cli.adapter = i2c_adapter_ptr;
+#ifdef DEBUG_IT
+   pr_info("i2c_cli.addr=0x%x\n",i2c_cli.addr);
+   printk_hex_info(io_buf,SMBUS_WR_DATA_OFF+io_buf[SMBUS_WR_DATA_LEN_OFF]);
+#endif
+
+   wr_buf=io_buf+SMBUS_WR_DATA_OFF;
+
+#ifdef DEBUG_IT
+   pr_info("write info:\n");
+   printk_hex_info(wr_buf,wr_cnt);
+#endif
+
+   while ( wr_cnt != 0 )
+   { 
+      uint32_t retry_cnt;
+
+      for(retry_cnt=0;retry_cnt<RETRY_LIMIT;retry_cnt++)
+      {
+         status = smbus_write_block(&i2c_cli,wr_buf,off,wr_cnt);
+         if ( status >= 0 )
+         {
+
+            if(retry_cnt>0)
+            {
+               pr_err("retried %u,recovered -EBUSY|ENXIO wr:%d,cmd/off:0x%02x,wr_buf[0]:0x%x OK.\n",retry_cnt,status,off,wr_buf[0]);
+            }
+
+            wr_buf += status;
+            off += status;
+            wr_cnt -= status;
+            result += status;
+            break;
+         }
+         else if ( status == -EBUSY || status == -ENXIO )
+         { /*some time, PS4 returns -EBUSY, and AT24 EEPROM returns -ENXIO*/
+            pr_err("I2C_ADDR:0x%X,wr_blk err:-EBUSY|ENXIO, retry:%d\n",i2c_cli.addr,retry_cnt+1);
+            udelay( UDELAY_VAL );
+         }
+         else
+         {
+            pr_err("smbus_write_block(...) err:%d",status);
+            break;/*break for(tetry_cnt=0;tetry_cnt<ETRY_LIMIT;retry_cnt++)*/
+         }
+      }/*for(retry_cnt=0;retry_cnt<RETRY_LIMIT;retry_cnt++)*/
+
+      if( status < 0 )
+      {
+         pr_err("I2C_ADDR:0x%X,smbus_write_block(...) err:%d\n",i2c_cli.addr,status);
+         result=status;
+         break;/*break while ( wr_cnt != 0 )*/
+      }
+#ifdef DEBUG_IT
+      else
+      {
+         pr_info("exp %d,wr %d ok\n",io_buf[SMBUS_WR_DATA_LEN_OFF],result);
+      }
+#endif
+   }/*while ( wr_cnt != 0 )*/
+
+#ifdef DEBUG_IT
+   pr_info("result:%d\n",result);
+#endif
+
+   return result;
+}
+#else /* !MULTI_ACCESSING */
+s32 nai_smbus_write_block
+(
+   struct i2c_adapter *i2c_adapter_ptr,
+   const u8* in_buf,
+   u16 in_buf_len
+)
+{
+   s32 result = -1;
+   int layer_1_retry_cnt;
+   struct i2c_client i2c_cli;
+   i2c_cli.adapter = i2c_adapter_ptr;
+
+   i2c_cli.flags=0; /*bug fix for sending invalid I2C slave address*/
+
+   /*little-endian*/
+   i2c_cli.addr = in_buf[SMBUS_WR_ADDR_EXT_OFF];
+   i2c_cli.addr <<= 8;
+   i2c_cli.addr |= in_buf[SMBUS_WR_ADDR_OFF];
+
+   if ( in_buf[ SMBUS_WR_ADDR_EXT_OFF ] & 0xFF )
+   {
+      i2c_cli.flags |= I2C_M_TEN;
+   }
+   for ( layer_1_retry_cnt = 0; layer_1_retry_cnt < RETRY_LIMIT; layer_1_retry_cnt++ )
+   {
+#ifdef DEBUG_IT
+      pr_info("in_buf[SMBUS_WR_DATA_LEN_OFF:0x%x]:0x%x",SMBUS_WR_DATA_LEN_OFF,in_buf[SMBUS_WR_DATA_LEN_OFF]);printk_hex_info(&in_buf[SMBUS_WR_DATA_OFF],in_buf[SMBUS_WR_DATA_LEN_OFF]);
+#endif
+      result = i2c_smbus_write_i2c_block_data( &i2c_cli, in_buf[SMBUS_WR_CMD_OFF], in_buf[SMBUS_WR_DATA_LEN_OFF], &in_buf[SMBUS_WR_DATA_OFF] );
+      if ( result == 0 )
+      {
+#ifdef DEBUG_IT
+         pr_info("wr cmd '0x%x',data_len:0x%x:\n",in_buf[SMBUS_WR_CMD_OFF],in_buf[SMBUS_WR_DATA_LEN_OFF]);printk_hex_info(&in_buf[SMBUS_WR_DATA_OFF],in_buf[SMBUS_WR_DATA_LEN_OFF]);
+#endif
+         if ( layer_1_retry_cnt > 0 )
+         {
+            pr_err("recovered after tried %d, i2c_smbus_write_i2c_block_data(0x%x,0x%02x,0x%02x,%02x)\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_WR_DATA_LEN_OFF],in_buf[SMBUS_WR_DATA_OFF]);
+         }
+         result = in_buf[SMBUS_WR_DATA_LEN_OFF];
+         break;
+      }
+      else
+      {
+         if ( result == -EBUSY || -ENXIO )
+         { /*some time, PS4 returns -EBUSY, and AT24 EEPROM returns -ENXIO*/
+            pr_err("tried %d, i2c_smbus_write_i2c_block_data(0x%x,0x%02x,0x%02x,%02x),errno=%d\n",layer_1_retry_cnt,i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_WR_DATA_LEN_OFF],in_buf[SMBUS_WR_DATA_OFF],result);
+            udelay( UDELAY_VAL );
+         }
+         else
+         {
+            pr_err("i2c_smbus_write_i2c_block_data(0x%x,0x%02x,0x%02x,%02x),errno=%d\n",i2c_cli.addr,in_buf[SMBUS_RD_CMD_OFF],in_buf[SMBUS_WR_DATA_LEN_OFF],in_buf[SMBUS_WR_DATA_OFF],result);
+            break;
+         }
+      }
+   }
+   return result;
+}
+EXPORT_SYMBOL(nai_smbus_write_block);
+#endif /* MULTI_ACCESSING */
+
+ssize_t nai_smbus_dev_write(struct file *filp, const char __user *usr_buf, size_t len, loff_t *off)
+{
+   int result=0;
+   uint8_t in_buf[NAI_I2C_SMBUS_RD_WR_MGR_BUF_LEN+SMBUS_TRX_BUF_LEN_MAX];
+
+   struct i2c_smbus_drv_data *i2c_drv_data_ptr=filp->private_data;
+
+#ifdef DEBUG_IT
+   pr_info("usr_buf[SMBUS_WR_DATA_LEN_OFF:0x%x]=%d,usr_buf:\n",SMBUS_WR_DATA_LEN_OFF,usr_buf[SMBUS_WR_DATA_LEN_OFF]);printk_hex_info(usr_buf,SMBUS_WR_DATA_OFF+usr_buf[SMBUS_WR_DATA_LEN_OFF]);
+#endif
+   mutex_lock(i2c_drv_data_ptr->mutex_ptr);
+   memset(in_buf,0,sizeof(in_buf));
+   if ( len < the_max(NAI_SMBUS_WR_MGR_HEADER_SZ,usr_buf[SMBUS_WR_DATA_LEN_OFF]) )
+   {
+      pr_err("len=%zd, SMBUS_WR_DATA_OFF=%d,usr_buf[SMBUS_WR_DATA_LEN_OFF]=%d,error input format\n",len,SMBUS_WR_DATA_OFF,usr_buf[SMBUS_WR_DATA_LEN_OFF]);
+      result = -EINVAL;
+      goto done;
+   }
+
+   memset(in_buf,0,sizeof(in_buf));
+
+   if ( copy_from_user(in_buf,usr_buf,SMBUS_WR_DATA_OFF+usr_buf[SMBUS_WR_DATA_LEN_OFF]) )
+   {
+      pr_err("error copy_from_user()\n");
+      result = -EFAULT;
+      goto done;
+   }
+#ifdef DEBUG_IT
+   pr_info("in_buf[SMBUS_WR_DATA_LEN_OFF:0x%x]=%d,payload:\n",SMBUS_WR_DATA_LEN_OFF,in_buf[SMBUS_WR_DATA_LEN_OFF]);printk_hex_info(in_buf+SMBUS_WR_DATA_OFF,in_buf[SMBUS_WR_DATA_LEN_OFF]);
+#endif
+
+   result = nai_smbus_write_block( i2c_drv_data_ptr->i2c_adapter_ptr,in_buf,len < SMBUS_WR_DATA_OFF ? SMBUS_WR_DATA_OFF:SMBUS_WR_DATA_OFF+in_buf[SMBUS_WR_DATA_LEN_OFF] );
+   if ( result != in_buf[SMBUS_WR_DATA_LEN_OFF] )
+   {
+      pr_err("I2C_ADDR:0x%X,err in nai_smbus_write_block() %d\n",*((u16*)usr_buf),result);
+   }
+
+done:
+   mutex_unlock(i2c_drv_data_ptr->mutex_ptr);
+
+   return result;
+}
+EXPORT_SYMBOL(nai_smbus_dev_write);
diff --git a/drivers/misc/nai-generic-i2c/shared_smbus.h b/drivers/misc/nai-generic-i2c/shared_smbus.h
new file mode 100644
index 0000000..3ca7e91
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/shared_smbus.h
@@ -0,0 +1,10 @@
+#ifndef _SHARED_SMBUS_H_
+#define _SHARED_SMBUS_H_
+
+ssize_t nai_smbus_dev_write(struct file *filp, const char __user *usr_buf, size_t len, loff_t *off);
+ssize_t nai_smbus_dev_read(struct file *filp, char __user *usr_buf, size_t len, loff_t *off);
+
+int32_t nai_smbus_write_block(struct i2c_adapter*i2c_adapter_ptr, const uint8_t* io_buf, uint16_t io_buf_sz);
+int32_t nai_smbus_read_block(struct i2c_adapter *i2c_adapter_ptr, const uint8_t* in_buf, uint16_t in_buf_len, uint8_t* out_buf, uint16_t out_buf_len);
+
+#endif /*_SHARED_SMBUS_H_*/
diff --git a/drivers/misc/nai-generic-i2c/shared_utils.c b/drivers/misc/nai-generic-i2c/shared_utils.c
new file mode 100644
index 0000000..5a3fba6
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/shared_utils.c
@@ -0,0 +1,170 @@
+#include <linux/init.h>
+#define pr_fmt(fmt) "%s:%d>" fmt,strrchr(__FILE__,'/'),__LINE__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#if (KERNEL_VERSION(2,6,18) > LINUX_VERSION_CODE)
+#include <linux/config.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/cdev.h>
+#include <asm/ioctl.h>
+#include <asm/irq.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 3, 0)
+#include <asm/switch_to.h>
+#else
+#include <asm/system.h>
+#endif
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+
+#include "nai_generic_i2c.h"
+#include "shared_utils.h"
+
+#define RETRY_LIMIT          3
+
+struct i2c_smbus_drv_data* create_dev_fs
+(
+   const char* dev_file_name,
+   const char* parent_name,
+   struct file_operations* file_ops,
+   uint32_t i2c_addr_num,
+   uint8_t chip_flags,
+   int* status
+)
+{
+   struct i2c_smbus_drv_data *i2c_drv_data_ptr;
+   /*
+    * devm_kzalloc() is resource-managed kzalloc(). The memory allocated with resource-managed
+    * functions is associated with the device. When the device is detached from the system or the
+    * driver for the device is unloaded, that memory is freed automatically. It is possible to
+    * free the memory with devm_kfree() if it's no longer needed.
+    * i2c_drv_data_ptr=devm_kzalloc(&pdev->dev,sizeof(*i2c_drv_data_ptr),GFP_KERNEL);
+    */
+   i2c_drv_data_ptr=kzalloc(sizeof(*i2c_drv_data_ptr)+ i2c_addr_num * sizeof(struct i2c_client *),GFP_KERNEL);
+
+   if ( i2c_drv_data_ptr==NULL )
+   {
+      pr_err("kmalloc(struct i2c_smbus_drv_data,GFP_KERNEL) err\n");
+      *status = -ENOMEM;
+      goto err_step_1;
+   }
+
+   memset( i2c_drv_data_ptr, 0, sizeof(*i2c_drv_data_ptr) );
+#ifdef DEBUG_IT
+   pr_info("i2c_drv_data_ptr vir_addr=0x%p\n",i2c_drv_data_ptr);
+#endif
+                                                                 /*check man page, vs register_chrdev*/
+   if ((*status = alloc_chrdev_region(&i2c_drv_data_ptr->first, 0, 1, parent_name)) < 0) /*listed in /proc/devices more than ones*/
+   {
+      pr_err("alloc_chrdev_region() err=%d\n",*status);
+      goto err_step_2;
+   }
+
+   if (IS_ERR(i2c_drv_data_ptr->generic_i2c_class = class_create(THIS_MODULE, dev_file_name)))
+   {
+      pr_err("class_create() err=%ld for file \"%s\"\n",PTR_ERR(i2c_drv_data_ptr->generic_i2c_class),dev_file_name);
+      *status=PTR_ERR(i2c_drv_data_ptr->generic_i2c_class);
+      goto err_step_3;
+   }
+
+   if (IS_ERR(device_create(i2c_drv_data_ptr->generic_i2c_class, NULL, i2c_drv_data_ptr->first, NULL, dev_file_name)))
+   {
+      *status = PTR_ERR(device_create(i2c_drv_data_ptr->generic_i2c_class, NULL, i2c_drv_data_ptr->first, NULL, dev_file_name));
+      pr_err("device_create() err=%d, for file \"%s\"\n",*status,dev_file_name);
+      goto err_step_4;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("device file \"%s\" created\n",dev_file_name);
+#endif
+   /* c_dev is the member of i2c_drv_data_ptr points to, the address of i2c_drv_data_ptr can be gotten from address of c_dev with container_of(...)*/
+   cdev_init(&i2c_drv_data_ptr->c_dev,file_ops); /*make the link from address of struct cdev to address of struct struct i2c_smbus_drv_data*/
+   if ((*status = cdev_add(&i2c_drv_data_ptr->c_dev, i2c_drv_data_ptr->first, 1)) < 0)
+   {
+      pr_err("cdev_add() err=%d\n",*status);
+      goto err_step_5;
+   }
+
+   i2c_drv_data_ptr->io_limit = g_io_limit;
+   i2c_drv_data_ptr->write_timeout = g_write_timeout;
+   i2c_drv_data_ptr->chip_access_flags |= chip_flags; 
+   i2c_drv_data_ptr->num_addresses=i2c_addr_num;
+   return i2c_drv_data_ptr;
+
+err_step_5:
+   device_destroy(i2c_drv_data_ptr->generic_i2c_class, i2c_drv_data_ptr->first);
+err_step_4:
+   class_destroy(i2c_drv_data_ptr->generic_i2c_class);
+err_step_3:
+   unregister_chrdev_region(i2c_drv_data_ptr->first,1);
+err_step_2:
+   kfree(i2c_drv_data_ptr);
+err_step_1:
+   return NULL;
+}
+EXPORT_SYMBOL(create_dev_fs);
+
+void delete_char_dev( struct i2c_smbus_drv_data* i2c_smbus_drv_data_ptr )
+{
+   cdev_del(&i2c_smbus_drv_data_ptr->c_dev);
+   device_destroy(i2c_smbus_drv_data_ptr->generic_i2c_class, i2c_smbus_drv_data_ptr->first);
+   class_destroy(i2c_smbus_drv_data_ptr->generic_i2c_class);
+   unregister_chrdev_region(i2c_smbus_drv_data_ptr->first,1);
+   kfree(i2c_smbus_drv_data_ptr);
+}
+EXPORT_SYMBOL(delete_char_dev);
+
+void build_i2c_client_addr(struct i2c_client* i2c_cli,const uint8_t* in_buf)
+{
+   i2c_cli->flags = 0; /*bug fix for sending invalid I2C slave address*/
+
+   /*little-endian*/
+   i2c_cli->addr = in_buf[SMBUS_WR_ADDR_EXT_OFF];
+   i2c_cli->addr <<= 8;
+   i2c_cli->addr |= in_buf[SMBUS_WR_ADDR_OFF];
+
+   if ( in_buf[ SMBUS_RD_ADDR_EXT_OFF ] & 0xFF )
+   {
+      i2c_cli->flags |= I2C_M_TEN;
+   }
+}
+EXPORT_SYMBOL(build_i2c_client_addr);
+
+//#ifdef DEBUG_IT
+void printk_hex_info(const uint8_t* hex_info,unsigned int info_size)
+{
+   #define COLUMN_NUM 16
+   #define DELIMITER ','
+   #define ELEMENT_SIZE 3  /*including 2 bytes hex num and 1 byte field delimiter ',' or '\n'*/
+   char work_buf[ELEMENT_SIZE*COLUMN_NUM+sizeof(int)/*sizeof(int) is used for last str delimiter '\0' and mem alignment*/];
+   unsigned int i;
+
+   memset(work_buf,0,sizeof(work_buf));
+   for(i=0;i<info_size;i++)
+   {
+      sprintf(work_buf+(i*ELEMENT_SIZE)%(COLUMN_NUM*ELEMENT_SIZE),"%02x%c",hex_info[i],(i==(info_size-1)||(i+1)%COLUMN_NUM==0)?'\n':DELIMITER);
+      if(i==(info_size-1)||(i+1)%COLUMN_NUM==0)
+      {
+         printk(KERN_INFO"%s",work_buf);
+         memset(work_buf,0,sizeof(work_buf));
+      }
+   }
+}
+EXPORT_SYMBOL(printk_hex_info);
+//#endif /* #ifdef DEBUG_IT */
+
+uint32_t the_max( uint32_t a, uint32_t b )
+{
+   return a >= b ? a : b;
+}
+EXPORT_SYMBOL(the_max);
diff --git a/drivers/misc/nai-generic-i2c/shared_utils.h b/drivers/misc/nai-generic-i2c/shared_utils.h
new file mode 100644
index 0000000..3c82316
--- /dev/null
+++ b/drivers/misc/nai-generic-i2c/shared_utils.h
@@ -0,0 +1,56 @@
+#ifndef _SHARED_UTILS_H_
+#define _SHARED_UTILS_H_
+
+//#define DEBUG_IT
+#define RETRY_LIMIT 3
+static unsigned g_io_limit = 128;
+module_param(g_io_limit, uint, 0);
+MODULE_PARM_DESC(g_io_limit, "Maximum bytes per I/O (default 128)");
+ 
+static unsigned g_write_timeout = 25;
+module_param(g_write_timeout, uint, 0);
+MODULE_PARM_DESC(g_write_timeout, "Time (in ms) to try writes (default 25)");
+
+enum I2C_ADAPTERS
+{
+   I2C_ADAPTER_0,
+   I2C_ADAPTER_1,
+   I2C_ADAPTER_NUM
+};
+
+struct i2c_smbus_drv_data
+{
+   struct cdev c_dev;                   /*make the link from address of struct cdev to address of struct struct i2c_smbus_drv_data*/
+   struct class *generic_i2c_class;     /*device class*/
+   dev_t first;                         /*for the first device number*/
+   struct mutex *mutex_ptr;             /*shared by all instances*/
+   struct i2c_adapter *i2c_adapter_ptr; //TBD shared by all instances ???
+   uint16_t user_cnt;
+   uint8_t chip_access_flags;           //TBD create ioctl(...) to re-set/change it, 2018-11-19
+   uint16_t io_limit;                   //TBD create ioctl(...) to re-set/change it, 2018-11-19
+   uint32_t write_timeout;
+   uint16_t num_addresses;
+   struct i2c_client *clients[];
+};
+
+void build_i2c_client_addr(struct i2c_client* i2c_cli,const u8* in_buf);
+
+struct i2c_smbus_drv_data* create_dev_fs
+(
+   const char* dev_file_name,
+   const char* parent_name,
+   struct file_operations* file_ops,
+   uint32_t i2c_addr_num,
+   uint8_t chip_flags,
+   int* status
+);
+
+void delete_char_dev( struct i2c_smbus_drv_data* i2c_smbus_drv_data_ptr );
+
+//#ifdef DEBUG_IT
+void printk_hex_info(const u8* hex_info,unsigned int info_size);
+//#endif DEBUG_IT
+
+uint32_t the_max( uint32_t a, uint32_t b );
+
+#endif /*_SHARED_UTILS_H_*/
diff --git a/drivers/misc/nai-pci-device/Kconfig b/drivers/misc/nai-pci-device/Kconfig
new file mode 100644
index 0000000..97f8d8c
--- /dev/null
+++ b/drivers/misc/nai-pci-device/Kconfig
@@ -0,0 +1,11 @@
+menu "NAI PCI Device support"
+
+config NAI_PCI_DEVICE
+	tristate "NAI PCI Device"
+	select CONFIG_PCI
+	help
+	  This option to enable NAI PCI Device Support.
+
+	  If unsure, say N.
+
+endmenu
diff --git a/drivers/misc/nai-pci-device/Makefile b/drivers/misc/nai-pci-device/Makefile
new file mode 100644
index 0000000..6690d1f
--- /dev/null
+++ b/drivers/misc/nai-pci-device/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_NAI_PCI_DEVICE)	+= naipci.o
+
diff --git a/drivers/misc/nai-pci-device/naioctl.h b/drivers/misc/nai-pci-device/naioctl.h
new file mode 100755
index 0000000..a900d7f
--- /dev/null
+++ b/drivers/misc/nai-pci-device/naioctl.h
@@ -0,0 +1,253 @@
+#ifndef NAIOCTL_H
+#define NAIOCTL_H
+
+/* Since this file needs to be kept in sync with naibrd driver, we will leave file as it looks for naibrd except we force the definition of LINUX here */
+#define LINUX 1
+
+#ifdef WIN32
+/* Suppress "warning C4201: nonstandard extension used : nameless struct/union" */
+#pragma warning( disable : 4201)
+#endif
+
+#ifndef ULONG
+#ifdef NAI_VISA
+#define ULONG unsigned long
+#else
+#define ULONG unsigned int
+#endif
+#endif
+
+#ifndef USHORT
+#define USHORT unsigned short
+#endif
+
+#ifndef UCHAR
+#define UCHAR unsigned char
+#endif
+
+#if defined(LINUX) || defined(VXWORKS) || defined(LYNX)|| defined(NAI_RTP)
+
+/*For moudle Block Transfer*/
+#define BLK_CAPABLE                  (1 << 0)
+#define BLK_FIFO_CAPABLE             (1 << 1)
+#define PCK_CAPABLE                  (1 << 2)
+#define DATA_WIDTH16BIT              (2)  /*Two bytes*/
+#define DATA_WIDTH32BIT              (4)  /*Four bytes*/
+#define READ_OP              		    (0)  
+#define WRITE_OP              		 (1)  
+
+#define NAI_TYPE 0x44
+#define NAI_HWREV_GEN5  0x2 
+
+#define IOCTL_NAI_READ_PORT_UCHAR     _IOWR(NAI_TYPE, 0, NAI_READ_OUTPUT)
+#define IOCTL_NAI_READ_PORT_USHORT    _IOWR(NAI_TYPE, 1, NAI_READ_OUTPUT)
+#define IOCTL_NAI_WRITE_PORT_UCHAR    _IOWR(NAI_TYPE, 2, NAI_WRITE_INPUT)
+#define IOCTL_NAI_WRITE_PORT_USHORT   _IOWR(NAI_TYPE, 3, NAI_WRITE_INPUT)
+#define IOCTL_NAI_READ_INFO           _IOWR(NAI_TYPE, 4, NAI_DEVICE_CONFIG)
+#define IOCTL_NAI_INT_TRIGGER_ENABLE  _IOWR(NAI_TYPE, 5, NAI_INTERRUPT_DATA)
+#define IOCTL_NAI_INT_CONFIGURE       _IOWR(NAI_TYPE, 6, NAI_INT_CONFIG)
+#define IOCTL_NAI_INT_HOOK            _IOWR(NAI_TYPE, 7, NAI_INT_HOOK)
+#define IOCTL_NAI_INT_DATA            _IOWR(NAI_TYPE, 8, NAI_INT_DATA)
+#define IOCTL_NAI_INT_DISABLE         _IOWR(NAI_TYPE, 9, NAI_INT_DATA)
+
+/* for VME Address, LynxOS */
+#define IOCTL_NAI_GET_VME_BASE_ADDR   _IOWR(NAI_TYPE, 10, NAI_READ_OUTPUT)
+#define IOCTL_NAI_GET_VME_ADDR        _IOWR(NAI_TYPE, 11, NAI_READ_OUTPUT)
+#define IOCTL_NAI_SET_VME_ADDR        _IOWR(NAI_TYPE, 12, NAI_READ_OUTPUT)
+
+#define IOCTL_NAI_READ_PORT_32     _IOWR(NAI_TYPE, 13, NAI_READ_OUTPUT)
+#define IOCTL_NAI_WRITE_PORT_32    _IOWR(NAI_TYPE, 14, NAI_WRITE_INPUT)
+#define IOCTL_NAI_READ_PCIINFO        _IOWR(NAI_TYPE, 15, NAI_DEVICE_CONFIG)
+#define IOCTL_NAI_HW_BLOCK_READ       _IOR(NAI_TYPE, 16, NAI_BLOCK_DATA)
+#define IOCTL_NAI_HW_BLOCK_WRITE      _IOW(NAI_TYPE, 17, NAI_BLOCK_DATA)
+#define IOCTL_NAI_READ_SHRM	      _IOWR(NAI_TYPE, 18, nai_shrm_data)
+#define IOCTL_NAI_WRITE_SHRM	      _IOWR(NAI_TYPE, 19, nai_shrm_data)
+#define IOCTL_NAI_GEN_IRQ_SHRM	      _IO(NAI_TYPE, 20)
+#define IOCTL_NAI_HW_BLOCK_READ_CAP   _IOR(NAI_TYPE, 21, NAI_BLOCK_DATA_CAP)
+#define IOCTL_NAI_HW_BLOCK_WRITE_CAP  _IOW(NAI_TYPE, 22, NAI_BLOCK_DATA_CAP)
+#define IOCTL_NAI_GET_PCI_MOD_REV     _IOR(NAI_TYPE, 23, NAI_MODULE_PCI_REVISION)
+
+#else /* WIN32 */
+
+/* Device type in the "User Defined" range. */
+#define NAI_TYPE 50000
+
+#define IOCTL_NAI_READ_PORT_USHORT \
+CTL_CODE(NAI_TYPE, 0x0, METHOD_BUFFERED, FILE_READ_ACCESS )
+
+#define IOCTL_NAI_WRITE_PORT_USHORT \
+CTL_CODE(NAI_TYPE, 0x1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+#define IOCTL_NAI_READ_PORT_UCHAR \
+CTL_CODE(NAI_TYPE, 0x2, METHOD_BUFFERED, FILE_READ_ACCESS )
+
+#define IOCTL_NAI_WRITE_PORT_UCHAR \
+CTL_CODE(NAI_TYPE, 0x3, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+#define IOCTL_NAI_INT_TRIGGER_ENABLE \
+CTL_CODE(NAI_TYPE, 0x4, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_NAI_READ_INFO \
+CTL_CODE(NAI_TYPE, 0x5, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_NAI_INT_CONFIGURE \
+CTL_CODE(NAI_TYPE, 0x6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+#define IOCTL_NAI_READ_PORT_32 \
+CTL_CODE(NAI_TYPE, 0x7, METHOD_BUFFERED, FILE_READ_ACCESS )
+
+#define IOCTL_NAI_WRITE_PORT_32 \
+CTL_CODE(NAI_TYPE, 0x8, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+#define IOCTL_NAI_READ_PCIINFO \
+CTL_CODE(NAI_TYPE, 0x9, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#endif
+
+
+typedef struct _NAI_MODULE_PCI_REVISION {
+	uint8_t pciMajorRev;
+	uint8_t pciMinorRev;
+} NAI_MODULE_PCI_REVISION;
+
+typedef struct _NAI_WRITE_INPUT
+{
+  ULONG   PortNumber; /* Offset to write */
+  union               /* Data to be written */
+  {
+    ULONG   LongData;
+    USHORT  ShortData;
+    UCHAR   CharData;
+  } data;  /* VxWorks needs union name */
+} NAI_WRITE_INPUT;
+
+typedef struct _NAI_READ_OUTPUT
+{
+  union               /* Data to be read */
+  {
+	ULONG   LongData;
+	USHORT  ShortData;
+	UCHAR   CharData;
+  } data;  /* VxWorks needs union name */
+} NAI_READ_OUTPUT;
+
+/*
+   This structure is used with IOCTL_NAI_READ_INFO to
+   obtain configuration information from the device.
+*/
+
+typedef struct _NAI_DEVICE_CONFIG {
+
+  ULONG BaseAdr;
+  ULONG PortCount;
+  UCHAR IrqLine;
+  UCHAR Status;
+  ULONG bPCIDevice;
+  ULONG BusNum;
+  ULONG DeviceId;
+
+} NAI_DEVICE_CONFIG, *PNAI_DEVICE_CONFIG;
+
+/*
+   This structure is used with IOCTL_NAI_READ_PCIINFO to
+   obtain configuration information from the device.
+   Note, this structure is an extension of the NAI_DEVICE_CONFIG
+   structure, with additional fields for the Device Number,
+   Function Number and Slot Number.
+*/
+
+typedef struct _NAI_DEVICE_CONFIG_EX {
+
+  ULONG BaseAdr;
+  ULONG PortCount;
+  UCHAR IrqLine;
+  UCHAR Status;
+  ULONG bPCIDevice;
+  ULONG BusNum;
+  ULONG DeviceId;
+  ULONG DeviceNum;
+  ULONG FunctionNum;
+  ULONG SlotNum;
+
+} NAI_DEVICE_CONFIG_EX, *PNAI_DEVICE_CONFIG_EX;
+
+/*
+   These flags are used on NAI_DEVICE_CONFIG.Status.
+*/
+#define NAI_STATUS_READY    0x00000000
+#define NAI_STATUS_CONFLICT 0x00000001
+
+typedef struct _NAI_READ_INFO
+{
+   NAI_DEVICE_CONFIG DeviceConfig;
+
+} NAI_INFO_BUFFER;
+
+typedef struct _NAI_READ_PCIINFO
+{
+   NAI_DEVICE_CONFIG_EX DeviceConfig;
+
+} NAI_PCIINFO_BUFFER;
+
+/*
+   This structure is used with IOCTL_NAI_INT_CONFIGURE to
+   change the interrupt handling behavior on the device.
+*/
+
+typedef struct _NAI_INT_CONFIG {
+  ULONG  ReadAddr;
+  ULONG  WriteAddr;
+  ULONG  WriteValue;
+} NAI_INT_CONFIG, *PNAI_INT_CONFIG;
+
+typedef struct _NAI_INT_HOOK {
+	ULONG Level;
+	ULONG Vector;
+	ULONG tid;
+} NAI_INT_HOOK, *PNAI_INT_HOOK;
+
+typedef struct _NAI_INT_DATA {
+	ULONG Level;
+	ULONG Vector;
+} NAI_INT_DATA, *PNAI_INT_DATA;
+
+typedef struct _NAI_INTERRUPT_DATA {
+	union
+   {
+   USHORT UshortData;
+   ULONG  UlongData;
+   }data;
+} NAI_INTERRUPT_DATA;
+
+typedef struct _NAI_BLOCK_DATA {
+	uint32_t in_RegAddr;
+   uint32_t in_Stride;
+   uint32_t in_Count;
+   uint32_t in_RegWidth;
+   uint32_t in_DataWidth;
+   uint32_t in_Module;
+   void *   dataBuffer;
+} NAI_BLOCK_DATA;
+
+
+typedef struct _NAI_BLOCK_DATA_CAP {
+	uint32_t in_RegAddr;
+   uint32_t in_Stride;
+   uint32_t in_Count;
+   uint32_t in_RegWidth;
+   uint32_t in_DataWidth;
+   uint32_t in_Module;
+   uint32_t in_Cap;
+   uint32_t in_Spare;
+   void *   dataBuffer;
+} NAI_BLOCK_DATA_CAP;
+
+typedef struct _nai_shrm_data{
+        void *   pbuf;
+        uint32_t offset;
+        uint32_t len;
+        int32_t  err;
+        int32_t  pad; /*memory alignment to calculte IOCTL_NAI_WRITE_SHRM and IOCTL_NAI_READ_SHRM */
+} nai_shrm_data;
+
+#endif /*NAIOCTL.H */
diff --git a/drivers/misc/nai-pci-device/naipci.c b/drivers/misc/nai-pci-device/naipci.c
new file mode 100644
index 0000000..c06b6aa
--- /dev/null
+++ b/drivers/misc/nai-pci-device/naipci.c
@@ -0,0 +1,2193 @@
+/* =========================================================================
+ *
+ * Copyright (c) 2013 North Atlantic Industries, Inc.  All Rights Reserved.
+ *
+ * Author: North Atlantic Industries, Inc.
+ *
+ * SubSystem: Linux kernel 2.6.x device driver for PCI boards
+ *
+ * FileName: naipci.c
+ *
+ * History:
+ *
+ * 09-24-07 JC Added multiple PCI card support in x86 Linux.
+ * 10-01-07 JC Added User level ISR support in x86 Linux
+ * 12-12-07 JC Fedora 7 support, passing Bus#, Slot#, Card Index for NaiProbeDevice
+ * 01-30-08 JC PCI hardware changed Interrupt handling
+ * 03-10-10 JC supported Linux 2.6.31 - Fedora 12
+ * 03-24-10 JC supported Linux 64-bit Fedora 12
+ * 11-07-11 DT Modified to deal with kernel changes surrounding ioctl.
+ *             (device_ioctl definition changed and file_operations struct changed)
+ *             Also changed init_MUTEX calls to used sema_init when init_MUTEX
+ *             is not defined.
+ *
+ * 11-03-20 JH Modified to fix kernel panic built with petalinux-v2018.2, should be
+ *             backword campatible
+ * ==========================================================================*/
+#include <linux/module.h>
+#ifdef  pr_fmt
+#undef pr_fmt
+#endif
+#define pr_fmt(fmt) "NAI %s:%s:%d::" fmt, strrchr(__FILE__,'/'), __func__, __LINE__
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#if (KERNEL_VERSION(2,6,18) > LINUX_VERSION_CODE)
+#include <linux/config.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/msi.h>
+#include <linux/wait.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/cdev.h>
+#include <asm/io.h>
+#include <asm/ioctl.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 3, 0)
+#include <asm/switch_to.h>
+#else
+#include <asm/system.h>
+#endif
+//#if LINUX_VERSION_CODE > KERNEL_VERSION(4,0,0)
+#include <linux/uaccess.h>
+//#else
+//#include <asm/uaccess.h>
+//#endif
+#include <asm/hardirq.h>
+#include <asm/setup.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#include "../nai_KerModRev.h"
+
+#include "naioctl.h"
+
+//#define DEBUG_MODULE
+
+#define DRIVER_AUTHOR    "NAI Support <TechSupport@naii.com>"
+#define DRIVER_DESC      "NAI Inc. Generic Driver"
+#define DRIVER_VERSION	 "1.10"
+
+#define DEVICE_NAME      "nai_pci"
+#define NAI_MAX_DEVICES  8
+#define PCI_VENDOR_ID_NAI              0x15AC
+#define PCIE_DEVICE_ID_ARRAY_NAI 	   {0x7584, 0x6881, 0x6781}
+#define GEN5_CPCI_DEVICE_ID_ARRAY_NAI  {0x7581}
+#define HW_REV_BAR1      			   0x4
+#define NAI_LEGACY_IRQ_READ_OFFSET     0x3400
+#define NAI_LEGACY_IRQ_WRITE_OFFSET    0x3404
+#define NAI_GEN5_IRQ_READ_OFFSET       0x3F00
+#define NAI_GEN5_IRQ_STATUS_OFFSET     0x3F04
+#define NAI_GEN5_TRIG_IRQ_OFFSET 	   0x3F08
+
+#define MAX_DWORD_IN_BLK_FRAME         125
+#define MAX_WORD_IN_BLK_FRAME          MAX_DWORD_IN_BLK_FRAME * 2
+#define NAI_GEN5_BLK_XFER_OFFSET_ADD   0x3F10
+#define REG_WIDTH_8BIT                 1
+#define REG_WIDTH_16BIT                2 
+#define REG_WIDTH_32BIT                4
+#define MASK_UPPER_WORD                0xFFFF0000
+#define MASK_LOWER_WORD                0xFFFF
+#define NAI_GEN5_BLK_CTRL_HW_DEFAULT   0x00000102
+#define NAI_GEN5_BLK_CTRL_NULL         0x00000000
+#define NAI_GEN5_BLK_CTRL_PACK         0x00010000
+#define NAI_GEN5_BLK_CTRL_AUTO_REARM   0x80000000
+#define NAI_GEN5_BLK_FOUR_BYTE         0x4
+
+#define NAI_GEN5_SHRM_BAR_DISABLE      0x00
+#define NAI_GEN5_SHRM_BAR_ENABLE       0x01
+#define NAI_GEN5_SHRM_SIZE 		       (1 * (1024 * 1024));
+
+#define MAX_SHR_MEM_SIZE               64
+
+typedef struct _NAI_CONFIG
+{
+   ULONG BaseAdr;
+   ULONG PortCount;
+   UCHAR IrqLine;
+   UCHAR Status;
+   ULONG bPCIDevice;
+   ULONG BusNum;
+   ULONG DeviceId;
+} NAI_CONFIG, *PNAI_CONFIG;
+
+static int device_open(struct inode *ip, struct file *fp);
+static int device_release(struct inode *ip, struct file *fp);
+
+/* For kernel versions greater than or equal to 2.6.36 - the device_ioctl static function definition has changed.
+   Additionally, the file_operations structure changed - the .ioctl structure field no longer exists - now .unlocked_ioctl is used instead.*/
+#if (KERNEL_VERSION(2,6,36) <= LINUX_VERSION_CODE)
+static long device_ioctl(struct file *fp, unsigned int ioctl_num, unsigned long ioctl_param);
+#else
+static int device_ioctl(struct inode *ip, struct file *fp, unsigned int ioctl_num, unsigned long ioctl_param);
+#endif
+#ifdef CONFIG_COMPAT
+static long device_compat_ioctl(struct file *fp, unsigned int ioctl_num, unsigned long ioctl_param);
+#endif
+
+/* Globals */
+static struct nai_state *g_dev[NAI_MAX_DEVICES];
+static struct class *nai_class;
+static int g_device_count = 0;
+static int Major = 0;
+static const unsigned short pcieDeviceIdArrayNai[] = PCIE_DEVICE_ID_ARRAY_NAI;
+static const unsigned short gen5cpciDeviceIdArrayNai[] = GEN5_CPCI_DEVICE_ID_ARRAY_NAI;
+
+static DECLARE_WAIT_QUEUE_HEAD(nai_wq);
+
+struct nai_state {
+   /* the corresponding pci_dev structure */
+   struct pci_dev *pdev;
+
+   /* hardware resources */
+   unsigned long memstart;
+   unsigned long memend;
+   void __iomem *base_addr;
+   void __iomem *shrm_base_addr;
+   u32 			shrm_size;
+   u8 			shrm_bar_enabled;
+   unsigned int  irq;
+   unsigned int  device_index;
+   unsigned int  device_open;
+
+   /* PCI ID's */
+   u16 vendorId;  /* PCI Vendor ID */
+   u16 deviceId;  /* PCI Device ID */
+   u8 revId;      /* the chip revision */
+
+   spinlock_t lock;
+   struct semaphore open_sem;
+   mode_t open_mode;
+/*   wait_queue_head_t open_wait; */
+
+   struct semaphore sem;
+   unsigned int irqReadAddr;
+   unsigned int irqWriteAddr;
+   unsigned int irqWriteValue;
+   unsigned short irqValue;
+   unsigned int   irqValue32;
+   unsigned int irqUsrFlag;
+   
+  /* PCI location info */
+   u16 bus_number;
+   u16 slot_number; /* dev number */
+   u16 fn_number;   /* function number */
+};
+
+static u32 rw16Data(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount);
+static u32 rw32Data(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount);
+#ifdef CONFIG_COMPAT
+static u32 rw16DataCompat(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount);
+static u32 rw32DataCompat(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount);
+#endif
+static void configBlockCtrl(struct nai_state *s, u32 inModuleNum,  u32 inBlkCap, u32 inStride,  u32 blkXferSize);
+static u32 getBlockFrame(u32 inCount, u32 in_BlkCap);
+static u32 getRemainingCounts(u32 inCount, u32 inBlkCap);
+static s32 get_pci_module_revision(NAI_MODULE_PCI_REVISION  __user *arg);
+
+struct file_operations fops = {
+  .open = device_open,
+  .release = device_release,
+#if (KERNEL_VERSION(2,6,36) <= LINUX_VERSION_CODE)
+  .unlocked_ioctl = device_ioctl,
+#else
+  .ioctl = device_ioctl,
+#endif
+#ifdef CONFIG_COMPAT
+  .compat_ioctl = device_compat_ioctl,
+#endif
+};
+
+#define NAI_RESOURCE_SIZE_T
+#define NAI_PCI_IOREMAP_BAR
+
+#ifndef NAI_RESOURCE_SIZE_T
+typedef unsigned long resource_size_t;
+#endif
+
+#ifndef NAI_PCI_IOREMAP_BAR
+static inline void * pci_ioremap_bar(struct pci_dev *pdev, int bar)
+{
+        resource_size_t base, size;
+
+		if(pci_resource_len(pdev, bar) == 0){
+			 printk(KERN_ERR "BAR %d Length is 0:%x\n", bar);
+			return NULL;
+		}
+        if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
+                printk(KERN_ERR
+                       "Cannot find proper PCI device base address for BAR %d.\n",
+                       bar);
+                return NULL;
+        }
+
+        base = pci_resource_start(pdev, bar);
+        size = pci_resource_len(pdev, bar);
+
+        return ioremap_nocache(base, size);
+}
+#endif
+
+/* Basic 8-bit, 16-bit, 32-bit read and write functions */
+static void nai_write8(struct nai_state *s, u32 off, u8 data)
+{
+        writeb(data, s->base_addr + off);
+}
+
+static u8 nai_read8(struct nai_state *s, u32 off)
+{
+        return (readb(s->base_addr + off));
+}
+
+static void nai_write16(struct nai_state *s, u32 off, u16 data)
+{
+        writew(data, s->base_addr + off);
+}
+
+static u16 nai_read16(struct nai_state *s, u32 off)
+{
+        return (readw(s->base_addr + off));
+}
+
+static void nai_write32(struct nai_state *s, u32 off, u32 data)
+{
+        writel(data, s->base_addr + off);
+}
+
+static u32 nai_read32(struct nai_state *s, u32 off)
+{
+        return (readl(s->base_addr + off));
+}
+
+#ifdef DEBUG_MODULE
+static void printk_hex_info(unsigned char* hex_info,unsigned int info_size)
+{
+   #define COLUMN_NUM 16
+   #define ELEMENT_SIZE 3  /*including 2 bytes hex num and 1 byte field delimiter ',' or '\n'*/
+   char work_buf[ELEMENT_SIZE*COLUMN_NUM+sizeof(int)/*sizeof(int) is used for last str delimiter '\0' and mem alignment*/];
+   unsigned int i;
+
+   memset(work_buf,0,sizeof(work_buf));
+   for(i=0;i<info_size;i++)
+   {
+      sprintf(work_buf+(i*ELEMENT_SIZE)%(COLUMN_NUM*ELEMENT_SIZE),"%02x%c",hex_info[i],(i==(info_size-1)||(i+1)%COLUMN_NUM==0)?'\n':',');
+      if(i==(info_size-1)||(i+1)%COLUMN_NUM==0)
+      {
+         printk(KERN_INFO"%s",work_buf);
+         memset(work_buf,0,sizeof(work_buf));
+      }
+   }
+}
+#endif
+
+static int nai_shrm_access(struct nai_state *s, nai_shrm_data *usr_arg, u32 rd)
+{
+   int err = 0;
+   u32 oklen = 0;
+   nai_shrm_data tmp_nai_shrm_data;
+
+   err=copy_from_user(&tmp_nai_shrm_data,usr_arg,sizeof(tmp_nai_shrm_data));
+   if(err!=0)
+   {
+      err = -EFAULT;
+      goto exit;
+   }
+
+   if(s->shrm_bar_enabled != NAI_GEN5_SHRM_BAR_ENABLE)
+   {
+      pr_err("device1 s->deviceId=0x%x not enabled\n",s->deviceId);
+      err = -EFAULT;
+      goto exit;
+   }
+
+   if (rd)
+   {  //read operation
+      err = !access_ok(VERIFY_WRITE, tmp_nai_shrm_data.pbuf, tmp_nai_shrm_data.len);
+   }
+   else
+   {  //write operation
+      err = !access_ok(VERIFY_READ, tmp_nai_shrm_data.pbuf, tmp_nai_shrm_data.len);
+   }
+   if (err)
+   {
+      pr_err("user did not allocate space currectly\n");
+      err = -EFAULT;
+      goto exit;
+   }
+#ifdef DEBUG_MODULE
+   else
+   {
+      if(tmp_nai_shrm_data.len>1024)
+      {
+         pr_info("passed access_ok(%s,tmp_nai_shrm_data.pbuf,tmp_nai_shrm_data.len(%d))\n",rd==0?"VERIFY_READ":"VERIFY_WRITE",tmp_nai_shrm_data.len);
+      }
+   }
+#endif
+
+   /* Ensure we are starting at a valid location */
+   if ((tmp_nai_shrm_data.offset < 0) || (tmp_nai_shrm_data.offset > (s->shrm_size - 1)))
+   {
+      pr_err("invalid ofset\n");
+      err = -EFAULT;
+      goto exit;
+   }
+
+   /* Ensure not reading past end of the image */
+   if ((tmp_nai_shrm_data.offset + tmp_nai_shrm_data.len) > s->shrm_size)
+   {
+      oklen =  s->shrm_size - tmp_nai_shrm_data.offset;
+   }
+   else
+   {
+      oklen = tmp_nai_shrm_data.len;
+   }
+
+   if (rd)
+   {  /*read op*/
+      err = copy_to_user(tmp_nai_shrm_data.pbuf, s->shrm_base_addr+tmp_nai_shrm_data.offset, oklen);
+      if(err)
+      {
+         pr_err("failed copy_to_user length: %d \n",oklen);
+         oklen = 0;
+      }
+#ifdef DEBUG_MODULE
+      //too many log info in /var/log/messages
+      else
+      {
+         pr_info("read %d bytes from phy shrm offset 0x%0x, vir addr=%p\n",oklen,tmp_nai_shrm_data.offset,s->shrm_base_addr+tmp_nai_shrm_data.offset);
+         printk_hex_info(s->shrm_base_addr+tmp_nai_shrm_data.offset,oklen<64?oklen:16);//not necassary to dump all read info
+      }
+#endif
+   }
+   else
+   {  /*write op*/
+      /* on failure, set the len to 0 to return empty packet to the device */
+      err = copy_from_user(s->shrm_base_addr+tmp_nai_shrm_data.offset, tmp_nai_shrm_data.pbuf, oklen);   
+      if (err)
+      {
+         pr_err("failed copy_from_user: length %d \n",oklen);
+         oklen = 0;
+      }
+#ifdef DEBUG_MODULE
+      else
+      {
+         if(oklen>4)
+         {
+           pr_info("write %d bytes to phy shrm off 0x%0x, vir addr=%p\n",oklen,tmp_nai_shrm_data.offset,s->shrm_base_addr+tmp_nai_shrm_data.offset);
+           printk_hex_info(s->shrm_base_addr+tmp_nai_shrm_data.offset,oklen<64?oklen:16);//not necassary to dump all write info
+         }
+      }
+#endif
+   }
+exit:
+
+   return err;
+}
+/*TODO: 
+	 * This is a temporary hack to support download via
+	 * bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+	 * We have to create another PCI device driver 
+	 * for Gen5 device to handle normal I/O operation and 
+	 * download operation
+	 * 
+	 */
+static void nai_gen_shrm_interrupt(struct nai_state *s)
+{
+   if(s->shrm_bar_enabled == NAI_GEN5_SHRM_BAR_ENABLE){
+     writel(1, s->base_addr + NAI_GEN5_TRIG_IRQ_OFFSET);
+   }
+}
+
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+static void config_shrm_pcie_bar2(struct pci_dev *pcidev, struct nai_state *drvdata)
+{
+   struct nai_state *privdrv = drvdata;
+   u32 value = 0;
+
+   /*check if bar2 address exist*/
+   pci_read_config_dword(pcidev, PCI_BASE_ADDRESS_2, &value);
+   /*printk(KERN_INFO*/pr_info( "----------------------------------%s:probe vendor:%x device:%x bar2: %x\n",DEVICE_NAME,pcidev->vendor, pcidev->device,value);
+   if(value > 0)
+   {	
+      privdrv->shrm_base_addr = pci_ioremap_bar(pcidev,2);
+      if (!privdrv->shrm_base_addr)
+      { 
+         printk(KERN_ERR "%s:Cannot map share memory bar2 \n",DEVICE_NAME);
+      }
+      else
+      {
+         privdrv->shrm_bar_enabled = NAI_GEN5_SHRM_BAR_ENABLE;
+         privdrv->shrm_size = NAI_GEN5_SHRM_SIZE;
+      }
+   }
+
+   return;   
+}
+
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+static void config_shrm_cpcie_bar1(struct pci_dev *pcidev, struct nai_state *drvdata)
+{
+	struct nai_state *privdrv = drvdata;
+	u32 value = 0;
+
+	/*check if bar1 address exist*/
+	pci_read_config_dword(pcidev, PCI_BASE_ADDRESS_1, &value);
+	/*printk(KERN_INFO*/pr_info("%s:probe vendor:%x,device:%x,bar1 phy addr: %x\n",DEVICE_NAME,pcidev->vendor, pcidev->device,value);
+	if(value > 0)
+	{	
+		privdrv->shrm_base_addr = pci_ioremap_bar(pcidev, 1);
+		if (!privdrv->shrm_base_addr)
+		{ 
+			printk(KERN_ERR "%s:Cannot map share memory bar2 \n",DEVICE_NAME);
+		}
+		else
+		{
+			privdrv->shrm_bar_enabled = NAI_GEN5_SHRM_BAR_ENABLE;
+			privdrv->shrm_size = NAI_GEN5_SHRM_SIZE;
+		}
+	}
+	
+	return;  
+}
+
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+static void config_shrm_bar(struct pci_dev *pcidev, struct nai_state *drvdata)
+{
+	struct nai_state *privdrv = drvdata;
+	int count = 0;
+	
+	privdrv->shrm_bar_enabled = NAI_GEN5_SHRM_BAR_DISABLE;
+	privdrv->shrm_size = 0;
+	
+	for(count=0; count< sizeof(pcieDeviceIdArrayNai)/sizeof(unsigned short); count++)
+	{
+		if( pcieDeviceIdArrayNai[count] == privdrv->deviceId ){
+			config_shrm_pcie_bar2(pcidev,drvdata);
+			goto done;
+		}
+			
+	}
+	
+	for(count=0; count< sizeof(gen5cpciDeviceIdArrayNai)/sizeof(unsigned short); count++)
+	{
+		if( gen5cpciDeviceIdArrayNai[count]  == privdrv->deviceId ){
+			config_shrm_cpcie_bar1(pcidev, privdrv);
+			goto done;
+		}
+	
+	}
+
+done:	
+	return;
+	
+}
+
+#if (KERNEL_VERSION(2,6,22) > LINUX_VERSION_CODE)
+irqreturn_t nai_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+irqreturn_t nai_interrupt(int irq, void *dev_id)
+#endif
+{
+   struct nai_state *s = dev_id;
+   unsigned short IntType = 0;
+   unsigned int   Int32Type =0;
+   irqreturn_t irqStatus = IRQ_NONE;
+
+   if(s->revId < NAI_HWREV_GEN5)
+   {   
+	 IntType = nai_read16(s, NAI_LEGACY_IRQ_READ_OFFSET);
+	 if (IntType & 0x01) /* it's my interrupt */
+	 {
+		/* save IntStatus word */
+		s->irqValue = IntType;
+		/* clear interrupt, for backward compatible */
+		nai_write16(s, NAI_LEGACY_IRQ_WRITE_OFFSET, s->irqWriteValue );
+		s->irqUsrFlag = 1;
+		wake_up_interruptible(&nai_wq);
+		/* we did have a valid interrupt and handled it */
+		irqStatus = IRQ_HANDLED;
+	 }
+      
+   }
+   else   /*for HW Revision 2 and above*/
+   {
+         //read status register 
+         Int32Type = nai_read32(s, NAI_GEN5_IRQ_STATUS_OFFSET);
+        
+         if (Int32Type & 0x1)
+         {
+            //read vector register to clear IRQ
+            s->irqValue32 = nai_read32(s, NAI_GEN5_IRQ_READ_OFFSET);
+            s->irqUsrFlag = 1;
+            wake_up_interruptible(&nai_wq);
+            /* we did have a valid interrupt and handled it */
+            irqStatus = IRQ_HANDLED;
+         }
+   }
+   return(irqStatus);
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+static int __devinit nai_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
+#else
+static int nai_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
+#endif
+{
+   struct nai_state *s;
+   int res = -1;
+   int err = -1;
+#ifdef CONFIG_PCI_MSI
+   int devCnt = 0;
+#endif   
+   
+   pr_info("%s:probe vendor:%x device:%x\n",DEVICE_NAME,pcidev->vendor, pcidev->device);   
+   /*TODO: This temp workaround to ignore 68ARM1 PCIe RC Bridge port*/ 
+   if(pcidev->device == 0x6884){
+      printk(KERN_INFO "ignore pci device %X \n",pcidev->device);   
+      return res;
+   }
+
+   if ((res=pci_enable_device(pcidev))){
+      printk(KERN_ERR "%s:pci device was already enabled\n",DEVICE_NAME);
+      return res;
+   }
+	
+   res = pci_request_regions(pcidev, DEVICE_NAME);
+   if (res) {
+      printk(KERN_ERR "%s:Cannot obtain PCI resources, aborting.\n",DEVICE_NAME);
+      goto err_out_disable_pdev;
+   }
+	
+   pci_set_master(pcidev);
+
+   if (!(s = kmalloc(sizeof(struct nai_state), GFP_KERNEL))) {
+      res = -ENOMEM;
+      printk(KERN_ERR "%s:out of memory.\n",DEVICE_NAME);
+      goto err_out_disable_pdev;
+   }
+
+   memset(s, 0, sizeof(struct nai_state));
+   /* init_waitqueue_head(&s->open_wait); */
+#ifndef init_MUTEX
+   sema_init(&s->open_sem, 1);
+#else
+   init_MUTEX(&s->open_sem);
+#endif
+   spin_lock_init(&s->lock);
+
+   s->pdev = pcidev;
+   
+   s->irq = pcidev->irq;
+   s->vendorId = pcidev->vendor;
+   s->deviceId = pcidev->device;
+   s->device_index = g_device_count;
+   pci_read_config_byte(pcidev, PCI_REVISION_ID, &s->revId);
+
+   s->bus_number = pcidev->bus->number;
+   s->slot_number = pcidev->devfn >> 3;   /* right shift 3 bits */
+   s->fn_number = pcidev->devfn & 0x3;    /* take low 3 bits */
+	
+   s->irqWriteValue = 1; /*set legacy IRQ write ACK value to 1*/
+   s->irqUsrFlag = 0; /*default irq usr flag to 0*/
+   
+   if( (pcidev->revision & 0xf) >= HW_REV_BAR1 ){
+		s->base_addr= pci_ioremap_bar(pcidev, 1);
+	}else{
+		s->base_addr= pci_ioremap_bar(pcidev, 0);
+	}
+	
+	
+   if (!s->base_addr) {
+		printk(KERN_ERR "%s:Cannot map device registers, aborting.\n",DEVICE_NAME);
+		goto err_out_free_res;
+	}
+	
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+	config_shrm_bar(pcidev, s);
+   
+#ifdef CONFIG_PCI_MSI
+	if (pci_msi_enabled()){
+		for(devCnt=0; devCnt< sizeof(pcieDeviceIdArrayNai)/sizeof(unsigned short); devCnt++)
+		{
+			if( (pcieDeviceIdArrayNai[devCnt]  == s->deviceId) ){
+				err = pci_enable_msi(pcidev);
+				if (err){ 
+					printk(KERN_ERR "%s:Failed to enable MSI\n",DEVICE_NAME);
+					goto err_out_unmap_io;
+				}
+			break;
+			}
+		}
+	}
+#endif
+
+   if (request_irq(pcidev->irq, nai_interrupt,
+#if (KERNEL_VERSION(2,6,24) < LINUX_VERSION_CODE)
+       IRQF_SHARED
+#else
+       SA_SHIRQ
+#endif
+       , DEVICE_NAME, s) != 0) {
+      printk(KERN_ERR "%s: unable to request IRQ %d\n",DEVICE_NAME, pcidev->irq);
+      res = -EBUSY;
+      goto err_out_unmap_io;
+   }
+	  
+   if(s->device_index==0)
+   {
+      /* register this module as a character device driver.*/
+      printk(KERN_INFO "%s:registering character device \n",DEVICE_NAME);
+
+      err = register_chrdev (0, DEVICE_NAME, &fops);
+      if( err < 0 )
+      {
+         printk (KERN_ERR "%s:registering char device failed with err=%d\n",DEVICE_NAME,err);
+         goto err_out_free_irq;
+      }
+	
+	  Major = err;	/* In case the user specified `major=0' (dynamic) */
+	  nai_class = class_create(THIS_MODULE, DEVICE_NAME);
+	  if (IS_ERR(nai_class)) {
+		 err = PTR_ERR(nai_class);
+		 printk (KERN_ERR "%s:failed to created device class err=%d\n",DEVICE_NAME,err);
+		 goto out_chrdev;
+	  }
+  
+   }
+
+	device_create(nai_class, NULL, MKDEV(Major, s->device_index), NULL,
+			  "nai%u", s->device_index);
+
+   pci_set_drvdata(pcidev, s);
+   g_dev[g_device_count] = s;
+   g_device_count++;
+   
+   return 0;
+
+out_chrdev:
+	unregister_chrdev(Major, DEVICE_NAME);
+err_out_free_irq:
+#ifdef CONFIG_PCI_MSI
+if (pci_msi_enabled()){
+		for(devCnt=0; devCnt< sizeof(pcieDeviceIdArrayNai)/sizeof(unsigned short); devCnt++)
+		{
+			if(((pcidev->msi_enabled) && (pcieDeviceIdArrayNai[devCnt] == s->deviceId))){
+				pci_disable_msi( pcidev );
+				break;	
+			}
+		}
+	}
+#endif
+   free_irq(s->irq, (struct nai_state *) s);	
+err_out_unmap_io:
+	iounmap(s->base_addr);
+if(	s->shrm_bar_enabled == NAI_GEN5_SHRM_BAR_ENABLE )
+	iounmap(s->shrm_base_addr);
+err_out_free_res:	   
+	kfree(s);
+err_out_disable_pdev:
+   pci_disable_device(pcidev);
+   pci_set_drvdata(pcidev, NULL);
+   return res;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+static void __devinit nai_remove(struct pci_dev *dev)
+#else
+static void nai_remove(struct pci_dev *dev)
+#endif
+{
+#if (KERNEL_VERSION(2,6,24) >= LINUX_VERSION_CODE)
+   int ret = -1;
+#endif   
+   struct nai_state *s = pci_get_drvdata(dev);
+
+#ifdef CONFIG_PCI_MSI
+   int 	devCnt=0;
+#endif   
+   
+   printk(KERN_INFO "%s:remove vendor:%x device:%x\n",DEVICE_NAME,dev->vendor,dev->device);   
+   
+   if (!s){
+	printk (KERN_ERR"%s:pci dev was not initialized\n",DEVICE_NAME);
+	return;
+   } 
+
+
+   if(dev->irq){      
+      free_irq(dev->irq, s);
+#ifdef CONFIG_PCI_MSI
+if (pci_msi_enabled()){
+		for(devCnt=0; devCnt< sizeof(pcieDeviceIdArrayNai)/sizeof(unsigned short); devCnt++)
+		{
+			if(((dev->msi_enabled) && (pcieDeviceIdArrayNai[devCnt] == s->deviceId))){
+				printk (KERN_ERR"%s:disable MSI\n",DEVICE_NAME);
+				pci_disable_msi( dev );
+			break;	
+			}
+		}
+	}
+#endif
+   }
+   
+	device_destroy(nai_class, MKDEV(Major, s->device_index));
+
+    if ( g_device_count <= 1 ){
+	  printk (KERN_INFO"%s: class destory \n",DEVICE_NAME);
+	  class_destroy(nai_class);
+#if (KERNEL_VERSION(2,6,24) < LINUX_VERSION_CODE)
+      unregister_chrdev (Major, DEVICE_NAME);
+#else
+      ret = unregister_chrdev (Major, DEVICE_NAME);
+      if (ret < 0) {
+       printk (KERN_ERR"%s:error in unregister err=%d\n",DEVICE_NAME,ret);
+      }
+#endif
+    }
+	
+   if (s->base_addr) {
+      iounmap(s->base_addr);
+      s->base_addr = 0;
+   }
+   
+   if(s->shrm_base_addr)
+	  iounmap(s->shrm_base_addr);
+
+   /* release_mem_region(s->memstart, s->memend);*/
+   pci_release_regions(dev);
+   pci_disable_device(dev);
+
+   kfree(s);
+
+   pci_set_drvdata(dev, NULL);
+   //t.y new remove a device count
+   g_device_count--;	
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+static struct pci_device_id id_table[] __devinitdata = {
+#else
+static struct pci_device_id id_table[] = {
+#endif
+  { PCI_VENDOR_ID_NAI, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
+  { 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, id_table);
+
+static struct pci_driver nai_driver = {
+  .name     = DEVICE_NAME,
+  .id_table = id_table,
+  .probe    = nai_probe,
+  .remove   = nai_remove
+};
+
+static int __init nai_begin(void)
+{
+   /*printk (KERN_INFO*/pr_info("%s:North Atlantic Industries Linux Driver Version %s\n",DEVICE_NAME, DRIVER_VERSION);
+   return pci_register_driver(&nai_driver);
+}
+
+static void __exit nai_finish (void)
+{
+   pci_unregister_driver(&nai_driver);
+}
+
+module_init(nai_begin);
+module_exit(nai_finish);
+
+static int device_open(struct inode *ip, struct file *fp)
+{
+   int minor_number = iminor(ip);
+
+   fp->private_data = g_dev[minor_number];
+
+   try_module_get(THIS_MODULE);
+
+   g_dev[minor_number]->device_open = 1;
+#ifdef DEBUG_MODULE
+   pr_info("file name:\"%s\",minor:%d\n",fp->f_path.dentry->d_iname,iminor(fp->f_path.dentry->d_inode));
+#endif
+   return (0);
+}
+
+static int device_release(struct inode *ip, struct file *fp)
+{
+   int minor_number = iminor(ip);
+   module_put(THIS_MODULE);
+
+   /* printk ("<1>nai:close() called minor=%d\n", minor_number);*/
+   g_dev[minor_number]->device_open = 0;
+   return (0);
+}
+
+/*if failed, it returns -EFAULT*/
+static int get_pci_module_revision(NAI_MODULE_PCI_REVISION __user *arg) {
+	int ret = 0;
+	u8 major = NAI_DRV_PCI_VER_MAJOR;
+	u8 minor = NAI_DRV_PCI_VER_MINOR;
+	
+	if((ret == put_user(major, &arg->pciMajorRev)) == 0)
+    {
+      ret = put_user(minor, &arg->pciMinorRev);
+    }
+	return ret;
+}
+/*Get frame count.  
+If is pack, the frame count is in_count / MAX_DWORD_IN_BLK_FRAME *2 since each block transfer is 32 bit and when it is packed there are 2 data entries in each 32 bit block transfer.
+If is not pack, the frame count is in_count / MAX_DWORD_IN_BLK_FRAME since each block transfer is 32 bit.
+*/
+static u32 getBlockFrame(u32 inCount, u32 in_BlkCap)
+{
+   u32 frameCount=0;
+   frameCount = inCount / MAX_DWORD_IN_BLK_FRAME; 
+   if( in_BlkCap & PCK_CAPABLE)
+   {
+      frameCount = inCount / (MAX_DWORD_IN_BLK_FRAME * 2);
+   }
+   return(frameCount);   
+}
+
+/*Get frame count.  
+If is pack and if count is odd, it needs one to round up the count.
+If is pack and count is not odd, remaining count is mod in_count divided by 2.
+If is not pack, remaining count is mod in_count.
+*/
+static u32 getRemainingCounts(u32 inCount, u32 inBlkCap)
+{
+   u32 remainingCount=0;
+
+   if( inBlkCap & PCK_CAPABLE)
+   {
+	  remainingCount = (inCount % (MAX_DWORD_IN_BLK_FRAME *2)) / 2;
+	  if( (inCount % 2) == 1)  
+	  {  
+		remainingCount = (inCount % (MAX_DWORD_IN_BLK_FRAME *2)) / 2 + 1;   /*odd*/
+      }
+   }
+   else
+   {
+      remainingCount = (inCount % (MAX_DWORD_IN_BLK_FRAME ));
+   }
+   return(remainingCount);
+}
+
+/*configBlockCtrl()  
+Configure the block transfer control register.
+*/
+static void configBlockCtrl(struct nai_state *s, u32 inModuleNum,  u32 inBlkCap, u32 inStride,  u32 blkXferSize)
+{
+	u32 blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+	u32 blockCtrlStride =0;
+	
+	if(inBlkCap & PCK_CAPABLE)
+		blockCtrl |= NAI_GEN5_BLK_CTRL_PACK;
+	
+    if(blkXferSize == MAX_WORD_IN_BLK_FRAME)
+    {	
+		blockCtrl |= NAI_GEN5_BLK_CTRL_AUTO_REARM;  	/*turn on auto re-arm*/
+		blockCtrl |= MAX_WORD_IN_BLK_FRAME;             /*set max trasfer word size*/
+	}
+	else
+	{
+		blockCtrl |= blkXferSize *2 ;                   /*multiple by 2 since HW expects in words*/
+	}
+	/*stride*/
+	blockCtrlStride = inStride << 8; 		/*stride is defined at bit 15-8 of block ctrl reg*/
+   blockCtrl |= blockCtrlStride;               		/*set stride size (4bytes per stride)*/
+		
+	nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((inModuleNum-1)*REG_WIDTH_32BIT) , blockCtrl );
+}
+
+/*rw32Data()  
+Perform read or write operations from user to/from Hardware when the user data buffer is 32 bit.
+*/
+static u32 rw32Data(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount)
+{
+   int32_t status =0;
+   u32 ival =0;
+   u32 ival2 =0;
+   u32 temp =0;
+   
+	if(rwOp == READ_OP)
+	{
+		ival = nai_read32( s, inRegAddr + *byteCount * inStride);
+		if(inBlkCap & PCK_CAPABLE)
+		{
+         /*data is packed, the first item is at bit(0-15), the second item is at bit(16-31)
+         use 32 bit on a 16Bit user data buffer, so reduced the number of bus access by half*/
+         temp = ival & 0xffff;
+         status = copy_to_user( (dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 ), &temp, REG_WIDTH_32BIT );
+         
+         if(inCount/2 != *byteCount)
+         {
+            temp = ival & 0xffff0000;
+            temp >>= 16;
+            status = copy_to_user( (dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 + REG_WIDTH_32BIT ), &temp, REG_WIDTH_32BIT );
+         }
+		}
+		else
+		{
+			status = copy_to_user( (dataBufferAddr + *byteCount * REG_WIDTH_32BIT), &ival, REG_WIDTH_32BIT );
+		}
+	}
+	else  /*write op*/
+	{
+      if(inBlkCap & PCK_CAPABLE)
+		{
+			ival = (uint32_t)(*(u64*)(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 ));
+         if(*byteCount != inCount/2)   
+         {
+            ival2 = (uint32_t)(*(u64*)(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 + REG_WIDTH_32BIT ));
+         }
+         else
+         {
+            if(inCount % 2 == 0)
+            {
+               ival2 = (uint32_t)(*(u64*)(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 + REG_WIDTH_32BIT ));
+            }
+         }
+         nai_write32(s, inRegAddr + *byteCount * inStride,  ((ival2 & 0xffff) << 16) | (ival & 0xffff));
+		}
+		else
+		{
+		   ival = (uint32_t)(*(u64*)(dataBufferAddr + *byteCount * REG_WIDTH_32BIT));
+         nai_write32(s, inRegAddr + *byteCount * inStride, ival );
+		}
+	}
+	(*byteCount)++;
+	return(status);
+}
+/*rw16Data()  
+Perform read or write operations from user to/from Hardware when the user data buffer is 16 bit.
+*/
+static u32 rw16Data(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount)
+{
+   int32_t status = 0;
+	u32 ival =0;
+	
+	if(rwOp == READ_OP)
+	{
+		ival = nai_read32( s, inRegAddr + *byteCount * inStride );
+		if(inBlkCap & PCK_CAPABLE)
+		{
+			/*data is packed, the first item is at bit(0-15), the second item is at bit(16-31)
+			  use 32 bit on a 16Bit user data buffer, so reduced the number of bus access by half*/
+			
+			if(*byteCount == (inCount/2))
+			{
+				status = copy_to_user( (dataBufferAddr + *byteCount * REG_WIDTH_32BIT), &ival, REG_WIDTH_16BIT );
+			}
+			else
+			{
+				status = copy_to_user( (dataBufferAddr + *byteCount * REG_WIDTH_32BIT), &ival, REG_WIDTH_32BIT );
+			}
+		}
+		else
+		{
+			status = copy_to_user( (dataBufferAddr + *byteCount * REG_WIDTH_16BIT), &ival, REG_WIDTH_16BIT );
+		}
+	}
+	else  /*write op*/
+	{
+      if(inBlkCap & PCK_CAPABLE)
+		{
+			/*data is packed, the first item is at bit(0-15), the second item is at bit(16-31)
+			  use 32 bit on a 16Bit user data buffer, so reduced the number of bus access by half
+			*/
+         ival = (u32)(*((u64*)(dataBufferAddr + *byteCount * REG_WIDTH_32BIT)));  
+         if(*byteCount == (inCount/2))
+			{
+			   if( (inCount % 2) == 1)  /* odd */
+            {
+               ival = (uint16_t)(*((u64*)(dataBufferAddr + *byteCount * REG_WIDTH_32BIT)));
+            }
+         }
+		}
+		else
+		{
+		   ival = (uint16_t)(*((u64*)(dataBufferAddr + *byteCount * REG_WIDTH_16BIT)));  
+      }
+      nai_write32(s, inRegAddr + *byteCount * inStride, ival );
+	}
+	(*byteCount)++;
+	
+	return(status);
+}
+
+#ifdef CONFIG_COMPAT
+/*rw32DataCompact()  
+Perform read or write operations from user to/from Hardware when the user data buffer is 32 bit.
+*/
+static u32 rw32DataCompat(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount)
+{
+   int32_t status =0;
+   u32 ival =0;
+   u32 ival2 = 0;
+   u32 temp =0;
+   
+	if(rwOp == READ_OP)
+	{
+		ival = nai_read32( s, inRegAddr + *byteCount * inStride );
+		if(inBlkCap & PCK_CAPABLE)
+		{
+			/*data is packed, the first item is at bit(0-15), the second item is at bit(16-31)
+			  use 32 bit on a 16Bit user data buffer, so reduced the number of bus access by half*/
+         temp = ival & 0xffff;
+         status = copy_to_user( compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2), &temp, REG_WIDTH_32BIT );
+         if(inCount/2 != *byteCount)
+         {
+            temp = ival & 0xffff0000;
+            temp >>= 16;
+            status = copy_to_user( compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 + REG_WIDTH_32BIT), &temp, REG_WIDTH_32BIT );
+         }
+		}
+		else
+		{
+			status = copy_to_user( compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT), &ival, REG_WIDTH_32BIT );
+		}
+	}
+	else  /*write op*/
+	{
+      if(inBlkCap & PCK_CAPABLE)
+		{
+			ival = (uint32_t)(*(u64*)(compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 )));
+         if(*byteCount != inCount/2)   
+         {
+            ival2 = (uint32_t)(*(u64*)(compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 + REG_WIDTH_32BIT )));
+         }
+         else
+         {
+            if(inCount % 2 == 0)
+            {
+               ival2 = (uint32_t)(*(u64*)(compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT * 2 + REG_WIDTH_32BIT )));
+            }
+         }
+         nai_write32(s, inRegAddr + *byteCount * inStride,  ((ival2 & 0xffff) << 16) | (ival & 0xffff));
+		}
+		else
+		{
+		   ival = (uint32_t)(*(u64*)(compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT)));
+         nai_write32(s, inRegAddr + *byteCount * inStride, ival );
+		}
+	}
+	(*byteCount)++;
+	
+	return(status);
+}
+
+
+/*rw32DataCompact()  
+Perform read or write operations from user to/from Hardware when the user data buffer is 16 bit.
+*/
+static u32 rw16DataCompat(struct nai_state *s, u32 inRegAddr, u32 inStride, u32 inBlkCap, u32 inCount, void *dataBufferAddr, u32 rwOp, u32 *byteCount)
+{
+   int32_t status = 0;
+	u32 ival =0;
+	
+	if(rwOp == READ_OP)
+	{
+		ival = nai_read32( s, inRegAddr + *byteCount * inStride);
+		if(inBlkCap & PCK_CAPABLE)
+		{
+			/*data is packed, the first item is at bit(0-15), the second item is at bit(16-31)
+			  use 32 bit on a 16Bit user data buffer, so reduced the number of bus access by half*/
+			
+			if(*byteCount == (inCount/2))
+			{
+				status = copy_to_user( compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT), &ival, REG_WIDTH_16BIT );
+			}
+			else
+			{
+				status = copy_to_user( compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT), &ival, REG_WIDTH_32BIT );
+			}
+		}
+		else
+		{
+			status = copy_to_user( compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_16BIT), &ival, REG_WIDTH_16BIT );
+		}
+	}
+	else  /*write op*/
+	{
+      if(inBlkCap & PCK_CAPABLE)
+		{
+			/*data is packed, the first item is at bit(0-15), the second item is at bit(16-31)
+			  use 32 bit on a 16Bit user data buffer, so reduced the number of bus access by half
+			*/
+         ival = (u32)(*((u64*)(compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT))));  
+         if(*byteCount == (inCount/2))
+			{
+			   if( (inCount % 2) == 1)  /* odd */
+            {
+               ival = (uint16_t)(*((u64*)(compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_32BIT))));
+            }
+         }
+		}
+		else
+		{
+		   ival = (uint16_t)(*((u64*)(compat_ptr(dataBufferAddr + *byteCount * REG_WIDTH_16BIT))));  
+      }
+      nai_write32(s, inRegAddr + *byteCount * inStride, ival );
+	}
+	(*byteCount)++;
+	
+	return(status);
+}
+#endif
+
+#if (KERNEL_VERSION(2,6,36) <= LINUX_VERSION_CODE)
+static long device_ioctl(struct file *fp, unsigned int ioctl_num, unsigned long ioctl_param)
+#else
+static int device_ioctl(struct inode *ip, struct file *fp, unsigned int ioctl_num, unsigned long ioctl_param)
+#endif
+{
+   int status;
+   int ret = 0;
+   unsigned long flags;
+   NAI_CONFIG cfg;
+   NAI_INT_CONFIG ic;
+   NAI_WRITE_INPUT tmpIOBufferIn;
+   NAI_READ_OUTPUT tmpIOBufferOut;
+   NAI_INTERRUPT_DATA iData;
+   NAI_BLOCK_DATA blockData;
+   NAI_BLOCK_DATA_CAP blockDataCap;
+   
+   u32 ival = 0;
+   u32 x;
+   u32 ptrx=0;
+   u32 temp=0;
+   u32 blockFrames=0;
+   u32 remainingDataCounts=0;
+   u32 blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+   struct nai_state *s = fp->private_data;
+
+#ifdef DEBUG_MODULE
+   pr_info("ioctl_num=%x,IOCTL_NAI_READ_SHRM=%lx,IOCTL_NAI_WRITE_SHRM=%lx\n",ioctl_num,IOCTL_NAI_READ_SHRM,IOCTL_NAI_WRITE_SHRM);
+#endif
+
+   if (ioctl_num == IOCTL_NAI_READ_PORT_UCHAR)
+   {
+      status = copy_from_user( &tmpIOBufferOut, ((void*)ioctl_param), sizeof(tmpIOBufferOut) );
+      ival = nai_read8( s, tmpIOBufferOut.data.CharData );
+      tmpIOBufferOut.data.CharData = ival;
+      status = __copy_to_user( ((void*)ioctl_param), &tmpIOBufferOut, sizeof(tmpIOBufferOut) );
+      ret = status;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_WRITE_PORT_UCHAR)
+   {
+      status = copy_from_user( &tmpIOBufferIn, ((void*)ioctl_param), sizeof(tmpIOBufferIn) );
+      nai_write8(s, tmpIOBufferIn.PortNumber, tmpIOBufferIn.data.CharData );
+      ret = status;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_READ_PORT_USHORT)
+   {
+      status = copy_from_user( &tmpIOBufferOut, ((void*)ioctl_param), sizeof(tmpIOBufferOut) );
+      ival = nai_read16( s, tmpIOBufferOut.data.ShortData );
+      tmpIOBufferOut.data.ShortData = ival;
+      status = __copy_to_user( ((void*)ioctl_param), &tmpIOBufferOut, sizeof(tmpIOBufferOut) );
+      ret = status;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_WRITE_PORT_USHORT)
+   {
+      status = copy_from_user( &tmpIOBufferIn, ((void*)ioctl_param), sizeof(tmpIOBufferIn) );
+      nai_write16(s, tmpIOBufferIn.PortNumber, tmpIOBufferIn.data.ShortData );
+      ret = status;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_READ_PORT_32)
+   {
+      status = copy_from_user( &tmpIOBufferOut, ((void*)ioctl_param), sizeof(tmpIOBufferOut) );
+      ival = nai_read32(s,tmpIOBufferOut.data.LongData);
+      tmpIOBufferOut.data.LongData = ival;
+      status = __copy_to_user( ((void*)ioctl_param), &tmpIOBufferOut, sizeof(tmpIOBufferOut) );
+#ifdef DEBUG_MODULE
+      if(tmpIOBufferOut.data.LongData!=0)
+      { 
+         pr_info("ioctl_num=%x,IOCTL_NAI_READ_PORT_32=%lx,read:0x%08lx\n",ioctl_num,IOCTL_NAI_READ_PORT_32,tmpIOBufferOut.data.LongData);
+      }
+#endif
+     ret = status;
+   }
+   else 
+   if (ioctl_num == IOCTL_NAI_WRITE_PORT_32)
+   {
+      status = copy_from_user( &tmpIOBufferIn, ((void*)ioctl_param), sizeof(tmpIOBufferIn) );
+      nai_write32(s, tmpIOBufferIn.PortNumber, tmpIOBufferIn.data.LongData );
+      ret = status;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_READ_INFO) {
+      cfg.BusNum = s->bus_number;
+      cfg.PortCount = s->slot_number;   /* PortCount used as PCI Slot# */
+      cfg.bPCIDevice = s->device_index; /* bPCIDevice used as device index */
+      cfg.DeviceId = s->deviceId;
+      cfg.BaseAdr = (ULONG)s->base_addr;
+
+      status= __copy_to_user( ((void*)ioctl_param), &cfg, sizeof(cfg) );
+      ret = status;
+   }
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+    else
+    if (ioctl_num == IOCTL_NAI_READ_SHRM)
+    {
+       status = nai_shrm_access(s, (nai_shrm_data*)ioctl_param, 1);
+       ret = status;
+    } 
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+   else
+   if (ioctl_num == IOCTL_NAI_WRITE_SHRM)
+   {
+       status = nai_shrm_access(s, (nai_shrm_data*)ioctl_param, 0);
+       ret = status;
+   }
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+   else
+   if (ioctl_num == IOCTL_NAI_GEN_IRQ_SHRM)
+   {
+      nai_gen_shrm_interrupt(s);
+      ret = 0;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_INT_CONFIGURE) {
+      status= copy_from_user(&ic,((void*)ioctl_param),sizeof(ic));
+//IRQ Status and Vector address should NOT be configured from user application
+#if 0
+      s->irqReadAddr = ic.ReadAddr;
+      s->irqWriteAddr = ic.WriteAddr;
+#endif      
+      s->irqWriteValue = ic.WriteValue;
+      s->irqValue = 0;
+      ret = status;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_INT_DISABLE ) {
+      s->irqUsrFlag = 2;
+      wake_up_interruptible(&nai_wq);
+      ret = 0;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_INT_TRIGGER_ENABLE) {
+		local_irq_save(flags);
+		local_irq_disable();
+		local_irq_restore(flags);
+		local_irq_enable();		
+
+		wait_event_interruptible(nai_wq, s->irqUsrFlag != 0);
+		s->irqUsrFlag = 0;
+		if(s->revId < NAI_HWREV_GEN5)
+		{
+			iData.data.UshortData = (USHORT)s->irqValue;;
+		}
+		else
+		{
+		 	iData.data.UlongData = (ULONG)s->irqValue32;
+		}
+
+		status= copy_to_user(((void*)ioctl_param),&iData,sizeof(iData));
+
+		if (ival) {
+			s->irqValue = 0;
+			s->irqValue32 = 0;
+		}
+      ret = status;
+   }
+   else
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_READ) 
+   {
+      ptrx=0;
+      status= copy_from_user(&blockData,((void*)ioctl_param),sizeof(blockData));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockData.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+		  if(blockData.in_DataWidth == 2)  /*assume pack, newer design should use IOCTL_NAI_HW_BLOCK_READ_CAP*/
+        {
+            blockFrames = getBlockFrame(blockData.in_Count, PCK_CAPABLE);
+		      remainingDataCounts = getRemainingCounts(blockData.in_Count, PCK_CAPABLE);
+            if(blockFrames)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw16Data(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw16Data(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+         }
+         else  /*dataBuffer is 32bit*/
+         {
+            blockFrames = getBlockFrame(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+		      remainingDataCounts = getRemainingCounts(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+            if(blockFrames)
+            {
+               configBlockCtrl(s, blockData.in_Module, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw32Data(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/4, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw32Data(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+         }
+		blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+      nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockData.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );               
+	  }
+     ret = status;
+   }
+   else 
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_WRITE) 
+   {
+      ptrx=0;
+      status= copy_from_user(&blockData,((void*)ioctl_param),sizeof(blockData));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockData.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+		  if(blockData.in_DataWidth == 2)  /*assume pack, newer design should use IOCTL_NAI_HW_BLOCK_READ_CAP*/
+        {
+            blockFrames = getBlockFrame(blockData.in_Count, PCK_CAPABLE);
+		      remainingDataCounts = getRemainingCounts(blockData.in_Count, PCK_CAPABLE);
+            if(blockFrames)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw16Data(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw16Data(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+         }
+         else  /*dataBuffer is 32bit*/
+         {
+            blockFrames = getBlockFrame(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+		      remainingDataCounts = getRemainingCounts(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+            if(blockFrames)
+            {
+               configBlockCtrl(s, blockData.in_Module, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw32Data(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/4, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw32Data(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+         }
+		blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+      nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockData.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );               
+	  }
+     ret = status;
+   } 
+   else
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_READ_CAP)
+   {
+      ptrx=0;
+      status= copy_from_user(&blockDataCap,((void*)ioctl_param),sizeof(blockDataCap));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockDataCap.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+		   blockFrames = getBlockFrame(blockDataCap.in_Count, blockDataCap.in_Cap);
+         remainingDataCounts = getRemainingCounts(blockDataCap.in_Count, blockDataCap.in_Cap);
+         if(blockFrames)
+         {
+	         configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+            for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+            {
+				   if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+               {
+                  status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+	            }
+               else                         /* 32bit */
+               {
+                  status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+	            }
+	         }
+         }
+         if(remainingDataCounts)
+         {
+            if(blockDataCap.in_Cap & PCK_CAPABLE)
+		      {
+               temp = blockDataCap.in_Count - ptrx * 2;
+			      if((blockDataCap.in_Count % 2) == 0)  /*is even*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+				      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+						      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+						      status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+				      }
+			      }
+			      else /*odd*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts-1); 
+				      for(x=0; (x<remainingDataCounts-1) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+						      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+						      status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+				      }
+				      configBlockCtrl(s, blockDataCap.in_Module, (blockDataCap.in_Cap & (~PCK_CAPABLE)), blockDataCap.in_Stride/4, 1); 
+                  if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      ptrx *= 2;
+					      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, READ_OP, &ptrx);
+   			      }
+				      else                                /* 32bit */
+				      {
+					      ptrx *= 2;
+                     status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, READ_OP, &ptrx);
+				      }
+			      }
+            }
+            else
+            {
+               temp = blockDataCap.in_Count - ptrx;
+			      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+			      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+			      {
+				      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+				      }
+				      else                                /* 32bit */
+				      {
+					      status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+				      }
+			      }
+            }
+         }
+      blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+      nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockDataCap.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );
+      }
+      ret = status;
+   }
+   else 
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_WRITE_CAP)
+   {
+      ptrx=0;
+      status= copy_from_user(&blockDataCap,((void*)ioctl_param),sizeof(blockDataCap));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockDataCap.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+         blockFrames = getBlockFrame(blockDataCap.in_Count, blockDataCap.in_Cap);
+         remainingDataCounts = getRemainingCounts(blockDataCap.in_Count, blockDataCap.in_Cap);
+         if(blockFrames)
+         {
+            configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+            for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+            {
+               if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+               {
+                  status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+               }
+               else                         /* 32bit */
+               {
+                  status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+         }
+	      if(remainingDataCounts)
+	      {
+		      if(blockDataCap.in_Cap & PCK_CAPABLE)
+		      {
+			      temp = blockDataCap.in_Count - ptrx * 2;
+			      if((blockDataCap.in_Count % 2) == 0)  /*is even*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+				      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+						      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+						      status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+				      }
+			      }
+			      else /*odd*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts-1); 
+				      for(x=0; (x<remainingDataCounts-1) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+						      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+						      status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+				      }
+				      configBlockCtrl(s, blockDataCap.in_Module, (blockDataCap.in_Cap & (~PCK_CAPABLE)), blockDataCap.in_Stride/4, 1); 
+                  if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      ptrx *= 2;
+					      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+   			          }
+				      else                                /* 32bit */
+				      {
+					      ptrx *= 2;
+                     status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+				      }
+			      }
+		      }
+		      else /*non packed*/
+		      {
+			      temp = blockDataCap.in_Count - ptrx;
+			      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+			      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+			      {
+				      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      status = rw16Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+				      }
+				      else                                /* 32bit */
+				      {
+					      status = rw32Data(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+				      }
+			      }
+		      }
+         }
+      blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+      nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockDataCap.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );
+      }
+	  ret = status;
+   }
+   else 
+   if (ioctl_num == IOCTL_NAI_GET_PCI_MOD_REV) 
+   {
+      ret = get_pci_module_revision((NAI_MODULE_PCI_REVISION *)ioctl_param);
+   }
+   else
+   {
+      pr_err("not defined ioctl_num:0x%x\n",ioctl_num);
+      ret = -EFAULT;
+   }
+   return ret;
+}
+
+#ifdef CONFIG_COMPAT
+
+static int nai_shrm_compat_access(struct nai_state *s, unsigned long arg, u32 rd)
+{
+   int err = 0;
+   u32 oklen = 0;
+
+   nai_shrm_data local_nai_shrm_data;
+
+   err=copy_from_user(&local_nai_shrm_data,(void*)compat_ptr(arg),sizeof(nai_shrm_data));
+   if( err != 0 )
+   {
+       pr_err("copy_from_user(&local_nai_shrm_data,(void*)compat_ptr(arg),sizeof(nai_shrm_data))\n");
+       goto exit;
+   }
+
+   if(s->shrm_bar_enabled != NAI_GEN5_SHRM_BAR_ENABLE)
+   {
+      pr_err("device s->deviceId=0x%x not enabled\n",s->deviceId);
+      err = -EFAULT;
+      goto exit;
+   }
+
+   /* Ensure we are starting at a valid location */
+   if ((local_nai_shrm_data.offset < 0) || (local_nai_shrm_data.offset > (s->shrm_size - 1)))
+   {
+      pr_err("invalid ofset\n");
+      err = -EFAULT;
+      goto exit;
+   }
+
+   /* Ensure not reading past end of the image */
+   if ((local_nai_shrm_data.offset + local_nai_shrm_data.len) > s->shrm_size)
+   {
+      oklen =  s->shrm_size - local_nai_shrm_data.offset;
+      /*pr_info("local_nai_shrm_data.offset=%u,local_nai_shrm_data.len=%u,oklen=%u\n",local_nai_shrm_data.offset,local_nai_shrm_data.len,oklen);*/
+   }
+   else
+   {
+      oklen = local_nai_shrm_data.len;
+      /*pr_info("local_nai_shrm_data.offset=%u,local_nai_shrm_data.len=%u,oklen=%u\n",local_nai_shrm_data.offset,local_nai_shrm_data.len,oklen);*/
+   }
+
+   if (rd)
+   {  /*read op*/
+      err = copy_to_user((void*)((compat_ptr)(local_nai_shrm_data.pbuf)), s->shrm_base_addr+local_nai_shrm_data.offset, oklen);
+      if(err)
+      {
+         pr_err("failed copy_to_user length: %d \n",oklen);
+         oklen = 0;
+      }
+#ifdef DEBUG_MODULE
+ //too many log info in /var/log/messages
+      else
+      {
+         pr_info("read %d bytes from phy shrm offset 0x%0x, vir addr=%p\n",oklen,local_nai_shrm_data.offset,s->shrm_base_addr);
+         printk_hex_info(s->shrm_base_addr+local_nai_shrm_data.offset,oklen<64?oklen:(oklen-1)%64+1);//not necassary to dump all read info
+      }
+#endif
+   }
+   else
+   {  /*write op*/
+      err = copy_from_user(s->shrm_base_addr+local_nai_shrm_data.offset, (void*)((compat_ptr)(local_nai_shrm_data.pbuf)), oklen);   
+      if (err)
+      {
+         pr_err("failed copy_from_user: length %d \n",oklen);
+         oklen = 0;
+      }
+#ifdef DEBUG_MODULE
+      else
+      {
+         pr_info("write %d bytes to phy shrm offset 0x%0x, vir addr=%p\n",oklen,local_nai_shrm_data.offset,s->shrm_base_addr);
+         printk_hex_info(s->shrm_base_addr+local_nai_shrm_data.offset,oklen);
+      }
+#endif
+   }
+
+exit:
+   return err;
+}
+
+static long device_compat_ioctl(struct file *fp, unsigned int ioctl_num, unsigned long ioctl_param)
+{
+   int status;
+   int ret = 0;
+   unsigned long flags;
+   NAI_READ_OUTPUT rd;
+   NAI_WRITE_INPUT wr;
+   NAI_DEVICE_CONFIG cfg;
+   NAI_INT_CONFIG ic;
+   NAI_INTERRUPT_DATA iData;
+   NAI_BLOCK_DATA blockData;
+   u32 ival = 0;
+   u32 x;
+   u32 ptrx=0;
+   u32 temp=0;
+   u32 blockFrames=0;
+   u32 remainingDataCounts=0;
+   u32 blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+   u32 blockPackDataTwo;
+   struct nai_state *s = fp->private_data;
+   
+   if (ioctl_num == IOCTL_NAI_READ_PORT_UCHAR) {
+      status= copy_from_user(&rd,((void*)compat_ptr(ioctl_param)),sizeof(rd));
+      ival = nai_read8(s, rd.data.CharData );
+      rd.data.CharData = ival;
+      status= __copy_to_user(((void*)compat_ptr(ioctl_param)),&rd,sizeof(rd));
+   }
+
+   if (ioctl_num == IOCTL_NAI_WRITE_PORT_UCHAR) {
+      status= copy_from_user(&wr,((void*)compat_ptr(ioctl_param)),sizeof(wr));
+      nai_write8(s, wr.PortNumber, wr.data.CharData );
+   }
+   if (ioctl_num == IOCTL_NAI_READ_PORT_USHORT) {
+      status= copy_from_user(&rd,((void*)compat_ptr(ioctl_param)),sizeof(rd));
+      ival = nai_read16(s, rd.data.ShortData );
+      rd.data.ShortData = ival;
+      status= __copy_to_user(((void*)compat_ptr(ioctl_param)),&rd,sizeof(rd));
+   }
+   if (ioctl_num == IOCTL_NAI_WRITE_PORT_USHORT) {
+      status= copy_from_user(&wr,((void*)compat_ptr(ioctl_param)),sizeof(wr));
+      nai_write16(s, wr.PortNumber, wr.data.ShortData );
+   }
+   if (ioctl_num == IOCTL_NAI_READ_PORT_32) {
+      status= copy_from_user(&rd,((void*)compat_ptr(ioctl_param)),sizeof(rd));
+      ival = nai_read32(s, rd.data.LongData );
+      rd.data.LongData = ival;
+      status= __copy_to_user(((void*)compat_ptr(ioctl_param)),&rd,sizeof(rd));
+   }
+   if (ioctl_num == IOCTL_NAI_WRITE_PORT_32) {
+      status= copy_from_user(&wr,((void*)compat_ptr(ioctl_param)),sizeof(wr));
+      nai_write32(s, wr.PortNumber, wr.data.LongData );
+   }
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+   if (ioctl_num == IOCTL_NAI_READ_SHRM)
+   {
+      nai_shrm_compat_access(s, (nai_shrm_data*)compat_ptr(ioctl_param), 1);
+   }
+   
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+   if (ioctl_num == IOCTL_NAI_WRITE_SHRM)
+   {
+      nai_shrm_compat_access(s, (nai_shrm_data*)compat_ptr(ioctl_param), 0);
+   }
+   
+/*TODO: 
+* This is a temporary hack to support download via
+* bar1(cPCI dev)/bar2(PCIe dev) on Gen5 PCI card.
+* We have to create another PCI device driver 
+* for Gen5 device to handle normal I/O operation and 
+* download operation
+*/
+   if (ioctl_num == IOCTL_NAI_GEN_IRQ_SHRM)
+   {
+      nai_gen_shrm_interrupt(s);
+   }
+      
+   if (ioctl_num == IOCTL_NAI_READ_INFO)
+   {
+      cfg.BusNum = s->bus_number;
+      cfg.PortCount = s->slot_number;   /* PortCount used as PCI Slot# */
+      cfg.bPCIDevice = s->device_index; /* bPCIDevice used as device index */
+      cfg.DeviceId = s->deviceId;
+      status= __copy_to_user(((void*)compat_ptr(ioctl_param)),&cfg,sizeof(cfg));
+   }
+   
+   if (ioctl_num == IOCTL_NAI_GEN_IRQ_SHRM)
+      nai_gen_shrm_interrupt(s);
+   
+   if (ioctl_num == IOCTL_NAI_INT_CONFIGURE)
+   {
+      status= copy_from_user(&ic,((void*)compat_ptr(ioctl_param)),sizeof(ic));
+//IRQ Status and Vector address should NOT be configured from user application
+#if 0
+      s->irqReadAddr = ic.ReadAddr;
+      s->irqWriteAddr = ic.WriteAddr;
+#endif      
+      s->irqWriteValue = ic.WriteValue;
+      s->irqValue = 0;
+   }
+
+   if (ioctl_num == IOCTL_NAI_INT_TRIGGER_ENABLE)
+   {
+      local_irq_save(flags);
+      local_irq_disable();
+      local_irq_restore(flags);
+      local_irq_enable();
+
+      wait_event_interruptible(nai_wq, s->irqUsrFlag != 0);
+      s->irqUsrFlag = 0;
+      if(s->revId < NAI_HWREV_GEN5)
+      {
+         iData.data.UshortData = (USHORT)s->irqValue;
+      }
+      else
+      {   
+         iData.data.UlongData = (ULONG)s->irqValue32;
+      }
+
+      status = __copy_to_user(((void*)compat_ptr(ioctl_param)),&iData,sizeof(iData));
+ 
+      if (ival)
+      {
+         s->irqValue = 0;
+         s->irqValue32 = 0; 
+      }
+   }
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_READ) 
+   {
+      ptrx=0;
+      status= copy_from_user(&blockData,((void*)compat_ptr(ioctl_param)),sizeof(blockData));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockData.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+        if(blockData.in_DataWidth == 2)  /*assume pack, newer design should use IOCTL_NAI_HW_BLOCK_READ_CAP*/
+        {
+            blockFrames = getBlockFrame(blockData.in_Count, PCK_CAPABLE);
+            remainingDataCounts = getRemainingCounts(blockData.in_Count, PCK_CAPABLE);
+            if(blockFrames)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw16DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw16DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+        }
+        else  /*dataBuffer is 32bit*/
+        {
+           blockFrames = getBlockFrame(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+           remainingDataCounts = getRemainingCounts(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+           if(blockFrames)
+           {
+               configBlockCtrl(s, blockData.in_Module, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw32DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/4, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw32DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, READ_OP, &ptrx);
+               }
+            }
+         }
+         blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+         nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockData.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );               
+       }
+       ret = status;
+   }
+   
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_WRITE) 
+   {
+      ptrx=0;
+      status= copy_from_user(&blockData,((void*)compat_ptr(ioctl_param)),sizeof(blockData));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockData.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+         if(blockData.in_DataWidth == 2)  /*assume pack, newer design should use IOCTL_NAI_HW_BLOCK_READ_CAP*/
+         {
+            blockFrames = getBlockFrame(blockData.in_Count, PCK_CAPABLE);
+            remainingDataCounts = getRemainingCounts(blockData.in_Count, PCK_CAPABLE);
+            if(blockFrames)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw16DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/2, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw16DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, PCK_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+         }
+         else  /*dataBuffer is 32bit*/
+         {
+            blockFrames = getBlockFrame(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+            remainingDataCounts = getRemainingCounts(blockData.in_Count, BLK_CAPABLE | BLK_FIFO_CAPABLE);
+            if(blockFrames)
+            {
+               configBlockCtrl(s, blockData.in_Module, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+               for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+               {
+                  status = rw32DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+            if(remainingDataCounts)
+            {
+               configBlockCtrl(s, blockData.in_Module, PCK_CAPABLE, blockData.in_Stride/4, remainingDataCounts);
+               for(x=0; (x< remainingDataCounts) && (status == 0); x++)
+               { 			   
+                  status = rw32DataCompat(s, blockData.in_RegAddr, blockData.in_Stride, BLK_CAPABLE | BLK_FIFO_CAPABLE, blockData.in_Count, blockData.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+         }
+         blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+         nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockData.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );               
+     }
+     ret = status;
+   } 
+
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_READ_CAP)
+   {
+      ptrx=0;
+      status= copy_from_user(&blockDataCap,((void*)compat_ptr(ioctl_param)),sizeof(blockDataCap));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockDataCap.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+		   blockFrames = getBlockFrame(blockDataCap.in_Count, blockDataCap.in_Cap);
+         remainingDataCounts = getRemainingCounts(blockDataCap.in_Count, blockDataCap.in_Cap);
+         if(blockFrames)
+         {
+	         configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+            for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+            {
+				   if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+               {
+					status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+	            }
+               else                         /* 32bit */
+               {
+					status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+	            }
+	         }
+         }
+         if(remainingDataCounts)
+         {
+            if(blockDataCap.in_Cap & PCK_CAPABLE)
+		      {
+               temp = blockDataCap.in_Count - ptrx * 2;
+			      if((blockDataCap.in_Count % 2) == 0)  /*is even*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+				      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+					status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+					status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+				      }
+			      }
+			      else /*odd*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts-1); 
+				      for(x=0; (x<remainingDataCounts-1) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+						      status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+						      status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+					      }
+				      }
+				      configBlockCtrl(s, blockDataCap.in_Module, (blockDataCap.in_Cap & (~PCK_CAPABLE)), blockDataCap.in_Stride/4, 1); 
+                  if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      ptrx *= 2;
+					      status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, READ_OP, &ptrx);
+   			      }
+				      else                                /* 32bit */
+				      {
+					      ptrx *= 2;
+                     status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, READ_OP, &ptrx);
+				      }
+			      }
+            }
+            else
+            {
+               temp = blockDataCap.in_Count - ptrx;
+			      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+			      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+			      {
+				      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+				      }
+				      else                                /* 32bit */
+				      {
+					      status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, READ_OP, &ptrx);
+				      }
+			      }
+            }
+         }
+      blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+      nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockDataCap.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );
+      }
+      ret = status;
+   }
+   
+   if (ioctl_num == IOCTL_NAI_HW_BLOCK_WRITE_CAP)
+   {
+      ptrx=0;
+      status= copy_from_user(&blockDataCap,((void*)compat_ptr(ioctl_param)),sizeof(blockDataCap));
+      blockCtrl = NAI_GEN5_BLK_CTRL_NULL;
+      if(blockDataCap.in_RegWidth == REG_WIDTH_32BIT)  /* only supported for 32 bit access for now*/
+      {
+         blockFrames = getBlockFrame(blockDataCap.in_Count, blockDataCap.in_Cap);
+         remainingDataCounts = getRemainingCounts(blockDataCap.in_Count, blockDataCap.in_Cap);
+         if(blockFrames)
+         {
+            configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, MAX_WORD_IN_BLK_FRAME);
+            for(x=0; (x < blockFrames *  MAX_DWORD_IN_BLK_FRAME) && (status == 0); x++)
+            {
+               if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+               {
+                  status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+               }
+               else                         /* 32bit */
+               {
+                  status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+               }
+            }
+         }
+	      if(remainingDataCounts)
+	      {
+		      if(blockDataCap.in_Cap & PCK_CAPABLE)
+		      {
+			      temp = blockDataCap.in_Count - ptrx * 2;
+			      if((blockDataCap.in_Count % 2) == 0)  /*is even*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+				      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+						      status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+						      status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+				      }
+			      }
+			      else /*odd*/
+			      {
+				      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts-1); 
+				      for(x=0; (x<remainingDataCounts-1) && (status == 0); x++)
+				      {
+					      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+					      {
+						      status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+					      else                         /* 32bit */
+					      {
+						      status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+					      }
+				      }
+				      configBlockCtrl(s, blockDataCap.in_Module, (blockDataCap.in_Cap & (~PCK_CAPABLE)), blockDataCap.in_Stride/4, 1); 
+                  if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      ptrx *= 2;
+					      status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+   			          }
+				      else                                /* 32bit */
+				      {
+					      ptrx *= 2;
+                     status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap ^ PCK_CAPABLE, 1, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+				      }
+			      }
+		      }
+		      else /*non packed*/
+		      {
+			      temp = blockDataCap.in_Count - ptrx;
+			      configBlockCtrl(s, blockDataCap.in_Module, blockDataCap.in_Cap, blockDataCap.in_Stride/4, remainingDataCounts); 
+			      for(x=0; (x<remainingDataCounts) && (status == 0); x++)
+			      {
+				      if(blockDataCap.in_DataWidth == 2)  /* 16bit */
+				      {
+					      status = rw16DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+				      }
+				      else                                /* 32bit */
+				      {
+					      status = rw32DataCompat(s, blockDataCap.in_RegAddr, blockDataCap.in_Stride, blockDataCap.in_Cap, blockDataCap.in_Count, blockDataCap.dataBuffer, WRITE_OP, &ptrx);
+				      }
+			      }
+		      }
+         }
+		blockCtrl = NAI_GEN5_BLK_CTRL_HW_DEFAULT;
+		nai_write32(s, NAI_GEN5_BLK_XFER_OFFSET_ADD +  ((blockDataCap.in_Module-1)*REG_WIDTH_32BIT) , blockCtrl );
+      }
+      ret = status;
+   }
+   
+   if (ioctl_num == IOCTL_NAI_GET_PCI_MOD_REV) 
+      ret = get_pci_module_revision((NAI_MODULE_PCI_REVISION *)compat_ptr(ioctl_param));
+
+   return ret;
+}
+
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
diff --git a/drivers/misc/nai_KerModRev.h b/drivers/misc/nai_KerModRev.h
new file mode 100644
index 0000000..863f86d
--- /dev/null
+++ b/drivers/misc/nai_KerModRev.h
@@ -0,0 +1,26 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAI_KERMODREV_H__
+#define __NAI_KERMODREV_H__
+
+#define NAI_DRV_SERDES_VER_MAJOR       	(1)
+#define NAI_DRV_SERDES_VER_MINOR       	(1)
+#define NAI_DRV_PCI_VER_MAJOR       	   (2)
+#define NAI_DRV_PCI_VER_MINOR       	   (0)
+
+#endif
diff --git a/drivers/misc/nai_mb_fpga_top_cfg.c b/drivers/misc/nai_mb_fpga_top_cfg.c
new file mode 100644
index 0000000..1b4f2ca
--- /dev/null
+++ b/drivers/misc/nai_mb_fpga_top_cfg.c
@@ -0,0 +1,687 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <asm/device.h>
+#include <linux/semaphore.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/miscdevice.h>
+#include <linux/mod_devicetable.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+
+#include "nai_mb_fpga_top_cfg.h"
+								
+#define NAI_DRV_NAME_VER       			"NAI,mb-fpga-top-cfg-1.0"
+#define NAI_HPS_READY_OFFSET            0x04
+#define NAI_HPS_READY_ALL_READY         0x80000000
+
+#define NAI_RESET_DURATION_OFFSET       0x08
+
+#define NAI_RESETS_OFFSET               0x0C
+#define NAI_RESETS_MODULE_1             0x00000200
+
+#define NAI_MODULE_ADDR_OFFSET_1        0x00
+#define NAI_MODULE_ADDR_MASK            0x03FF
+#define NAI_MODULE_ADDR_START_SHIFT     18
+#define NAI_MODULE_ADDR_END_SHIFT       2
+#define NAI_MODULE_ADDR_OFFSET(m)       (NAI_MODULE_ADDR_OFFSET_1 + (m * 8))
+
+#define NAI_MODULE_MASK_OFFSET_1        0x04
+#define NAI_MODULE_MASK_MASK            0x00FFFFFF
+#define NAI_MODULE_MASK_OFFSET(m)       (NAI_MODULE_MASK_OFFSET_1 + (m * 8))
+
+#define NAI_ALL_MODULES_MASK_OFFSET     0x38 //module_addr baseaddr (0x0000_0030) + 0x38 = 0x0000_0068
+
+struct nai_common_dev {
+	struct miscdevice miscdev;
+	void __iomem      *revision_base;
+	void __iomem      *ps_ready_base;
+	void __iomem      *ps_reset_base;
+	void __iomem      *module_addr_config_base;
+	void __iomem      *mb_common_base;
+	u32               mb_common_size;
+	
+	struct semaphore  sem;
+};
+
+static int nai_common_open(struct inode *inode, struct file *filp) {
+	/* Open must be implemented to force the miscdevice open
+	 * function to store dev pointer in the file private data.
+	 */
+	return 0;
+}
+
+static int nai_common_release(struct inode *inode, struct file *filp) {
+	return 0;
+}
+
+static long get_params(struct nai_common_dev *dev, u32 mode,
+		       void __iomem **base_addr, u32 *size) {
+	long ret = 0;
+
+	switch (mode) {
+	case NAI_COMMON_MODE_COMMON:
+		*base_addr = dev->mb_common_base;
+		*size = dev->mb_common_size;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+
+	return ret;
+}
+
+static long _rdwr_reg(nai_common_reg __user *arg, u32 rd,
+		      void __iomem *base_addr, u32 size) {
+	long ret = 0;
+	u32 offset;
+	u32 type;
+	u32 end;
+
+	(void)get_user(offset, &arg->offset);
+	(void)get_user(type, &arg->type);
+
+        switch(type) {
+	case NAI_COMMON_TYPE_8_BIT:
+		end = size - sizeof(u8);
+		if (offset <= end) {
+			u8 val;
+
+			if (rd) {
+				val = ioread8(base_addr + offset);
+				(void)put_user(val, &arg->val8);
+			}
+			else {
+				(void)get_user(val, &arg->val8);
+				iowrite8(val, base_addr + offset);
+			}
+		}
+		else
+			ret = -EINVAL;
+		break;
+
+	case NAI_COMMON_TYPE_16_BIT:
+		end = size - sizeof(u16);
+		if (!(offset & 0x01) && (offset <= end)) {
+			u16 val;
+
+			if (rd) {
+				val = ioread16(base_addr + offset);
+				(void)put_user(val, &arg->val16);
+			}
+			else {
+				(void)get_user(val, &arg->val16);
+				iowrite16(val, base_addr + offset);
+			}
+		}
+		else
+			ret = -EINVAL;
+		break;
+
+	case NAI_COMMON_TYPE_32_BIT:
+		end = size - sizeof(u32);
+		if (!(offset & 0x03) && (offset <= end)) {
+			u32 val;
+
+			if (rd) {
+				val = ioread32(base_addr + offset);
+				(void)put_user(val, &arg->val32);
+			}
+			else {
+				(void)get_user(val, &arg->val32);
+				iowrite32(val, base_addr + offset);
+			}
+		}
+		else
+			ret = -EINVAL;
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static long rdwr_reg(struct nai_common_dev *dev,
+		     nai_common_reg __user *arg, u32 rd) {
+	long ret = 0;
+	u32 mode;
+	void __iomem *base_addr;
+	u32 size;
+
+	(void)get_user(mode, &arg->mode);
+
+	ret = get_params(dev, mode, &base_addr, &size);
+
+	if (likely(!ret))
+		ret = _rdwr_reg(arg, rd, base_addr, size);
+
+	return ret;
+}
+
+static long _rdwr_blk(nai_common_blk __user *arg, u32 rd,
+		      void __iomem *base_addr, u32 size) {
+	long ret = 0;
+	u32 offset;
+	u32 type;
+	u32 count;
+	u32 status;
+	void __user *user_val = NULL;
+	void *val = NULL;
+	u32 len;
+	u32 i;
+
+	(void)get_user(offset, &arg->offset);
+	(void)get_user(type, &arg->type);
+	(void)get_user(count, &arg->count);
+	(void)get_user(user_val, &arg->val);
+
+	switch (type) {
+	case NAI_COMMON_TYPE_8_BIT:
+		len = count * sizeof(u8);
+		break;
+
+	case NAI_COMMON_TYPE_16_BIT:
+		len = count * sizeof(u16);
+		if (offset & 0x01)
+			ret = -EINVAL;
+		break;
+
+	case NAI_COMMON_TYPE_32_BIT:
+		len = count * sizeof(u32);
+		if (offset & 0x03)
+			ret = -EINVAL;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	if ((offset + len) > size) {
+		ret = -EINVAL;
+	}
+
+	if (unlikely(ret))
+		goto exit;
+
+	ret = !access_ok(VERIFY_WRITE, user_val, len);
+	if (unlikely(ret)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	val = kmalloc(len, GFP_KERNEL);
+	if (unlikely(!val)) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if (!rd)
+		status = copy_from_user(val, user_val, len);
+
+        switch(type ) {
+	case NAI_COMMON_TYPE_8_BIT:
+		if (rd)
+			for (i = 0; i < len; ++i)
+				*(u8 *)(val + i) =
+					ioread8(base_addr + offset + i);
+		else
+			for (i = 0; i < len; ++i)
+				iowrite8(*(u8 *)(val + i),
+					 base_addr + offset + i);
+		break;
+
+	case NAI_COMMON_TYPE_16_BIT:
+		if (rd)
+			for (i = 0; i < len; i += 2)
+				*(u16 *)(val + i) =
+					ioread16(base_addr + offset + i);
+		else
+			for (i = 0; i < len; i += 2)
+				iowrite16(*(u16 *)(val + i),
+					  base_addr + offset + i);
+		break;
+
+	case NAI_COMMON_TYPE_32_BIT:
+		if (rd)
+			for (i = 0; i < len; i += 4)
+				*(u32 *)(val + i) =
+					ioread32(base_addr + offset + i);
+		else
+			for (i = 0; i < len; i += 4)
+				iowrite32(*(u32 *)(val + i),
+					  base_addr + offset + i);
+
+	default: /* Will never happen */
+		break;
+	}
+
+	if (rd)
+		status = copy_to_user(user_val, val, len);
+
+	kfree(val);
+exit:
+	return ret;
+}
+
+static long rdwr_blk(struct nai_common_dev *dev,
+		     nai_common_blk __user *arg, u32 rd) {
+	long ret = 0;
+	u32 mode;
+	void __iomem *base_addr;
+	u32 size;
+
+	(void)get_user(mode, &arg->mode);
+
+	ret = get_params(dev, mode, &base_addr, &size);
+
+	if (likely(!ret))
+		ret = _rdwr_blk(arg, rd, base_addr, size);
+
+	return ret;
+}
+
+static long get_fw_revs(struct nai_common_dev *dev,
+			nai_firmware_revs __user *arg) {
+	long ret = 0;
+	int i;
+	u32 val;
+
+	for (i = 0; i < NAI_COMMON_NUM_FW_REVS; ++i) {
+		val = ioread32(dev->revision_base + (i * sizeof(u32)));
+		(void)put_user(val, &arg->revisions[i]);
+	}
+
+	return ret;
+}
+
+static long rdwr_hps_ready(struct nai_common_dev *dev,
+			   u32 __user *arg, u32 rd) {
+	long ret = 0;
+	u32 val;
+	u32 reg;
+
+	if (rd) {
+		reg = ioread32(dev->ps_ready_base);
+		val = (reg & NAI_HPS_READY_ALL_READY) ? 1 : 0;
+
+		(void)put_user(val, arg);
+	}
+	else {
+		(void)get_user(val, arg);
+
+		ret = down_interruptible(&dev->sem);
+		if (unlikely(ret)) {
+			ret = -ERESTARTSYS;
+			goto exit;
+		}
+
+		val = val ? NAI_HPS_READY_ALL_READY : 0;
+		reg = ioread32(dev->ps_ready_base);
+		reg &= ~NAI_HPS_READY_ALL_READY;
+		reg |= val;
+
+		iowrite32(val, dev->ps_ready_base);
+
+		up(&dev->sem);
+	}
+exit:
+	return ret;
+}
+
+long rdwr_module_addr(struct nai_common_dev *dev,
+		      nai_module_addr __user *arg, u32 rd) {
+	long ret = 0;
+	u32 module_id;
+	u16 start;
+	u16 end;
+	u32 mask;
+	u32 addr;
+
+	(void)get_user(module_id, &arg->module_id);
+
+	if (module_id > NAI_COMMON_MODULE_7 || module_id < 0) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (rd) {
+		addr = ioread32(dev->module_addr_config_base +
+				NAI_MODULE_ADDR_OFFSET(module_id));
+		start = (addr >> NAI_MODULE_ADDR_START_SHIFT) &
+			NAI_MODULE_ADDR_MASK;
+		end = (addr >> NAI_MODULE_ADDR_END_SHIFT) &
+			NAI_MODULE_ADDR_MASK;
+		mask = ioread32(dev->module_addr_config_base +
+				NAI_MODULE_MASK_OFFSET(module_id));
+
+		(void)put_user(start, &arg->start);
+		(void)put_user(end, &arg->end);
+		(void)put_user(mask, &arg->mask);
+	}
+	else {
+		(void)get_user(start, &arg->start);
+		(void)get_user(end, &arg->end);
+		(void)get_user(mask, &arg->mask);
+/* NAI: Remove the error checking for the input values from userspace
+ * 0 is a valid value for start , end  and mask
+ */
+#if 0
+		if (!(start & ~NAI_MODULE_ADDR_MASK) ||
+		    !(end   & ~NAI_MODULE_ADDR_MASK) ||
+		    !(mask  & ~NAI_MODULE_MASK_MASK)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+#endif		
+		/* TODO does end need to be or'ed with 0x03? */
+		addr = (start << NAI_MODULE_ADDR_START_SHIFT) |
+		       (end  << NAI_MODULE_ADDR_END_SHIFT) |
+			0x03;
+		iowrite32(addr, dev->module_addr_config_base +
+			  NAI_MODULE_ADDR_OFFSET(module_id));
+		iowrite32(mask, dev->module_addr_config_base +
+			  NAI_MODULE_MASK_OFFSET(module_id));
+	}
+exit:
+	return ret;
+}
+
+static long rdwr_all_modules_mask(struct nai_common_dev *dev,
+				  u32 __user *arg, u32 rd) {
+	long ret = 0;
+	u32 val;
+
+	if (rd) {
+		val = ioread32(dev->module_addr_config_base +
+			       NAI_ALL_MODULES_MASK_OFFSET);
+		(void)put_user(val, arg);
+	}
+	else {
+		(void)get_user(val, arg);
+		if (!(val & ~NAI_MODULE_MASK_MASK))
+			iowrite32(val, dev->module_addr_config_base +
+				  NAI_ALL_MODULES_MASK_OFFSET);
+		else
+			ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static long nai_common_ioctl(struct file *filp, unsigned int cmd,
+			     unsigned long arg) {
+	struct nai_common_dev *dev;
+	long ret = 0;
+	u32 rd = 0;
+
+	dev = container_of(filp->private_data, struct nai_common_dev, miscdev);
+
+	if (_IOC_TYPE(cmd) != NAI_COMMON_MAGIC) {
+		ret = -ENOTTY;
+		goto exit;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg,
+				 _IOC_SIZE(cmd));
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg,
+				 _IOC_SIZE(cmd));
+	if (ret) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	switch (cmd) {
+	case NAI_IOC_COMMON_RD_REG:
+		rd = 1; /* Intentional dropthrough */
+	case NAI_IOC_COMMON_WR_REG:
+		ret = rdwr_reg(dev, (nai_common_reg __user *)arg, rd);
+		break;
+
+	case NAI_IOC_COMMON_RD_BLK:
+		rd = 1; /* Intentional dropthrough */
+	case NAI_IOC_COMMON_WR_BLK:
+		ret = rdwr_blk(dev, (nai_common_blk __user *)arg, rd);
+		break;
+
+	case NAI_IOC_COMMON_GET_FW_REVS:
+	        ret = get_fw_revs(dev, (nai_firmware_revs __user *)arg);
+		break;
+
+	case NAI_IOC_COMMON_GET_HPS_READY:
+		rd = 1; /* Intentional dropthrough */
+	case NAI_IOC_COMMON_SET_HPS_READY:
+		ret = rdwr_hps_ready(dev, (u32 __user *)arg, rd);
+		break;
+
+	case NAI_IOC_COMMON_GET_MODULE_ADDR:
+		rd = 1; /* Intentional dropthrough */
+	case NAI_IOC_COMMON_SET_MODULE_ADDR:
+		rdwr_module_addr(dev, (nai_module_addr __user *)arg, rd);
+		break;
+	case NAI_IOC_COMMON_GET_ALL_MODULES_MASK:
+		rd = 1; /* Intentioanl dropthrough */
+	case NAI_IOC_COMMON_SET_ALL_MODULES_MASK:
+		rdwr_all_modules_mask(dev, (u32 __user *)arg, rd);
+		break;
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+exit:
+	return ret;
+}
+
+static const struct file_operations nai_common_fops = {
+	.open           = nai_common_open,
+	.release        = nai_common_release,
+	.unlocked_ioctl = nai_common_ioctl,
+	.compat_ioctl   = nai_common_ioctl,
+};
+
+static const struct of_device_id of_nai_mb_fgpa_top_cfg_match[] = {
+	{ .compatible = NAI_DRV_NAME_VER, },
+	{},
+};
+
+static int nai_common_probe(struct platform_device *pdev) {
+	int ret = 0;
+	struct nai_common_dev *dev = NULL;
+	struct resource res;
+	struct device_node *pNode, *cNode;
+	
+	dev_info(&pdev->dev, "\n");
+	
+	/* Allocate and initialize device */
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+	memset(dev, 0, sizeof(*dev));
+
+	sema_init(&dev->sem, 1);
+
+	/* Initialize and register miscdevice */
+	dev->miscdev.name = NAI_MISC_DEV_NAME;
+	dev->miscdev.minor = MISC_DYNAMIC_MINOR;
+	dev->miscdev.fops = &nai_common_fops;
+	ret = misc_register((struct miscdevice *)dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to allocate misc device\n");
+		goto err_misc;
+	}
+
+	//get the parent node of the compatible device
+	pNode = of_find_compatible_node(NULL, NULL, NAI_DRV_NAME_VER);
+	if(!pNode) {
+		dev_err(&pdev->dev, "Unable to find compatible %s in DTB \n", NAI_DRV_NAME_VER);
+		goto err_find_comp_node;
+	}
+	
+	cNode = of_get_child_by_name(pNode, "top-rev");
+	if(cNode != NULL) {
+		
+		dev->revision_base = of_iomap(cNode,0);
+		if (!dev->revision_base) {
+			dev_err(&pdev->dev, "Failed to map revision registers\n");
+			ret = -ENOMEM;
+			goto err_top_rev_res;
+		}
+		//dev_info(&pdev->dev, "rev %p \n", dev->revision_base);
+		
+	} else {
+		goto err_top_rev_res;
+	}
+	
+	/* Map ps ready config memory */
+	cNode = of_get_child_by_name(pNode, "ps-ready");
+	if(cNode != NULL) {
+		
+		dev->ps_ready_base = of_iomap(cNode,0);
+		if (!dev->ps_ready_base) {
+			dev_err(&pdev->dev, "Failed to map ps-ready registers\n");
+			ret = -ENOMEM;
+			goto err_ps_ready_res;
+		}
+		//dev_info(&pdev->dev, "ready %p \n", dev->ps_ready_base);
+	} else {
+		goto err_ps_ready_res;
+	}
+	
+	/* Map ps reset config memory */
+	cNode = of_get_child_by_name(pNode, "ps-reset");
+	if(cNode != NULL) {
+		
+		dev->ps_reset_base = of_iomap(cNode,0);
+		if (!dev->ps_reset_base) {
+			dev_err(&pdev->dev, "Failed to map ps-reset registers\n");
+			ret = -ENOMEM;
+			goto err_ps_reset_res;
+		}
+		//dev_info(&pdev->dev, "reset %p \n", dev->ps_reset_base);
+	} else {
+		goto err_ps_reset_res;
+	}	
+	
+	/* Map Module Address config memory */
+	cNode = of_get_child_by_name(pNode, "module-addr-config");
+	if(cNode != NULL) {
+		
+		dev->module_addr_config_base = of_iomap(cNode,0);
+		if (!dev->module_addr_config_base) {
+			dev_err(&pdev->dev, "Failed to map module-addr-config registers\n");
+			ret = -ENOMEM;
+			goto err_module_addr_config_res;
+		}
+		//dev_info(&pdev->dev, "module addr %p \n", dev->module_addr_config_base);
+	} else {
+		goto err_module_addr_config_res;
+	}
+
+	/* Map Motherboard common area memory */
+	cNode = of_get_child_by_name(pNode, "mb-common");
+	if(cNode != NULL) {
+		
+	
+		dev->mb_common_base = of_iomap(cNode,0);
+		of_address_to_resource(cNode, 0, &res);
+		dev->mb_common_size = resource_size(&res);
+		if (!dev->mb_common_base) {
+			dev_err(&pdev->dev, "Failed to map mb-common registers\n");
+			ret = -ENOMEM;
+			goto err_mb_common_res;
+		}
+		//dev_info(&pdev->dev, "mb_common_base %p \n", dev->mb_common_base);
+		//dev_info(&pdev->dev, "mb_common size %d \n", dev->mb_common_size);
+	} else {
+		goto err_mb_common_res;
+	}
+					
+	/* Save misc device in platform dev */
+	platform_set_drvdata(pdev, dev);
+
+	return 0;
+	
+err_mb_common_res:
+	iounmap(dev->module_addr_config_base);
+err_module_addr_config_res:
+	iounmap(dev->ps_reset_base);
+err_ps_reset_res:
+	iounmap(dev->ps_ready_base);
+err_ps_ready_res:
+	iounmap(dev->revision_base);
+err_top_rev_res:
+err_find_comp_node:
+	misc_deregister((struct miscdevice *)dev);
+err_misc:
+	kfree(dev);
+exit:
+	return ret;
+}
+
+static int nai_common_remove(struct platform_device *pdev) {
+	struct nai_serdes_dev *dev = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	misc_deregister((struct miscdevice *)dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static struct platform_driver nai_common_drv = {
+	.driver   = {
+		.name  = NAI_DRV_NAME_VER,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(of_nai_mb_fgpa_top_cfg_match)
+	},
+	.probe    = nai_common_probe,
+	.remove   = nai_common_remove,
+};
+
+static int __init nai_common_init(void) {
+	return platform_driver_register(&nai_common_drv);
+}
+
+
+static void __exit nai_common_exit(void) {
+	platform_driver_unregister(&nai_common_drv);
+}
+
+module_init(nai_common_init);
+module_exit(nai_common_exit);
+
+MODULE_AUTHOR("Obi Okafor <ookafor@naii.com>");
+MODULE_DESCRIPTION("NAI Common driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/nai_mb_fpga_top_cfg.h b/drivers/misc/nai_mb_fpga_top_cfg.h
new file mode 100644
index 0000000..0ee0139
--- /dev/null
+++ b/drivers/misc/nai_mb_fpga_top_cfg.h
@@ -0,0 +1,97 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAI_MB_FPGA_TOP_CFG_
+#define __NAI_MB_FPGA_TOP_CFG_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NAI_MISC_DEV_NAME	            "nai_mb_fgpa_cfg"
+#define NAI_COMMON_TYPE_8_BIT       0x01
+#define NAI_COMMON_TYPE_16_BIT      0x02
+#define NAI_COMMON_TYPE_32_BIT      0x04
+
+#define NAI_COMMON_MODE_COMMON      0x01
+#define NAI_COMMON_MODE_HANDSHAKE   0x02
+
+#define NAI_COMMON_NUM_FW_REVS      9
+
+#define NAI_COMMON_MODULE_1         0
+#define NAI_COMMON_MODULE_2         1
+#define NAI_COMMON_MODULE_3         2
+#define NAI_COMMON_MODULE_4         3
+#define NAI_COMMON_MODULE_5         4
+#define NAI_COMMON_MODULE_6         5
+#define NAI_COMMON_MODULE_7         6
+
+typedef struct _nai_common_reg {
+	__u32 offset;
+	__u32 type;
+	__u32 mode;
+	union {
+		__u32 val32;
+		__u16 val16;
+		__u8  val8;
+	};
+} nai_common_reg;
+
+typedef struct _nai_common_blk {
+	__u32 offset;
+	__u32 type;
+	__u32 count;
+	__u32 mode;
+	void *val;
+} nai_common_blk;
+
+typedef struct _nai_firmware_revs {
+	__u32 revisions[NAI_COMMON_NUM_FW_REVS];
+} nai_firmware_revs;
+
+typedef struct _nai_module_addr {
+	__u32 module_id;
+	__u16 start;
+	__u16 end;
+	__u32 mask;
+} nai_module_addr;
+
+
+
+#define NAI_COMMON_MAGIC            0xDE
+
+#define NAI_IOC_COMMON_RD_REG               _IOWR(NAI_COMMON_MAGIC,  1, nai_common_reg)
+#define NAI_IOC_COMMON_WR_REG               _IOWR(NAI_COMMON_MAGIC,  2, nai_common_reg)
+#define NAI_IOC_COMMON_RD_BLK               _IOWR(NAI_COMMON_MAGIC,  3, nai_common_blk)
+#define NAI_IOC_COMMON_WR_BLK               _IOWR(NAI_COMMON_MAGIC,  4, nai_common_blk)
+#define NAI_IOC_COMMON_GET_FW_REVS          _IOR (NAI_COMMON_MAGIC,  5, nai_firmware_revs)
+#define NAI_IOC_COMMON_GET_HPS_READY        _IOR (NAI_COMMON_MAGIC,  6, __u32)
+#define NAI_IOC_COMMON_SET_HPS_READY        _IOW (NAI_COMMON_MAGIC,  7, __u32)
+#define NAI_IOC_COMMON_GET_MODULE_ADDR      _IOWR(NAI_COMMON_MAGIC,  8, nai_module_addr)
+#define NAI_IOC_COMMON_SET_MODULE_ADDR      _IOWR(NAI_COMMON_MAGIC,  9, nai_module_addr)
+#define NAI_IOC_COMMON_GET_ALL_MODULES_MASK _IOR (NAI_COMMON_MAGIC, 10, __u32)
+#define NAI_IOC_COMMON_SET_ALL_MODULES_MASK _IOW (NAI_COMMON_MAGIC, 11, __u32)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __NAI_MB_FPGA_TOP_CFG_ */
diff --git a/drivers/misc/nai_serdes.c b/drivers/misc/nai_serdes.c
new file mode 100644
index 0000000..c401fbb
--- /dev/null
+++ b/drivers/misc/nai_serdes.c
@@ -0,0 +1,1675 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <linux/string.h>
+#define pr_fmt(fmt) "%s:%s:%d::" fmt, strrchr(__FILE__,'/'), __func__, __LINE__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/rwsem.h>
+#include <asm/device.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/miscdevice.h>
+#include <linux/mod_devicetable.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+#include <linux/of_address.h>
+
+#include "nai_serdes_prv.h"
+#include "nai_serdes_utils.h"
+#include "nai_serdes_oper.h"
+#include "nai_serdes_config.h"
+#include "nai_serdes.h"
+#include "nai_KerModRev.h"
+
+//#define DEBUG_IT
+
+#define NAI_MISC_DEV_NAME	            "nai_serdes"
+#define NAI_DRV_NAME_VER                    "NAI,mb-serdes-1.0"
+
+#define NAI_MODULE_TX_FIFO_EMPTY_OFFSET     0x0040
+#define NAI_MODULE_RX_FIFO_EMPTY_OFFSET     0x00C0
+
+
+#define NAI_MODULE_DETECTED_OFFSET      	0x0100
+#define NAI_MODULE_DETECTED_DONE_SHIFT  	8
+
+#define NAI_MODULE_LINK_INIT_OFFSET     	0x0104
+#define NAI_MODULE_RESET_OFFSET         	0x0108
+#define NAI_MODULE_POWER_OFFSET        		0x010C
+#define NAI_MODULE_CLK_OFFSET        		0x0114
+#define NAI_MODULE_HSS_OFFSET        		0x011C
+#define NAI_MODULE_DLL_OFFSET        		0x0120
+#define NAI_MODULE_CONFIG_MODE_OFFSET       0x0124
+
+//Module common module mode ready state offset
+#define NAI_MODULE_COMMON_READY_OFFSET      				0x0000025C
+
+//Module Configuration Mode States
+#define NAI_MODULE_COMMON_CONFIGSTATE_REQUEST_ACK_BIT       0x00000001
+#define NAI_MODULE_COMMON_CONFIGSTATE_READY_BIT             0x00008000
+ 
+//Module Operation Mode States
+#define NAI_MODULE_COMMON_OPERSTATE_BM_ENTERED_BIT              0x00010000
+#define NAI_MODULE_COMMON_OPERSTATE_BM_COMMONPOPULATED_BIT  	0x00020000
+#define NAI_MODULE_COMMON_OPERSTATE_BM_PARAM_LOADED_BIT         0x00040000
+#define NAI_MODULE_COMMON_OPERSTATE_BM_CALIB_LOADED_BIT         0x00080000
+#define NAI_MODULE_COMMON_OPERSTATE_BM_READY_BIT                0x80000000
+
+/* Module Configuration  */
+#define NAI_CLR_MODULE_CONFIG     	0
+#define NAI_SET_MODULE_CONFIG     	1
+#define NAI_MODULE_RESET_DELAY_MS     	100
+#define NAI_MODULE_RESET_DELAY_US		1000
+#define NAI_MAX_MODULE_BIT_MASK	0x3f	//6 slots
+//module link and module detect timout
+//1 seconds
+#define NAI_MODULE_DETECT_COMPLETION_TIMEOUT                         (1 * HZ)
+
+struct nai_serdes_dev {
+	struct miscdevice   miscdev;
+	struct rw_semaphore rwsem;
+	s32                 initialized;
+	s32                 addressed;
+	void __iomem        *swserdes_common_base;
+	void __iomem        *hwserdes_common_base;
+	void __iomem		*modpktconfig_base;
+};
+
+int nai_serdes_open(struct inode *inode, struct file *filp)
+{
+  /* Open must be implemented to force the miscdevice open
+   * function to store dev pointer in the file private data.
+   */
+#ifdef DEBUG_IT
+   pr_info("file name:\"%s\",minor:%d\n",filp->f_path.dentry->d_iname,iminor(filp->f_path.dentry->d_inode));
+#endif
+   return 0;
+}
+
+int nai_serdes_release(struct inode *inode, struct file *filp)
+{
+#ifdef DEBUG_IT
+   pr_info("file name:\"%s\",minor:%d\n",filp->f_path.dentry->d_iname,iminor(filp->f_path.dentry->d_inode));
+#endif
+   return 0;
+}
+
+static long set_slot(struct nai_serdes_dev *dev, nai_serdes_slot *arg) {
+	long ret = 0;
+	s32 rc = NAI__SUCCESS;
+	s32 slot;
+
+	down_write(&dev->rwsem);
+
+	(void)get_user(slot, &arg->slot);
+
+	if(((slot >= NAI_MB_SLOT) && (slot <= NAI_MODULE_6_SLOT)) ||
+	   (slot == NAI_PPC_MB_SLOT)) {
+		rc = nai_init_msg_utils((u8)slot);
+
+		if (rc == NAI__SUCCESS)
+			dev->initialized = 1;
+		else {
+			dev->initialized = 0;
+			ret = -EIO;
+		}
+	} else {
+		rc = NAI_INVALID_SLOT_ID;
+		ret = -EINVAL;
+	}	
+
+	(void)put_user(rc, &arg->rc);
+
+	up_write(&dev->rwsem);
+
+	dev_dbg(dev->miscdev.this_device, "%s: slot=%d ret=%ld rc=%d\n",
+		__func__, slot, ret, rc);
+
+	return ret;
+}
+
+static long init_addr(struct nai_serdes_dev *dev, nai_serdes_addr *arg) {
+	long ret = 0;	
+	s32 rc = NAI__SUCCESS;
+	const u8 MODULE_ADDR_ARRAY_COUNT = 8;
+	u32 uModAddresses[MODULE_ADDR_ARRAY_COUNT];
+	
+	down_write(&dev->rwsem);
+
+	if (!dev->initialized) {
+		ret = -EACCES;
+		goto exit;
+	}
+
+	ret = copy_from_user(&uModAddresses, (void __user*)&arg->addr, sizeof(uModAddresses));
+	if (ret != 0)
+	{
+		rc = NAI_USER_COPY_FAILED;
+		goto exit;
+	}
+	
+	rc = nai_perform_init_slot_addressing(uModAddresses, MODULE_ADDR_ARRAY_COUNT);
+
+	if (rc == NAI__SUCCESS)
+		dev->addressed = 1;
+	else {
+		dev->addressed = 0;
+		ret = -EIO;
+	}
+exit:
+	(void)put_user(rc, &arg->rc);
+
+	up_write(&dev->rwsem);
+
+	dev_dbg(dev->miscdev.this_device, "%s: ret=%ld rc=%d\n",
+		__func__, ret, rc);
+
+	return ret;
+}
+
+static long rdwr_16(struct nai_serdes_dev *dev, nai_serdes_16 *arg, u32 rd) {
+	long ret;
+	s32 rc;
+	u32 addr;
+	s32 slot;
+	u16 val;
+
+	(void)get_user(slot, &arg->slot);
+	(void)get_user(addr, &arg->addr);
+
+	if (!dev->initialized || ((slot == -1) && !dev->addressed)) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (rd) {
+		if (slot == -1)
+			rc = nai_read_reg16_request(addr, &val);
+		else
+			rc = nai_read_reg16_by_slot_request(slot, addr, &val);
+
+		if (rc == NAI__SUCCESS)
+			(void)put_user(val, &arg->val);
+	}
+	else {
+		(void)(get_user(val, &arg->val));
+
+		if (slot == -1)
+			rc = nai_write_reg16_request(addr, val);
+		else
+			rc = nai_write_reg16_by_slot_request(slot, addr, val);
+	}
+
+	ret = (rc == NAI__SUCCESS) ? 0 : -EIO;
+exit:
+	(void)put_user(rc, &arg->rc);
+
+	dev_dbg(dev->miscdev.this_device,
+		"%s: slot=%d rd=%d addr=0x%08X val=0x%04X rc=%d\n",
+		__func__, slot, rd, addr, val, rc);
+
+	return ret;
+}
+
+static long rdwr_32(struct nai_serdes_dev *dev, nai_serdes_32 *arg, u32 rd) {
+	long ret = 0;
+	s32 rc;
+	u32 addr;
+	s32 slot;
+	u32 val;
+
+	(void)get_user(slot, &arg->slot);
+	(void)get_user(addr, &arg->addr);
+
+	if (!dev->initialized || ((slot == -1) && !dev->addressed)) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (rd) { //rd op
+		if (slot == -1)
+			rc = nai_read_reg32_request(addr, &val);
+		else
+			rc = nai_read_reg32_by_slot_request(slot, addr, &val);
+#ifdef DEBUG_IT
+        pr_info("rd:%d,slot:%d,addr:0x%x,val:0x%x\n",rd,slot,addr,val);
+#endif
+		if (rc == NAI__SUCCESS)
+			(void)put_user(val, &arg->val);
+	}
+	else { //wr op
+		(void)(get_user(val, &arg->val));
+
+		if (slot == -1)
+			rc = nai_write_reg32_request(addr, val);
+		else
+			rc = nai_write_reg32_by_slot_request(slot, addr, val);
+	}
+
+	ret = (rc == NAI__SUCCESS) ? 0 : -EIO;
+exit:
+	(void)put_user(rc, &arg->rc);
+
+	dev_dbg(dev->miscdev.this_device,
+		"%s: slot=%d rd=%d addr=0x%08X val=0x%08X rc=%d\n",
+		__func__, slot, rd, addr, val, rc);
+
+	return ret;
+}
+
+static long rdwr_blk_16(struct nai_serdes_dev *dev, nai_serdes_blk_16 *arg,
+			u32 rd) {
+	long ret = 0;
+	s32 rc;
+	u32 addr;
+	s32 slot;
+	u16 count;
+	u8 stride;
+	u32 len;
+	void __user *user_val;
+	u16 *val = NULL;
+
+	(void)get_user(slot, &arg->slot);
+	(void)get_user(addr, &arg->addr);
+	(void)get_user(count, &arg->count);
+	(void)get_user(stride, &arg->stride);
+	(void)get_user(user_val, &arg->val);
+
+	if (!dev->initialized || ((slot == -1) && !dev->addressed)) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	len = sizeof(*val) * count;
+	if (rd)
+		ret = !access_ok(VERIFY_WRITE, user_val, len);
+	else
+		ret = !access_ok(VERIFY_READ, user_val, len);
+	if (ret) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	val = kmalloc(len, GFP_KERNEL);
+	if (!val) {
+		rc = NAI__SUCCESS;
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if (rd) {
+		if (slot == -1)
+			rc = nai_read_block16_request(addr, (u32)count,
+						      stride, val);
+		else
+			rc = nai_read_block16_by_slot_request(slot, addr, (u32)count,
+							      stride, val);
+
+		if (rc == NAI__SUCCESS)
+			ret = copy_to_user(user_val, val, len);
+	}
+	else {
+		ret = copy_from_user(val, user_val, len);
+		
+		if (ret == 0) {
+			if (slot == -1)
+				rc = nai_write_block16_request(addr, (u32)count,
+								   stride, val);
+			else
+				rc = nai_write_block16_by_slot_request(slot, addr, (u32)count,
+									   stride, val);
+		}
+	}
+
+	if (ret)
+		rc = NAI_USER_COPY_FAILED;
+		
+exit:
+	
+	(void)put_user(rc, &arg->rc);
+
+	dev_dbg(dev->miscdev.this_device,
+		"%s: slot=%d rd=%d addr=0x%08X count=%d stride=%d rc=%d\n",
+		__func__, slot, rd, addr, count, stride, rc);
+#ifdef DEBUG
+	if (val) {
+		for (len = 0; len < count; ++len)
+			dev_dbg(dev->miscdev.this_device, "0x%04X\n", val[len]);
+	}
+#endif
+	if (val)
+		kfree(val);
+
+	return ret;
+}
+
+
+
+static long rdwr_blk_16_large(struct nai_serdes_dev *dev, nai_serdes_blk_16_large *arg,
+			u32 rd) {
+	long ret = 0;
+	s32 rc;
+	u32 addr;
+	s32 slot;
+	u32 count;
+	u8 stride;
+	u32 len;
+	void __user *user_val;
+	u16 *val = NULL;
+
+	(void)get_user(slot, &arg->slot);
+	(void)get_user(addr, &arg->addr);
+	(void)get_user(count, &arg->count);
+	(void)get_user(stride, &arg->stride);
+	(void)get_user(user_val, &arg->val);
+
+   if (!dev->initialized || ((slot == -1) && !dev->addressed)) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+   
+   
+       len = sizeof(*val) * count;
+       if (rd)
+		 ret = !access_ok(VERIFY_WRITE, user_val, len);
+         else
+		 ret = !access_ok(VERIFY_READ, user_val, len);
+       if (ret) {
+		   ret = -EFAULT;
+		 goto exit;
+	    }
+       val = kmalloc(len, GFP_KERNEL);
+       if (!val) {
+		   rc = NAI__SUCCESS;
+		 ret = -ENOMEM;
+		   goto exit;
+	    }
+       
+       if (rd) {
+		 if (slot == -1)
+			rc = nai_read_block16_request(addr, count,
+						      stride, val);
+		 else
+			rc = nai_read_block16_by_slot_request(slot, addr, count,
+							      stride, val);
+
+		if (rc == NAI__SUCCESS)
+			ret = copy_to_user(user_val, val, len);
+	   }
+      else
+      {
+         ret = copy_from_user(val, user_val, len);
+         if (ret == 0) {
+            if (slot == -1) {
+               rc = nai_write_block16_request(addr, count,
+                              stride, val);
+            } else {
+              rc = nai_write_block16_by_slot_request(slot, addr, count,
+                                 stride, val);
+           }
+        }   
+      }
+   
+
+	if (ret)
+		rc = NAI_USER_COPY_FAILED;
+		
+exit:
+	
+	(void)put_user(rc, &arg->rc);
+    
+	dev_dbg(dev->miscdev.this_device,
+		"%s: slot=%d rd=%d addr=0x%08X count=%d stride=%d rc=%d\n",
+		__func__, slot, rd, addr, count, stride, rc);
+#ifdef DEBUG
+	if (val) {
+		for (len = 0; len < count; ++len)
+			dev_dbg(dev->miscdev.this_device, "0x%04X\n", val[len]);
+	}
+#endif
+	if (val)
+		kfree(val);
+
+	return ret;
+}
+
+static long rdwr_blk_32(struct nai_serdes_dev *dev, nai_serdes_blk_32 *arg,
+			u32 rd) {
+	long ret = 0;
+	s32 rc;
+	u32 addr;
+	s32 slot;
+	u16 count;
+	u8 stride;
+	u32 len;
+	void __user *user_val;
+	u32 *val = NULL;
+
+	(void)get_user(slot, &arg->slot);
+	(void)get_user(addr, &arg->addr);
+	(void)get_user(count, &arg->count);
+	(void)get_user(stride, &arg->stride);
+	(void)get_user(user_val, &arg->val);
+
+	if (!dev->initialized || ((slot == -1) && !dev->addressed)) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	len = sizeof(*val) * count;
+	if (rd)
+		ret = !access_ok(VERIFY_WRITE, user_val, len);
+	else
+		ret = !access_ok(VERIFY_READ, user_val, len);
+	if (ret) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	val = kmalloc(len, GFP_KERNEL);
+	if (!val) {
+		rc = NAI__SUCCESS;
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if (rd) {
+		if (slot == -1)
+			rc = nai_read_block32_request(addr, (u32)count,
+						      stride, val);
+		else
+			rc = nai_read_block32_by_slot_request(slot, addr, (u32)count,
+							      stride, val);
+
+		if (rc == NAI__SUCCESS)
+			ret = copy_to_user(user_val, val, len);
+	} else {
+		ret = copy_from_user(val, user_val, len);
+		
+		if (ret == 0) {
+			if (slot == -1) {
+				rc = nai_write_block32_request(addr, (u32)count,
+								   stride, val);
+			} else {
+				rc = nai_write_block32_by_slot_request(slot, addr, (u32)count,
+									   stride, val);
+			}
+		}
+	}
+
+	if (ret)
+		rc = NAI_USER_COPY_FAILED;
+		
+exit:
+        (void)put_user(rc, &arg->rc);
+
+	dev_dbg(dev->miscdev.this_device,
+		"%s: slot=%d rd=%d addr=0x%08X count=%d stride=%d rc=%d\n",
+		__func__, slot, rd, addr, count, stride, rc);
+#ifdef DEBUG
+	if (val) {
+		for (len = 0; len < count; ++len)
+			dev_dbg(dev->miscdev.this_device, "0x%08X\n", val[len]);
+	}
+#endif
+        if (val)
+	        kfree(val);
+
+        return ret;
+}
+
+static long rdwr_blk_32_large(struct nai_serdes_dev *dev, nai_serdes_blk_32_large *arg,
+			u32 rd) {
+	long ret = 0;
+	s32 rc;
+	u32 addr;
+	s32 slot;
+	u32 count;
+	u8 stride;
+	u32 len;
+   u32 remainLen;
+	void __user *user_val;
+	u32 *val = NULL;
+   u32 idx=0;
+   u32 maxWrSegCnt=0;
+   u32 remainingWrCnt=0;
+
+	(void)get_user(slot, &arg->slot);
+	(void)get_user(addr, &arg->addr);
+	(void)get_user(count, &arg->count);
+	(void)get_user(stride, &arg->stride);
+	(void)get_user(user_val, &arg->val);
+
+	if (!dev->initialized || ((slot == -1) && !dev->addressed)) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+   if( count > NAI_MAX_COUNT_PER_WRITE)
+   {
+       maxWrSegCnt=count/NAI_MAX_COUNT_PER_WRITE;
+       remainingWrCnt=count%NAI_MAX_COUNT_PER_WRITE; 
+       len = sizeof(*val) * NAI_MAX_COUNT_PER_WRITE;
+       
+       val = kmalloc(len, GFP_KERNEL);
+       if (!val) {
+		   rc = NAI__SUCCESS;
+		   ret = -ENOMEM;
+		   goto exit;
+	    }
+       
+       for(idx=0; idx < maxWrSegCnt; idx++)
+       {
+          if (rd)
+          ret = !access_ok(VERIFY_WRITE, user_val + idx * len, len);
+            else
+          ret = !access_ok(VERIFY_READ, user_val + idx * len, len);
+          if (ret) {
+            ret = -EFAULT;
+            goto exit;
+          }
+          
+          if (rd) {
+            if (slot == -1)
+			       rc = nai_read_block32_request(addr, NAI_MAX_COUNT_PER_WRITE,
+						         stride, val);
+		      else
+			       rc = nai_read_block32_by_slot_request(slot, addr, NAI_MAX_COUNT_PER_WRITE,
+							      stride, val);
+
+          if (rc == NAI__SUCCESS)
+			   ret = copy_to_user(user_val + idx * len, val, len);
+	       } else {
+	       ret = copy_from_user(val, user_val + idx * len, len);
+          if (ret == 0) {
+             if (slot == -1) {
+                rc = nai_write_block32_request(addr, NAI_MAX_COUNT_PER_WRITE,
+                                 stride, val);
+                } else {
+                  rc = nai_write_block32_by_slot_request(slot, addr, NAI_MAX_COUNT_PER_WRITE,
+                                 stride, val);
+               }
+            }
+          }
+       }
+       if(remainingWrCnt)
+       {
+          remainLen = sizeof(*val) * remainingWrCnt;
+          if (rd)  
+          ret = !access_ok(VERIFY_WRITE, user_val + maxWrSegCnt * len, remainLen);
+            else
+          ret = !access_ok(VERIFY_READ, user_val + maxWrSegCnt * len, remainLen);
+          if (ret) {
+            ret = -EFAULT;
+            goto exit;
+          }
+          
+          if (rd) {
+            if (slot == -1)
+			       rc = nai_read_block32_request(addr, remainingWrCnt,
+						         stride, val);
+		      else
+			       rc = nai_read_block32_by_slot_request(slot, addr, remainingWrCnt,
+							      stride, val);
+
+          if (rc == NAI__SUCCESS)
+			   ret = copy_to_user(user_val + maxWrSegCnt * len, val, remainLen);
+	       } else {
+	       ret = copy_from_user(val, user_val + maxWrSegCnt * len, remainLen);
+          if (ret == 0) {
+             if (slot == -1) {
+                rc = nai_write_block32_request(addr, remainingWrCnt,
+                                 stride, val);
+                } else {
+                  rc = nai_write_block32_by_slot_request(slot, addr, remainingWrCnt,
+                                    stride, val);
+               }
+            }
+          }
+       }     
+   }
+   else
+   {
+       len = sizeof(*val) * count;
+       if (rd)
+		 ret = !access_ok(VERIFY_WRITE, user_val, len);
+         else
+		 ret = !access_ok(VERIFY_READ, user_val, len);
+       if (ret) {
+		   ret = -EFAULT;
+		 goto exit;
+	    }
+       val = kmalloc(len, GFP_KERNEL);
+       if (!val) {
+		   rc = NAI__SUCCESS;
+		 ret = -ENOMEM;
+		   goto exit;
+	    }
+       
+       if (rd) {
+		 if (slot == -1)
+			rc = nai_read_block32_request(addr, count,
+						      stride, val);
+		else
+			rc = nai_read_block32_by_slot_request(slot, addr, count,
+							      stride, val);
+
+		if (rc == NAI__SUCCESS)
+			ret = copy_to_user(user_val, val, len);
+	   }
+      else
+      {
+         ret = copy_from_user(val, user_val, len);
+         if (ret == 0) {
+            if (slot == -1) {
+               rc = nai_write_block32_request(addr, count,
+                              stride, val);
+            } else {
+              rc = nai_write_block32_by_slot_request(slot, addr, count,
+                                 stride, val);
+           }
+        }   
+      }
+   }
+	if (ret)
+		rc = NAI_USER_COPY_FAILED;
+		
+exit:
+        (void)put_user(rc, &arg->rc);
+
+	dev_dbg(dev->miscdev.this_device,
+		"%s: slot=%d rd=%d addr=0x%08X count=%d stride=%d rc=%d\n",
+		__func__, slot, rd, addr, count, stride, rc);
+#ifdef DEBUG
+	if (val) {
+		for (len = 0; len < count; ++len)
+			dev_dbg(dev->miscdev.this_device, "0x%08X\n", val[len]);
+	}
+#endif
+        if (val)
+	        kfree(val);
+
+        return ret;
+}
+
+static long rdwr_module_eeprom(struct nai_serdes_dev *dev, nai_serdes_module_eeprom *arg, u32 rd) {
+	
+	long ret = 0;
+	s32 rc;
+	u16 chipId;
+	u8 reqId;
+	u8 compId;
+	u32 eepromOffset;
+	s32 len;
+	s32 buffSize;
+	
+	void __user *user_buff;
+	u8 *buf = NULL;
+	
+#ifdef DEBUG	
+	u32 index = 0;
+#endif
+
+	(void)get_user(chipId, &arg->chipId); //function:0x81,interface:0x80,
+	(void)get_user(reqId, &arg->reqId);   //always 0
+	(void)get_user(compId, &arg->compId); //module 1/2
+	(void)get_user(eepromOffset, &arg->eepromOffset);
+	(void)get_user(user_buff, &arg->buff);
+	(void)get_user(len, &arg->len);
+
+	if (!dev->initialized || (compId == -1)) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	buffSize = sizeof(*buf) * len;
+	if (rd)
+		ret = !access_ok(VERIFY_WRITE, user_buff, buffSize);
+	else
+		ret = !access_ok(VERIFY_READ, user_buff, buffSize);
+	
+	if (ret) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	buf = kmalloc(buffSize, GFP_KERNEL);
+	if (!buf) {
+		rc = NAI_UNABLE_TO_ALLOCATE_MEMORY;
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if (rd) {
+		rc = nai_read_module_eeprom_request(chipId, reqId, compId, eepromOffset, buf, len);
+		if (rc == NAI__SUCCESS)
+			ret = copy_to_user(user_buff, buf, buffSize);
+	} else {
+		ret = copy_from_user(buf, user_buff, buffSize);
+		if (ret == 0)
+			rc = nai_write_module_eeprom_request(chipId, reqId, compId, eepromOffset, buf, len);
+	}
+	
+	if (ret)
+		rc = NAI_USER_COPY_FAILED;
+		
+exit:
+	(void)put_user(rc, &arg->rc);
+#ifdef DEBUG_IT
+        pr_info("dev=%s chipId=%d rd=%d reqId=0x%x compId=0x%x eepromOffset=0x%x len=%d rc=%d \n",dev_name(dev->miscdev.this_device), chipId, rd, reqId, compId, eepromOffset, len, rc);
+#endif
+	dev_dbg(dev->miscdev.this_device,
+		"%s: chipId=%d rd=%d reqId=0x%x compId=0x%x eepromOffset=0x%x len=%d rc=%d \n",
+		__func__, chipId, rd, reqId, compId, eepromOffset, len, rc);
+	
+#ifdef DEBUG	
+	if (buf) {
+		for (index = 0; index < len; ++index)
+			dev_dbg(dev->miscdev.this_device, "0x%08x\n", buf[index]);
+	}
+#endif
+        if (buf)
+	        kfree(buf);
+	        
+        return ret;
+}
+
+static long rdwr_module_flash(struct nai_serdes_dev *dev, nai_serdes_module_flash *arg, u8 op) {
+	
+	u8 reqId;
+	u8 compId;
+	u32 flashOffset;
+	u8 numPage;
+	s32 len;
+	
+	long ret = 0;
+	s32 rc;
+	s32 buffSize;
+	
+	void __user *user_buff;
+	u8 *buf = NULL;
+#ifdef DEBUG	
+	u32 index = 0;
+#endif
+
+	(void)get_user(reqId, &arg->reqId);
+	(void)get_user(compId, &arg->compId);
+	(void)get_user(flashOffset, &arg->flashOffset);
+	(void)get_user(numPage, &arg->numPage);
+	(void)get_user(user_buff, &arg->buff);
+	(void)get_user(len, &arg->len);
+
+	if (!dev->initialized || compId == -1) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (op == NAI_MODULE_FLASH_ERASE) {
+		rc = nai_erase_flash_request(reqId, compId, flashOffset, numPage);
+	} else {
+		
+		buffSize = sizeof(*buf) * len;
+		if (op == NAI_MODULE_FLASH_READ) {
+			ret = !access_ok(VERIFY_WRITE, user_buff, buffSize);
+		} else if (op ==  NAI_MODULE_FLASH_WRITE) {
+			ret = !access_ok(VERIFY_READ, user_buff, buffSize);
+		}
+		if (ret) {
+			ret = -EFAULT;
+			goto exit;
+		}
+
+		buf = kmalloc(buffSize, GFP_KERNEL);
+		if (!buf) {
+			rc = NAI__SUCCESS;
+			ret = -ENOMEM;
+			goto exit;
+		}
+
+		if (op == NAI_MODULE_FLASH_READ) {
+
+			rc = nai_read_module_flash_request(reqId, compId, flashOffset, buf, len);
+			if (rc == NAI__SUCCESS)
+				ret = copy_to_user(user_buff, buf, buffSize);
+
+		} else if ( op ==  NAI_MODULE_FLASH_WRITE ) {
+			
+			ret = copy_from_user(buf, user_buff, buffSize);
+			if (ret == 0)
+				rc = nai_write_module_flash_request(reqId, compId, flashOffset, buf, len);
+				
+		} else {
+			rc = nai_erase_flash_request(reqId, compId, flashOffset ,numPage);
+		}
+	}
+	
+	if (ret)
+		rc = NAI_USER_COPY_FAILED;
+		
+exit:
+	(void)put_user(rc, &arg->rc);
+
+	dev_dbg(dev->miscdev.this_device,
+		"%s: op=%d reqId=0x%08X compId=0x%x flashOffset=0x%x len=%d rc=%d\n",
+		__func__, op, reqId, compId, flashOffset, len, rc);
+#ifdef DEBUG
+	if (buf) {
+		for (index = 0; index < len; ++index)
+			dev_dbg(dev->miscdev.this_device, "0x%08x\n", buf[index]);
+	}
+#endif
+        if (buf)
+	        kfree(buf);
+#ifdef DEBUG_IT
+        pr_info("NAI_IOC_SERDES_ERASE_MODULE_FLASH:0x%x,ret:%d\n",NAI_IOC_SERDES_ERASE_MODULE_FLASH,ret);
+#endif
+        return ret;
+}
+
+static long rdwr_module_micro(struct nai_serdes_dev *dev, nai_serdes_module_micro *arg, u8 op) {
+	u8 reqId;
+	u8 compId;
+	u8 channel;
+	u32 flashOffset;	
+	s32 len;
+	
+	long ret = 0;
+	s32 rc;
+	s32 buffSize;
+	
+	void __user *user_buff;
+	u8 *buf = NULL;
+#ifdef DEBUG	
+	u32 index = 0;
+#endif
+
+	(void)get_user(reqId, &arg->reqId);
+	(void)get_user(compId, &arg->compId);
+	(void)get_user(channel, &arg->channel);
+	(void)get_user(flashOffset, &arg->flashOffset);	
+	(void)get_user(user_buff, &arg->buff);
+	(void)get_user(len, &arg->len);
+
+	if (!dev->initialized || compId == -1) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (op == NAI_MODULE_MICRO_ERASE) {
+		rc = nai_erase_micro_request(reqId, compId, channel);
+	} else {
+		
+		buffSize = sizeof(*buf) * len;
+		if (op == NAI_MODULE_MICRO_GET) {
+			ret = !access_ok(VERIFY_WRITE, user_buff, buffSize);
+		} else if (op ==  NAI_MODULE_MICRO_WRITE) {
+			ret = !access_ok(VERIFY_READ, user_buff, buffSize);
+		}
+		if (ret) {
+			ret = -EFAULT;
+			goto exit;
+		}
+
+		buf = kmalloc(buffSize, GFP_KERNEL);
+		if (!buf) {
+			rc = NAI__SUCCESS;
+			ret = -ENOMEM;
+			goto exit;
+		}
+
+		if (op == NAI_MODULE_MICRO_GET) {
+
+			rc = nai_get_micro_request(reqId, compId, channel, buf, len);
+			if (rc == NAI__SUCCESS)
+				ret = copy_to_user(user_buff, buf, buffSize);
+
+		} else if ( op ==  NAI_MODULE_MICRO_WRITE ) {
+			ret = copy_from_user(buf, user_buff, buffSize);
+			if (ret == 0) 
+				rc = nai_write_micro_request(reqId, compId, channel, flashOffset, buf, len);							
+		} else {
+			rc = nai_erase_micro_request(reqId, compId, channel);
+		}
+	}
+	
+	if (ret)
+		rc = NAI_USER_COPY_FAILED;
+		
+exit:
+	(void)put_user(rc, &arg->rc);
+
+	dev_dbg(dev->miscdev.this_device,
+		"%s: op=%d reqId=0x%08X compId=0x%x flashOffset=0x%x len=%d rc=%d\n",
+		__func__, op, reqId, compId, flashOffset, len, rc);
+#ifdef DEBUG
+	if (buf) {
+		for (index = 0; index < len; ++index)
+			dev_dbg(dev->miscdev.this_device, "0x%08x\n", buf[index]);
+	}
+#endif
+        if (buf)
+	        kfree(buf);
+	        
+        return ret;	
+}
+
+static long get_module_mode_ready_state(struct nai_serdes_dev *dev, nai_module_op *arg, u32 rd) {
+	
+	long ret = 0;
+	u32 val = 0;
+	u32 slot = 0;
+	u32 rc = 0;
+
+	(void)get_user(slot, &arg->slot);
+
+	if ( !dev->initialized && 
+		((slot < NAI_MODULE_1_SLOT) || (slot > NAI_MODULE_6_SLOT)) ) {
+		rc = NAI_SYSTEM_NOT_READY;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	rc = nai_read_reg32_by_slot_request(slot, NAI_MODULE_COMMON_READY_OFFSET, &val);
+	if (rc == NAI__SUCCESS) {
+		switch(rd) {
+		
+			case NAI_MODULE_COMMON_CONFIGSTATE_REQUEST_ACK_BIT:
+				val = (val & NAI_MODULE_COMMON_CONFIGSTATE_REQUEST_ACK_BIT) ? 1 : 0;
+				break;
+			
+			case NAI_MODULE_COMMON_CONFIGSTATE_READY_BIT:
+				val = (val & NAI_MODULE_COMMON_CONFIGSTATE_READY_BIT) ? 1 : 0;
+				break;
+			
+			case NAI_MODULE_COMMON_OPERSTATE_BM_ENTERED_BIT:
+				val = (val & NAI_MODULE_COMMON_OPERSTATE_BM_ENTERED_BIT) ? 1 : 0;
+				break;
+			
+			case NAI_MODULE_COMMON_OPERSTATE_BM_COMMONPOPULATED_BIT:
+				val = (val & NAI_MODULE_COMMON_OPERSTATE_BM_COMMONPOPULATED_BIT) ? 1 : 0;
+				break;
+			
+			case NAI_MODULE_COMMON_OPERSTATE_BM_PARAM_LOADED_BIT:
+				val = (val & NAI_MODULE_COMMON_OPERSTATE_BM_PARAM_LOADED_BIT) ? 1 : 0;
+				break;
+			
+			case NAI_MODULE_COMMON_OPERSTATE_BM_CALIB_LOADED_BIT:
+				val = (val & NAI_MODULE_COMMON_OPERSTATE_BM_CALIB_LOADED_BIT) ? 1 : 0;
+				break;
+			
+			case NAI_MODULE_COMMON_OPERSTATE_BM_READY_BIT:
+				val = (val & NAI_MODULE_COMMON_OPERSTATE_BM_READY_BIT) ? 1 : 0;
+				break;
+			
+			default:
+				val = 0;
+				rc = NAI_INVALID_PARAMETER_VALUE;
+			break;
+		}
+		(void)put_user(val, &arg->enable);
+	}	
+
+	ret = (rc == NAI__SUCCESS) ? 0 : -EIO;
+	
+exit:
+	(void)put_user(rc, &arg->rc);
+	(void)put_user(val, &arg->enable);
+	return ret;
+}
+
+static long get_module_detected(struct nai_serdes_dev *dev,
+				nai_module_op __user *arg) {
+	long ret = 0;
+	u32 val = 0;
+	u32 slot = 0;
+	u32 done = 0;
+	u32 rc = 0;
+
+	(void)get_user(slot, &arg->slot);
+
+	if ( (slot >= NAI_MODULE_1_SLOT) && (slot <= NAI_MODULE_6_SLOT) ) {
+		slot = slot - 1;
+		val = ioread32(dev->swserdes_common_base + NAI_MODULE_DETECTED_OFFSET);
+		/*
+		 * upper byte is module detect done
+		 * lower byte is module ready
+		*/
+		done = val >> NAI_MODULE_DETECTED_DONE_SHIFT;
+		
+		//return 1 to user app if both module detect done and module ready are set to 1
+		if (done & (1 << slot)) {
+			val = (val & (1 << slot)) ? 1 : 0;
+		} else {
+			rc = ret = -EAGAIN;
+		}
+	} else {
+		rc = ret = -EINVAL;
+	}
+	
+	(void)put_user(val, &arg->enable);
+	(void)put_user(rc, &arg->rc);
+	return ret;
+}
+
+static long get_serdes_module_revision(nai_module_serdes_revision __user *arg) {
+	long ret = 0;
+	u8 major = NAI_DRV_SERDES_VER_MAJOR;
+	u8 minor = NAI_DRV_SERDES_VER_MINOR;
+	
+	if((ret = put_user(major, &arg->serdesMajorRev)) == 0)
+    {
+      ret = put_user(minor, &arg->serdesMinorRev);
+    }
+	return ret;
+}
+
+static long get_module_link_init(struct nai_serdes_dev *dev,
+				 nai_module_op __user *arg) {
+	long ret = 0;
+	u32 val = 0;
+	u32 slot = 0;
+	u32 rc = 0;
+
+	
+	(void)get_user(slot, &arg->slot);
+
+	if ( (slot >= NAI_MODULE_1_SLOT) && (slot <= NAI_MODULE_6_SLOT) ) {
+		
+		slot = slot - 1;
+		
+		val = ioread32(dev->swserdes_common_base + NAI_MODULE_LINK_INIT_OFFSET);
+		val = (val & (1 << slot)) ? 1 : 0;
+		
+		if (!val) {
+			rc = ret = -EAGAIN;
+		}
+	} else {
+		rc = ret = -EINVAL;
+	}
+	
+	(void)put_user(val, &arg->enable);
+	(void)put_user(rc, &arg->rc);
+	return ret;
+}
+
+static long set_module_reset
+(
+   struct nai_serdes_dev *dev,
+   nai_module_op __user *arg)
+{
+   long result = 0;
+   u32 val = 0;
+   u32 slot = 0;
+   u32 rc = 0;
+   u32 timer = 0;
+
+   (void)get_user(slot, &arg->slot);
+
+   if((slot >= NAI_MODULE_1_SLOT) && (slot <= NAI_MODULE_6_SLOT))
+   {
+      /* Module Reset and HSS is a bitmap register
+       * Bit 0 = Module 1
+       * Bit 1 = Module 2
+       * Bit 2 = Module 3
+       * Bit 3 = Module 4
+       * Bit 4 = Module 5
+       * Bit 5 = Module 6
+       */
+      
+      slot = slot - 1;
+      /* SoftReset module operation
+       * 1. Held module HSS in reset
+       * 2. wait 1ms (based on KF's module reset spec)
+       * 3. Held module reset 
+       * 4. wait 1ms (based on KF's module reset spec)
+       * 5. Release module from reset
+       * 6. wait for module detect done and module ready (timeout in 1seconds)
+       * 7. take module hss out of reset 
+       * 8. wait for link init done (timeout in 1seconds)
+       */
+      //1. Held module HSS in reset
+      val = ioread32(dev->swserdes_common_base + NAI_MODULE_HSS_OFFSET);
+      val |= (1 << slot);
+      iowrite32(val, dev->swserdes_common_base + NAI_MODULE_HSS_OFFSET);
+      // 2. wait 1ms (based on KF's module reset spec)
+      udelay(NAI_MODULE_RESET_DELAY_US);
+      // 3. Held module nReset
+      val = ioread32(dev->swserdes_common_base + NAI_MODULE_RESET_OFFSET);
+      val &= ~(1 << slot);
+      iowrite32(val, dev->swserdes_common_base + NAI_MODULE_RESET_OFFSET);
+      // 4. wait 1ms (based on KF's module reset spec)
+      udelay(NAI_MODULE_RESET_DELAY_US);
+      // 5. Release module from nReset
+      val = ioread32(dev->swserdes_common_base + NAI_MODULE_RESET_OFFSET);
+      val |= (1 << slot);
+      iowrite32(val, dev->swserdes_common_base + NAI_MODULE_RESET_OFFSET);
+      
+      //6. wait for module detect done and module ready (timeout in 1seconds)
+      timer = jiffies;
+      while ( 0 != get_module_detected(dev, (nai_module_op __user *)arg) )
+      {
+         if (((s32)jiffies - (s32)timer) > NAI_MODULE_DETECT_COMPLETION_TIMEOUT)
+         {
+            rc = NAI_MODULE_DETECT_READY_TIMEOUT;
+            result =  -EAGAIN;
+            pr_err("slot:%d,NAI_MODULE_DETECT_READY_TIMEOUT:%d,result:%d\n",slot,NAI_MODULE_DETECT_READY_TIMEOUT,result);
+            break;
+         }
+         schedule();
+      }
+      
+      // 7. Release module HSS from reset
+      val = ioread32(dev->swserdes_common_base + NAI_MODULE_HSS_OFFSET);
+      val &= ~(1 << slot);
+      //TODO: A bug in MB FPGA that we can't use bitmap to take each module out of HSS reset
+      //Temp WR for the above bug: take all module out of HSS reset by clear all bits in the HSS register
+      val = 0x0;
+      iowrite32(val, dev->swserdes_common_base + NAI_MODULE_HSS_OFFSET);
+      
+      //8. wait for link init done (timeout in 1seconds)
+      timer = jiffies;
+      while (0 != get_module_link_init(dev, (nai_module_op __user *)arg))
+      {   
+         if (((s32)jiffies - (s32)timer) > NAI_MODULE_DETECT_COMPLETION_TIMEOUT)
+         {
+            rc = NAI_MODULE_LINK_DETECT_TIMEOUT;
+            result =  -EAGAIN;
+            pr_err("slot:%d,NAI_MODULE_LINK_DETECT_TIMEOUT:%d,result:%d\n",slot,NAI_MODULE_LINK_DETECT_TIMEOUT,result);
+            break;
+         }
+         schedule();
+      }
+   }
+   else
+   {
+      rc = result = -EINVAL;
+      pr_err("slot:%d,result:%d\n",slot,result);
+   }
+
+   (void)put_user(rc, &arg->rc);
+#ifdef DEBUG_IT
+   pr_info("slot:%d,rc:%d\n",slot,rc);
+#endif
+   return result;
+}
+
+static long kill_module_serdes(struct nai_serdes_dev *dev,
+			     nai_module_op __user *arg) {
+	long ret = 0;
+	u32 val = 0;
+	u32 slot = 0;
+	u32 rc = 0;
+
+	(void)get_user(slot, &arg->slot);
+	
+	if ( (slot >= NAI_MODULE_1_SLOT) && (slot <= NAI_MODULE_6_SLOT) ) {
+		/* Module Power is a bitmap register
+		 * Bit 0 = Module 1
+		 * Bit 1 = Module 2
+		 * Bit 2 = Module 3
+		 * Bit 3 = Module 4
+		 * Bit 4 = Module 5
+		 * Bit 5 = Module 6
+		 */
+		
+		slot = slot - 1;
+				
+		// 1. Kill module serdes for desired module
+		val = ioread32(dev->swserdes_common_base + NAI_MODULE_RESET_OFFSET);
+		val &= ~(1 << slot);
+		iowrite32(val, dev->swserdes_common_base + NAI_MODULE_RESET_OFFSET);
+			
+	} else {
+		rc = ret = -EINVAL;
+	}
+	(void)put_user(rc, &arg->rc);
+	return ret;
+}
+
+static long set_module_config(struct nai_serdes_dev *dev,
+			      nai_module_op __user *arg, u32 op) {
+	long ret = 0;
+	u32 val = 0;
+	u32 slot = 0;
+	u32 rc = 0;
+
+	(void)get_user(slot, &arg->slot);
+
+	if ( (slot >= NAI_MODULE_1_SLOT) && (slot <= NAI_MODULE_6_SLOT) ) {
+		
+		/* Module Config mode is a bitmap register
+		 * Bit 0 = Module 1
+		 * Bit 1 = Module 2
+		 * Bit 2 = Module 3
+		 * Bit 3 = Module 4
+		 * Bit 4 = Module 5
+		 * Bit 5 = Module 6
+		 */
+		
+		slot = slot - 1;
+		
+		val = ioread32(dev->swserdes_common_base + NAI_MODULE_CONFIG_MODE_OFFSET);
+		val &= ~(1 << slot);
+		
+		if ( NAI_SET_MODULE_CONFIG == op )
+			val |= (1 << slot);
+		iowrite32(val, dev->swserdes_common_base + NAI_MODULE_CONFIG_MODE_OFFSET);
+
+	} else {
+		rc = ret = -EINVAL;
+	}
+	
+	(void)put_user(rc, &arg->rc);
+	return ret;
+}
+
+long nai_serdes_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
+   struct nai_serdes_dev *dev;
+   long ret = 0;
+   u32 rd = 0;
+   u8 op = 0;
+#ifdef DEBUG_IT
+   pr_info("file name:\"%s\",minor:%d,cmd:0x%x\n",filp->f_path.dentry->d_iname,iminor(filp->f_path.dentry->d_inode),cmd);
+#endif
+	dev = container_of(filp->private_data, struct nai_serdes_dev, miscdev);
+
+	dev_dbg(dev->miscdev.this_device, "%s: type=%d dir=%d size=%d\n",
+		__func__, _IOC_TYPE(cmd), _IOC_DIR(cmd), _IOC_SIZE(cmd));
+
+	if (_IOC_TYPE(cmd) != NAI_SERDES_MAGIC) {
+		ret = -ENOTTY;
+		goto exit;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg,
+				 _IOC_SIZE(cmd));
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg,
+				 _IOC_SIZE(cmd));
+	if (ret) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	switch (cmd) {
+	case NAI_IOC_SERDES_SET_SLOTID:
+		ret = set_slot(dev, (nai_serdes_slot *)arg);	
+		break;
+
+	case NAI_IOC_SERDES_INIT_ADDR:
+		ret = init_addr(dev, (nai_serdes_addr *)arg);
+		break;
+
+	default:
+		/* TODO should be a down_read but we want to serialize
+		 * access to all modules
+		 */
+		down_write(&dev->rwsem);
+
+		switch (cmd) {
+		case NAI_IOC_SERDES_RD_REG16:
+			rd = 1; /* Intentional fall-through */
+		case NAI_IOC_SERDES_WR_REG16:
+			ret = rdwr_16(dev, (nai_serdes_16 *)arg, rd);
+			break;
+
+		case NAI_IOC_SERDES_RD_REG32:
+			rd = 1; /* Intentional fall-through */
+		case NAI_IOC_SERDES_WR_REG32:
+			ret = rdwr_32(dev, (nai_serdes_32 *)arg, rd);
+			break;
+		case NAI_IOC_SERDES_RD_BLK16:
+			rd = 1; /* Intentional fall-through */
+		case NAI_IOC_SERDES_WR_BLK16:
+			ret = rdwr_blk_16(dev, (nai_serdes_blk_16 *)arg, rd);
+			break;
+      case NAI_IOC_SERDES_RD_BLK16_LARGE:
+			rd = 1; /* Intentional fall-through */
+		case NAI_IOC_SERDES_WR_BLK16_LARGE:
+			ret = rdwr_blk_16_large(dev, (nai_serdes_blk_16_large *)arg, rd);
+			break;
+ 		case NAI_IOC_SERDES_RD_BLK32:
+			rd = 1; /* Intentional fall-through */
+		case NAI_IOC_SERDES_WR_BLK32:
+			ret = rdwr_blk_32(dev, (nai_serdes_blk_32 *)arg, rd);
+			break;
+      	case NAI_IOC_SERDES_RD_BLK32_LARGE:
+			rd = 1; /* Intentional fall-through */
+		case NAI_IOC_SERDES_WR_BLK32_LARGE:
+			ret = rdwr_blk_32_large(dev, (nai_serdes_blk_32_large *)arg, rd);
+			break;
+		case NAI_IOC_SERDES_RD_MODULE_EEPROM:
+#ifdef DEBUG_IT
+                        pr_info("cmd:0x%x,NAI_IOC_SERDES_RD_MODULE_EEPROM:0x%x\n",cmd,NAI_IOC_SERDES_RD_MODULE_EEPROM);
+#endif
+			rd = 1; /* Intentional fall-through */
+		case NAI_IOC_SERDES_WR_MODULE_EEPROM:
+#ifdef DEBUG_IT
+                        pr_info("cmd:0x%x,NAI_IOC_SERDES_WR_MODULE_EEPROM:0x%x\n",cmd,NAI_IOC_SERDES_WR_MODULE_EEPROM);
+#endif
+			ret = rdwr_module_eeprom(dev, (nai_serdes_module_eeprom *)arg, rd);
+			break;
+		case NAI_IOC_SERDES_RD_MODULE_FLASH:
+			op = NAI_MODULE_FLASH_READ;
+			ret = rdwr_module_flash(dev, (nai_serdes_module_flash *)arg, op);
+			break;
+		case NAI_IOC_SERDES_WR_MODULE_FLASH:
+			op = NAI_MODULE_FLASH_WRITE;
+			ret = rdwr_module_flash(dev, (nai_serdes_module_flash *)arg, op);
+			break;
+		case NAI_IOC_SERDES_ERASE_MODULE_FLASH:
+			op = NAI_MODULE_FLASH_ERASE;
+			ret = rdwr_module_flash(dev, (nai_serdes_module_flash *)arg, op);
+#ifdef DEBUG_IT
+                        pr_info("cmd:0x%x,NAI_IOC_SERDES_ERASE_MODULE_FLASH:0x%x,ret:%ld\n",cmd,NAI_IOC_SERDES_ERASE_MODULE_FLASH,ret);
+#endif
+			break;
+		case NAI_IOC_GET_MODULE_DETECTED:
+			ret = get_module_detected(dev, (nai_module_op __user *)arg);
+			break;
+		case NAI_IOC_GET_MODULE_LINK_INIT:
+			ret = get_module_link_init(dev, (nai_module_op __user *)arg);
+			break;
+		case NAI_IOC_SET_MODULE_RESET:
+			ret = set_module_reset(dev, (nai_module_op __user *)arg);
+#ifdef DEBUG_IT
+                        pr_info("cmd:0x%x,NAI_IOC_SET_MODULE_RESET:0x%x,ret:%ld\n",cmd,NAI_IOC_SET_MODULE_RESET,ret);
+#endif
+			break;
+		case NAI_IOC_KILL_MODULE_SERDES:
+			ret = kill_module_serdes(dev, (nai_module_op __user *)arg);
+			break;
+		case NAI_IOC_SET_MODULE_CONFIG_MODE:
+			rd = NAI_SET_MODULE_CONFIG; /* Intentional fall-through */
+		case NAI_IOC_CLR_MODULE_CONFIG_MODE:
+			ret = set_module_config(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_GET_MODULE_CONFIG_STATE_RQ_ACK:
+			rd = NAI_MODULE_COMMON_CONFIGSTATE_REQUEST_ACK_BIT;
+			ret = get_module_mode_ready_state(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_GET_MODULE_CONFIG_STATE_RDY:
+			rd = NAI_MODULE_COMMON_CONFIGSTATE_READY_BIT;
+			ret = get_module_mode_ready_state(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_GET_MODULE_OPER_BM_ENTERED:
+			rd = NAI_MODULE_COMMON_OPERSTATE_BM_ENTERED_BIT;
+			ret = get_module_mode_ready_state(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_GET_MODULE_OPER_BM_COMMONPOPULATED:
+			rd =  NAI_MODULE_COMMON_OPERSTATE_BM_COMMONPOPULATED_BIT;
+			ret = get_module_mode_ready_state(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_GET_MODULE_OPER_BM_PARAM_LOADED:
+			rd = NAI_MODULE_COMMON_OPERSTATE_BM_PARAM_LOADED_BIT;
+			ret = get_module_mode_ready_state(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_GET_MODULE_OPER_BM_CALIB_LOADED:
+			rd = NAI_MODULE_COMMON_OPERSTATE_BM_CALIB_LOADED_BIT;
+			ret = get_module_mode_ready_state(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_GET_MODULE_OPER_BM_RDY:    			
+			rd = NAI_MODULE_COMMON_OPERSTATE_BM_READY_BIT;
+			ret = get_module_mode_ready_state(dev, (nai_module_op __user *)arg, rd);
+			break;
+		case NAI_IOC_SERDES_WR_MICRO:    			
+			op = NAI_MODULE_MICRO_WRITE;
+			ret = rdwr_module_micro(dev, (nai_serdes_module_micro *)arg, op);
+			break;
+		case NAI_IOC_SERDES_GET_MICRO: 
+			op = NAI_MODULE_MICRO_GET;
+			ret = rdwr_module_micro(dev, (nai_serdes_module_micro *)arg, op);
+			break; 		
+		case NAI_IOC_SERDES_ERASE_MICRO: 
+			op = NAI_MODULE_MICRO_ERASE;
+			ret = rdwr_module_micro(dev, (nai_serdes_module_micro *)arg, op);
+			break;
+      case NAI_IOC_GET_MODULE_SERDES_REVISION: 
+			ret = get_serdes_module_revision((nai_module_serdes_revision *)arg);
+			break; 	   
+		default:
+			ret = -ENOTTY;
+			break;
+		}
+
+		up_write(&dev->rwsem);
+	}
+exit:
+	return ret;
+}
+
+static const struct file_operations nai_serdes_fops = {
+	.open           = nai_serdes_open,
+	.release        = nai_serdes_release,
+	.unlocked_ioctl = nai_serdes_ioctl,
+	.compat_ioctl   = nai_serdes_ioctl,
+};
+
+static const struct of_device_id of_nai_mb_serdes_match[] = {
+	{ .compatible = NAI_DRV_NAME_VER, },
+	{},
+};
+
+static int nai_serdes_probe(struct platform_device *pdev)
+{
+   int ret = 0;
+   struct nai_serdes_dev *dev = NULL;   
+   struct device_node *pNode, *cNode;
+#ifdef DEBUG_IT
+   pr_info("!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+#endif
+   dev_info(&pdev->dev, "%s\n",__func__);
+   
+   /* Allocate and initialize device */
+   dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+   if (!dev)
+   {
+      ret = -ENOMEM;
+      goto exit;
+   }
+   memset(dev, 0, sizeof(*dev));
+
+   /* Initialize sem */
+   init_rwsem(&dev->rwsem);
+
+   /* Initialize and register miscdevice */
+   dev->miscdev.name = NAI_MISC_DEV_NAME;
+   dev->miscdev.minor = MISC_DYNAMIC_MINOR;
+   dev->miscdev.fops = &nai_serdes_fops;
+   ret = misc_register((struct miscdevice *)dev);
+   if (ret)
+   {
+      dev_err(&pdev->dev, "Failed to allocate misc device\n");
+      goto err_misc;
+   }
+#ifdef DEBUG_IT
+   else
+   {
+      pr_info("misc_register '%s' OK\n",NAI_MISC_DEV_NAME);
+   }
+#endif
+
+   //get the parent node of the compatible device
+   pNode = of_find_compatible_node(NULL, NULL, NAI_DRV_NAME_VER);
+   if(!pNode) {
+      dev_err(&pdev->dev, "Unable to find compatible %s in DTB \n", NAI_DRV_NAME_VER);
+      goto err_find_comp_node;
+   }
+#ifdef DEBUG_IT
+   else
+   {
+      pr_info("find compatible node '%s' OK\n",NAI_DRV_NAME_VER);
+   }
+#endif
+   
+   /* Map slow-access (i.e. software serdes) */
+   cNode = of_get_child_by_name(pNode, "slow-access");
+   if(cNode != NULL)
+   {
+      dev->swserdes_common_base = of_iomap(cNode,0);
+      if (!dev->swserdes_common_base)
+      {
+         dev_err(&pdev->dev, "Failed to map software serdes registers\n");
+         ret = -ENOMEM;
+         goto err_swserdes_res;
+      }
+#ifdef DEBUG_IT
+      else
+      {
+         pr_info("swserdes_common_base %p \n", dev->swserdes_common_base);
+         dev_info(&pdev->dev, "swserdes_common_base %p \n", dev->swserdes_common_base);
+      }
+#endif
+   }
+   else
+   {
+      goto err_swserdes_res; /* everything (all modules) should be capabale of SW SERDES */
+   }
+   
+   /* Map fast-access (i.e. hardware serdes) */
+   cNode = of_get_child_by_name(pNode, "fast-access");
+   if(cNode != NULL)
+   {
+      dev->hwserdes_common_base = of_iomap(cNode,0);
+      if (!dev->hwserdes_common_base)
+      {
+         dev_err(&pdev->dev, "Failed to map hardware serdes registers\n");
+         ret = -ENOMEM;
+         goto err_hwserdes_res;
+      }
+#ifdef DEBUG_IT
+      else
+      {
+         pr_info("hwserdes_common_base %p\n", dev->hwserdes_common_base);
+         dev_info(&pdev->dev, "hwserdes_common_base %p\n", dev->hwserdes_common_base);
+      }
+#endif
+   }
+   else
+   {
+      dev->hwserdes_common_base = NULL;
+   }   
+
+   /* Map module-pkt-cfg (i.e. module configuration modules used for serdes packets) */
+   cNode = of_get_child_by_name(pNode, "module-pkt-cfg");
+   if(cNode != NULL)
+   {
+      dev->modpktconfig_base = of_iomap(cNode,0);
+      if (!dev->modpktconfig_base)
+      {
+         dev_err(&pdev->dev, "Failed to map module serdes packet configuration registers\n");
+         ret = -ENOMEM;
+         goto err_modpktconfig_res;
+      }
+#ifdef DEBUG_IT
+      else
+      {
+         pr_info("modpktconfig_base %p\n", dev->modpktconfig_base);
+         dev_info(&pdev->dev, "modpktconfig_base %p\n", dev->modpktconfig_base);
+      }
+#endif
+   }
+   else
+   {
+      dev->modpktconfig_base = NULL;
+   }      
+
+   /* Set base address for util and oper code 
+    * NOTE: Seperate base addresses are used for 16 and 32 bit access
+    * 32 bit access uses hardware for forming serdes packets 
+    * 16 bit still uses software for forming serdes packets */
+   nai_set_virtual_base_sw(dev->swserdes_common_base);  /* 16 bit access will still use original software packetizing method */ 
+   nai_set_virtual_base_hw(dev->hwserdes_common_base);  /* 32 bit access will now use new hardware packetizing method */   
+   nai_set_virtual_base_module_pkt_config(dev->modpktconfig_base); /* Module Serdes Packet Configuration */
+   
+   /* Save misc device in platform dev */
+   platform_set_drvdata(pdev, dev);
+#ifdef DEBUG_IT
+   pr_info("!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+#endif
+   return 0;
+err_swserdes_res:
+   iounmap(dev->swserdes_common_base);   
+err_hwserdes_res:
+   iounmap(dev->hwserdes_common_base);      
+err_modpktconfig_res:
+   iounmap(dev->modpktconfig_base);
+err_find_comp_node:
+   misc_deregister((struct miscdevice *)dev);
+err_misc:
+   kfree(dev);
+exit:
+   return ret;
+}
+
+static int nai_serdes_remove(struct platform_device *pdev)
+{
+   struct nai_serdes_dev *dev = platform_get_drvdata(pdev);
+
+   platform_set_drvdata(pdev, NULL);
+   nai_set_virtual_base_hw(NULL);
+   nai_set_virtual_base_sw(NULL);
+   misc_deregister((struct miscdevice *)dev);
+   kfree(dev);
+
+   return 0;
+}
+
+static struct platform_driver nai_serdes_drv =
+{
+   .driver   = {
+      .name  = NAI_DRV_NAME_VER,
+      .owner = THIS_MODULE,
+      .of_match_table = of_match_ptr(of_nai_mb_serdes_match),
+   },
+   .probe    = nai_serdes_probe,
+   .remove   = nai_serdes_remove,
+};
+
+static int __init nai_serdes_init(void) {
+   return platform_driver_register(&nai_serdes_drv);
+}
+
+
+static void __exit nai_serdes_exit(void) {
+   platform_driver_unregister(&nai_serdes_drv);
+}
+
+module_init(nai_serdes_init);
+module_exit(nai_serdes_exit);
+
+MODULE_AUTHOR("Obi Okafor <ookafor@naii.com>");
+MODULE_DESCRIPTION("NAI SERDES driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/nai_serdes.h b/drivers/misc/nai_serdes.h
new file mode 100644
index 0000000..a7eab35
--- /dev/null
+++ b/drivers/misc/nai_serdes.h
@@ -0,0 +1,230 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAI_SERDES_H__
+#define __NAI_SERDES_H__
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Error Codes */
+#define NAI__SUCCESS 				       		 0
+#define NAI_ERROR_WRONG_SLOT_NUM 		       	-8201
+#define NAI_INVALID_SLOT_ID			       		-8202
+#define NAI_SERDES_UNEXPECTED_PAYLOAD_COUNT     -8203
+#define NAI_MODULE_NOT_FOUND			       	-8204
+#define NAI_MIS_ALIGNED_BYTE_ENABLE             -8205
+#define NAI_INVALID_PARAMETER_VALUE		       	-8206
+#define NAI_SYSTEM_NOT_READY			       	-8207
+#define NAI_MODULE_NOT_READY			       	-8208
+#define NAI_UNABLE_TO_ALLOCATE_MEMORY		    -8209
+#define NAI_COMMAND_NOT_RECOGNIZED		       	-8210
+#define NAI_TX_FIFO_NOT_EMPTY_TIMEOUT	        -8211
+#define NAI_RX_FIFO_PKT_NOT_READY_TIMEOUT       -8212
+#define NAI_DETECT_MODULES_TIMEOUT		       	-8213
+#define NAI_I2C_DEVICE_NOT_FOUND		       	-8214
+#define NAI_UNABLE_TO_LOCK_MUTEX   	   	       	-8215
+#define NAI_UNABLE_TO_UNLOCK_MUTEX		       	-8216
+#define NAI_STRIDE_CAUSES_MISALIGNMENT			-8217
+#define NAI_USER_COPY_FAILED					-8218
+#define NAI_MODULE_DETECT_READY_TIMEOUT			-8219
+#define NAI_MODULE_LINK_DETECT_TIMEOUT			-8220
+#define NAI_ENTER_CONFIG_MODE_TIMEOUT       	-8221
+#define NAI_STM_TX_TIMEOUT						-8222
+#define NAI_STM_RX_TIMEOUT						-8223
+#define NAI_ACK_NOT_RECEIVED					-8224
+#define NAI_POTENTIAL_BUFFER_OVERRUN			-8225
+#define NAI_CPLD_PROGRAMMING_ERROR				-8226
+#define NAI_INVALID_PAYLOAD_LENGTH				-8227
+#define NAI_INVALID_PACKET_TYPE					-8228
+#define NAI_RESPONSE_COMMAND_MISMATCH			-8229
+#define NAI_COMMAND_FAILED				    	-8230
+#define NAI_NOT_SUPPORTED						-8231
+#define NAI_INVALID_ADDRESS						-8232
+
+/* Misc */
+#define NAI_MB_SLOT				       	   0x00
+#define NAI_MODULE_1_SLOT			       0x01
+#define NAI_MODULE_2_SLOT			       0x02
+#define NAI_MODULE_3_SLOT			       0x03
+#define NAI_MODULE_4_SLOT			       0x04
+#define NAI_MODULE_5_SLOT			       0x05
+#define NAI_MODULE_6_SLOT			       0x06
+#define NAI_PPC_MB_SLOT				       0x0A
+#define NAI_ASSIGNED_SLOT			       0xFE
+#define NAI_INVALID_SLOT			       0xFF
+
+#define NAI_MODULE_FLASH_READ			   0x01
+#define NAI_MODULE_FLASH_WRITE			   0x02
+#define NAI_MODULE_FLASH_ERASE			   0x03
+#define NAI_MODULE_MICRO_GET			   0x04
+#define NAI_MODULE_MICRO_WRITE			   0x05
+#define NAI_MODULE_MICRO_ERASE			   0x06
+
+/* Block Write*/
+#define NAI_MAX_COUNT_PER_WRITE			   400000
+
+
+typedef struct _nai_serdes_slot {
+	__s32 slot;
+	__s32 rc;
+} nai_serdes_slot;
+
+typedef struct _nai_serdes_addr {
+       __u32 addr[8];
+       __s32 rc;
+} nai_serdes_addr;
+
+typedef struct _nai_serdes_16 {
+	__s32 slot;
+        __u32 addr;
+	__u16 val;
+	__s32 rc;
+} nai_serdes_16;
+
+typedef struct _nai_serdes_32 {
+	__s32 slot;
+	__u32 addr;
+	__u32 val;
+	__s32 rc;
+} nai_serdes_32;
+
+typedef struct _nai_serdes_blk_16 {
+	__s32 slot;
+	__u32 addr;
+	__u16 count;
+	__u8  stride;
+	__u16 *val;
+	__s32 rc;
+} nai_serdes_blk_16;
+
+typedef struct _nai_serdes_blk_32 {
+	__s32 slot;
+	__u32 addr;
+	__u16 count;
+	__u8  stride;
+	__u32 *val;
+	__s32 rc;
+} nai_serdes_blk_32;
+
+typedef struct _nai_serdes_blk_16_large {
+	__s32 slot;
+	__u32 addr;
+	__u32 count;
+	__u8  stride;
+	__u16 *val;
+	__s32 rc;
+} nai_serdes_blk_16_large;
+
+typedef struct _nai_serdes_blk_32_large {
+	__s32 slot;
+	__u32 addr;
+	__u32 count;
+	__u8  stride;
+	__u32 *val;
+	__s32 rc;
+} nai_serdes_blk_32_large;
+
+typedef struct _nai_serdes_module_eeprom {
+	__u16 chipId;
+	__u8 reqId;
+	__u8 compId;
+	__u32 eepromOffset;
+	__u8 *buff;
+	__s32 len;
+	__s32 rc;
+} nai_serdes_module_eeprom;
+
+typedef struct _nai_serdes_module_flash {
+	__u8 reqId;
+	__u8 compId;
+	__u32 flashOffset;
+	__u8 numPage;
+	__u8 *buff;
+	__s32 len;
+	__s32 rc;
+} nai_serdes_module_flash;
+
+typedef struct _nai_serdes_module_micro {
+	__u8 reqId;
+	__u8 compId;
+	__u8 channel;	
+	__u32 flashOffset;	
+	__u8 *buff;
+	__s32 len;
+	__s32 rc;
+} nai_serdes_module_micro;
+
+typedef struct _nai_module_op {
+	__u32 slot;
+	__u32 enable;
+	__s32 rc;
+} nai_module_op;
+
+typedef struct _nai_module_serdes_revision {
+	__u8 serdesMajorRev;
+	__u8 serdesMinorRev;
+} nai_module_serdes_revision;
+
+#define NAI_SERDES_MAGIC            0xDD
+
+#define NAI_IOC_SERDES_SET_SLOTID _IOWR(NAI_SERDES_MAGIC, 1,  nai_serdes_slot)
+#define NAI_IOC_SERDES_INIT_ADDR  _IOW (NAI_SERDES_MAGIC, 2,  nai_serdes_addr)
+#define NAI_IOC_SERDES_RD_REG16   _IOWR(NAI_SERDES_MAGIC, 3,  nai_serdes_16)
+#define NAI_IOC_SERDES_WR_REG16   _IOWR(NAI_SERDES_MAGIC, 4,  nai_serdes_16)
+#define NAI_IOC_SERDES_RD_REG32   _IOWR(NAI_SERDES_MAGIC, 5,  nai_serdes_32)
+#define NAI_IOC_SERDES_WR_REG32   _IOWR(NAI_SERDES_MAGIC, 6,  nai_serdes_32)
+#define NAI_IOC_SERDES_RD_BLK16   _IOWR(NAI_SERDES_MAGIC, 7,  nai_serdes_blk_16)
+#define NAI_IOC_SERDES_WR_BLK16   _IOWR(NAI_SERDES_MAGIC, 8,  nai_serdes_blk_16)
+#define NAI_IOC_SERDES_RD_BLK32   _IOWR(NAI_SERDES_MAGIC, 9,  nai_serdes_blk_32)
+#define NAI_IOC_SERDES_WR_BLK32   _IOWR(NAI_SERDES_MAGIC, 10, nai_serdes_blk_32)
+
+#define NAI_IOC_SERDES_RD_MODULE_EEPROM   			_IOWR(NAI_SERDES_MAGIC, 11, nai_serdes_module_eeprom)
+#define NAI_IOC_SERDES_WR_MODULE_EEPROM   			_IOWR(NAI_SERDES_MAGIC, 12, nai_serdes_module_eeprom)
+#define NAI_IOC_SERDES_ERASE_MODULE_FLASH   		_IOWR(NAI_SERDES_MAGIC, 13, nai_serdes_module_flash)
+#define NAI_IOC_SERDES_RD_MODULE_FLASH   			_IOWR(NAI_SERDES_MAGIC, 14, nai_serdes_module_flash)
+#define NAI_IOC_SERDES_WR_MODULE_FLASH   			_IOWR(NAI_SERDES_MAGIC, 15, nai_serdes_module_flash)
+#define NAI_IOC_GET_MODULE_DETECTED  				_IOWR(NAI_SERDES_MAGIC, 16, nai_module_op)
+#define NAI_IOC_GET_MODULE_LINK_INIT 				_IOWR(NAI_SERDES_MAGIC, 17, nai_module_op)
+#define NAI_IOC_SET_MODULE_RESET     				_IOW (NAI_SERDES_MAGIC, 18, nai_module_op)
+#define NAI_IOC_SET_MODULE_CONFIG_MODE    			_IOWR(NAI_SERDES_MAGIC, 19, nai_module_op)
+#define NAI_IOC_CLR_MODULE_CONFIG_MODE    			_IOWR(NAI_SERDES_MAGIC, 20, nai_module_op)
+#define NAI_IOC_GET_MODULE_CONFIG_STATE_RQ_ACK		_IOWR(NAI_SERDES_MAGIC, 21, nai_module_op)
+#define NAI_IOC_GET_MODULE_CONFIG_STATE_RDY   		_IOWR(NAI_SERDES_MAGIC, 22, nai_module_op)
+#define NAI_IOC_GET_MODULE_OPER_BM_ENTERED    		_IOWR(NAI_SERDES_MAGIC, 23, nai_module_op)
+#define NAI_IOC_GET_MODULE_OPER_BM_COMMONPOPULATED  _IOWR(NAI_SERDES_MAGIC, 24, nai_module_op)
+#define NAI_IOC_GET_MODULE_OPER_BM_PARAM_LOADED  	_IOWR(NAI_SERDES_MAGIC, 25, nai_module_op)
+#define NAI_IOC_GET_MODULE_OPER_BM_CALIB_LOADED    	_IOWR(NAI_SERDES_MAGIC, 26, nai_module_op)
+#define NAI_IOC_GET_MODULE_OPER_BM_RDY    			_IOWR(NAI_SERDES_MAGIC, 27, nai_module_op)
+#define NAI_IOC_SERDES_WR_MICRO					    _IOWR(NAI_SERDES_MAGIC, 28, nai_serdes_module_micro)
+#define NAI_IOC_SERDES_GET_MICRO				   	_IOWR(NAI_SERDES_MAGIC, 29, nai_serdes_module_micro)
+#define NAI_IOC_SERDES_ERASE_MICRO				   	_IOWR(NAI_SERDES_MAGIC, 30, nai_serdes_module_micro)
+#define NAI_IOC_KILL_MODULE_SERDES				   	_IOWR(NAI_SERDES_MAGIC, 31, nai_module_op)
+#define NAI_IOC_GET_MODULE_SERDES_REVISION		   	_IOR(NAI_SERDES_MAGIC, 32,  nai_module_serdes_revision)
+#define NAI_IOC_SERDES_RD_BLK16_LARGE              	_IOWR(NAI_SERDES_MAGIC, 33, nai_serdes_blk_16_large)
+#define NAI_IOC_SERDES_WR_BLK16_LARGE              	_IOWR(NAI_SERDES_MAGIC, 34, nai_serdes_blk_16_large)
+#define NAI_IOC_SERDES_RD_BLK32_LARGE              	_IOWR(NAI_SERDES_MAGIC, 35, nai_serdes_blk_32_large)
+#define NAI_IOC_SERDES_WR_BLK32_LARGE              	_IOWR(NAI_SERDES_MAGIC, 36, nai_serdes_blk_32_large)
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __NAI_SERDES_H__ */
diff --git a/drivers/misc/nai_serdes_config.c b/drivers/misc/nai_serdes_config.c
new file mode 100644
index 0000000..a234027
--- /dev/null
+++ b/drivers/misc/nai_serdes_config.c
@@ -0,0 +1,1049 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/semaphore.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/decompress/mm.h>
+
+#include "nai_serdes.h"
+#include "nai_serdes_prv.h"
+#include "nai_serdes_utils.h"
+#include "nai_serdes_config.h"
+#include "nai_serdes_oper.h"
+
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+
+static u16 g_usTranID = 1;
+static bool g_bLock = false;
+
+/* Isolated DT Globals */
+#define NUM_DT_CHANNELS 16
+const uint8_t ALL_CHANNELS = 0xFF;
+
+/* MessageCreation */
+static MsgPacket * create_nai_msg_packet(u16* pusData);
+static MsgPacketList * create_nai_msg_packet_list(void);
+static MsgPacketList * find_nai_msg_packet_list(MsgList *ptMsgList, u16 usTranID);
+static void init_nai_msgs(MsgList *ptMsgList);
+static void create_and_append_nai_msg_packet(MsgPacketList *ptMsgPacketList, u16* pusData);
+static void delete_nai_msg_packets(MsgPacketList *ptMsgPacketList);
+static void add_nai_msg(MsgList *ptMsgList, MsgPacketList *ptMsgPacketList);
+static void delete_nai_msgs(MsgList *ptMsgList);
+
+/* PrintMessage */
+#ifdef _VERBOSE
+static void print_nai_msgs(MsgList *ptMsgList, bool bPrintPayLd);
+static void print_nai_msg(MsgPacketList *ptMsgPacketList, bool bPrintPayLd);
+static void print_nai_msg_payload(MsgPacket *ptMsgPacket);
+#endif
+
+/* MessageValidation */
+static s32 compute_nai_msg_crc(MsgPacketList *ptMsgPacketList);
+static s32 validate_nai_msgs(MsgList *ptMsgList);
+static s32 validate_nai_msg(MsgPacketList *ptMsgPacketList);
+
+/* MessageProcessing */
+static bool nai_msg_requires_finished_response(MsgPacketList *ptMsgPacketList);
+static u32  nai_get_completion_timeout(MsgPacket *ptMsgPacket);
+
+static s32 nai_send_msg(MsgPacketList *ptMsgPackets);
+static s32 nai_receive_msg_packet(u8 ucRequesterID, u8 ucCompleterID, MsgList *ptMsgList);
+static u8 nai_get_serdes_completer_id(MsgPacket *ptMsgPacket);
+static u8 nai_get_serdes_requester_id(MsgPacket *ptMsgPacket);
+static u16 calculate_nai_expected_sequence_count(s32 ulPayloadWordLength);
+
+/* We provide higher level calls so no need to expose the inner workings of actual read or write requests */
+static s32 make_read_request(u16 usCommandType, u8 ucRequesterID, u8 ucCompleterID, u16 usChipID, u32 unOffset, u8 *pucBuf, s32 nLen);
+static s32 make_write_request(u16 usCommandType, u8 ucRequesterID, u8 ucCompleterID, u16 usChipID, u32 unEepromOffset, u8 *pucBuf, s32 nLen);
+static void* aligned_malloc(size_t size, size_t alignment);
+static void aligned_free(void* p);
+static u16 get_next_tran_id(void);
+
+static void* aligned_malloc(size_t size, size_t alignment) {
+
+    uintptr_t r = (uintptr_t)malloc(size + --alignment + sizeof(uintptr_t));
+    uintptr_t t = r + sizeof(uintptr_t);
+    uintptr_t o =(t + alignment) & ~(uintptr_t)alignment;
+
+    if (!r) 
+		return NULL;
+
+    ((uintptr_t*)o)[-1] = r;
+
+    return (void*)o;
+}
+
+static void aligned_free(void* p) {
+
+    if (!p) 
+		return;
+
+    free((void*)(((uintptr_t*)p)[-1]));
+}
+
+static u16 get_next_tran_id(void)
+{
+	static u16 usTranID = 0;
+	if (!g_bLock)
+	{
+		g_bLock = true;
+		g_usTranID++;
+		
+		if (g_usTranID >= 32767)
+			g_usTranID = 1;
+		usTranID = g_usTranID;
+		g_bLock = false;
+	}
+
+	return usTranID;
+}
+
+static MsgPacket * create_nai_msg_packet(u16* pusData)
+{
+//	MsgPacket *ptNewMsgPacket = malloc(sizeof(MsgPacket));
+	MsgPacket *ptNewMsgPacket = aligned_malloc(sizeof(MsgPacket), 4);
+
+#ifdef _DEBUG_X
+	s32 i=0;
+
+	for (i=0; i < MAX_SERDES_MSG_IN_WORDS; i++)
+		printk("usData[%d] = 0x%4.4x\r\n", i, pusData[i]);
+#endif
+	memcpy(ptNewMsgPacket->tNAIMsg.msg, pusData, (MAX_SERDES_MSG_IN_WORDS*2));
+	ptNewMsgPacket->ptNext = NULL;
+
+	return ptNewMsgPacket;
+}
+
+static MsgPacketList * create_nai_msg_packet_list()
+{
+//	MsgPacketList *ptNewMsgPacketList = malloc(sizeof(MsgPacketList));
+	MsgPacketList *ptNewMsgPacketList = aligned_malloc(sizeof(MsgPacketList), 4);
+		
+	ptNewMsgPacketList->ptStart = NULL;
+	ptNewMsgPacketList->ptEnd = ptNewMsgPacketList->ptStart;
+	ptNewMsgPacketList->ptNext = NULL;
+	ptNewMsgPacketList->nCount = 0;
+
+	return ptNewMsgPacketList;
+}
+
+static MsgPacketList * find_nai_msg_packet_list(MsgList *ptMsgList, u16 usTranID)
+{
+	MsgPacketList *ptTraverse = ptMsgList->ptStart;
+
+	while (ptTraverse != NULL)
+	{					
+		if (ptTraverse->ptStart->tNAIMsg.tSerdesPayLd.tTransportHdr.usID == usTranID)
+		{
+#ifdef _VERBOSE
+			printk("Found Transport ID: 0x%4x\r\n", ptTraverse->ptStart->tNAIMsg.tSerdesPayLd.tTransportHdr.usID);
+#endif
+			break;
+		}
+		ptTraverse = ptTraverse->ptNext;
+	}	
+
+	return ptTraverse;
+}
+
+static void init_nai_msgs(MsgList *ptMsgList)
+{
+	ptMsgList->ptStart = NULL;
+	ptMsgList->ptEnd = ptMsgList->ptStart;
+	ptMsgList->nCount = 0;	
+}
+
+static void create_and_append_nai_msg_packet(MsgPacketList *ptMsgPacketList, u16* pusData)
+{	
+	MsgPacket *ptNewMsgPacket = create_nai_msg_packet(pusData);
+
+#ifdef _VERBOSE
+	printk("Trans ID: %u Adding New Msg Packet - Sequence #: %u\r\n", 
+				ptNewMsgPacket->tNAIMsg.tSerdesPayLd.tTransportHdr.usID, 
+				ptNewMsgPacket->tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum);
+#endif
+
+	if (ptMsgPacketList->ptEnd == NULL)
+	{
+		ptMsgPacketList->ptStart = ptNewMsgPacket;
+	  	ptMsgPacketList->ptEnd = ptMsgPacketList->ptStart;
+	}
+	else
+	{
+		ptMsgPacketList->ptEnd->ptNext = ptNewMsgPacket;
+		ptMsgPacketList->ptEnd = ptNewMsgPacket;
+	}
+
+	ptMsgPacketList->nCount++;
+}
+
+static void delete_nai_msg_packets(MsgPacketList *ptMsgPacketList)
+{
+	MsgPacket *ptTraverse = NULL;	
+	
+	while (ptMsgPacketList->ptStart != NULL)
+	{
+		ptTraverse = ptMsgPacketList->ptStart;
+		ptMsgPacketList->ptStart = ptMsgPacketList->ptStart->ptNext;		
+//		free(ptTraverse);
+		aligned_free(ptTraverse);
+		ptMsgPacketList->nCount--;			
+	}
+}
+
+static void add_nai_msg(MsgList *ptMsgList, MsgPacketList *ptMsgPacketList)
+{
+#ifdef _VERBOSE
+	printk("Adding New Msg - Num of Packets: %u\r\n", ptMsgPacketList->ptEnd->tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum);
+#endif
+
+	if (ptMsgList->ptEnd == NULL)
+	{
+		ptMsgList->ptStart = ptMsgPacketList;
+	  	ptMsgList->ptEnd = ptMsgList->ptStart;
+	}
+	else
+	{
+		ptMsgList->ptEnd->ptNext = ptMsgPacketList;
+		ptMsgList->ptEnd = ptMsgPacketList;
+	}
+
+	ptMsgList->nCount++;
+}
+
+static void delete_nai_msgs(MsgList *ptMsgList)
+{
+	MsgPacketList *ptTraverse = NULL;
+	
+	while (ptMsgList->ptStart != NULL)
+	{
+		ptTraverse = ptMsgList->ptStart;
+		ptMsgList->ptStart = ptMsgList->ptStart->ptNext;
+		delete_nai_msg_packets(ptTraverse);
+//		free(ptTraverse);
+		aligned_free(ptTraverse);
+		ptMsgList->nCount--;
+	}
+}
+
+#ifdef _VERBOSE
+static void print_nai_msgs(MsgList *ptMsgList, bool bPrintPayLd)
+{
+	MsgPacketList *ptTraverse = ptMsgList->ptStart;
+
+	printk("\r\n******************************************************************\r\n");
+	printk("Printing NAI Messages\r\n");
+	printk("Total Num of Messages In Memory: %d\r\n", (int)ptMsgList->nCount);
+
+	while (ptTraverse != NULL)
+	{
+		print_nai_msg(ptTraverse, bPrintPayLd);
+		ptTraverse = ptTraverse->ptNext;
+	}
+	printk("\r\n******************************************************************\r\n");
+}
+
+static void print_nai_msg(MsgPacketList *ptMsgPacketList, bool bPrintPayLd)
+{
+
+	MsgPacket *ptTraverse = ptMsgPacketList->ptStart;	
+	s32 nMsgPacketCount = 0;
+	
+	if (ptMsgPacketList == NULL)
+		return;
+	
+	printk("\r\n******************************************************************\r\n");
+	printk("Printing Msg Contents - Total Num Packets in Msg = %d\r\n", (int)ptMsgPacketList->nCount);
+
+	while (ptTraverse != NULL)
+	{
+		nMsgPacketCount++;
+		printk("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\r\n");
+		printk("Msg Packet #:     %d\r\n", (unsigned int)nMsgPacketCount);
+		printk("Serdes CmdType:   0x%4.4x - (%u)\r\n", ptTraverse->tNAIMsg.tSerdesHdr.ucType, ptTraverse->tNAIMsg.tSerdesHdr.ucType);
+		printk("Serdes Length:    0x%4.4x - (%u)\r\n", (ptTraverse->tNAIMsg.tSerdesHdr.ucPayloadLength), (ptTraverse->tNAIMsg.tSerdesHdr.ucPayloadLength));
+		printk("Transport ID:     0x%4.4x - (%u)\r\n", ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usID, ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usID);
+		printk("Transport Length: 0x%8.4x - (%u)\r\n", (unsigned int)ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength, (unsigned int)ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength);
+		printk("Transport Seq #:  0x%4.4x - (%u)\r\n", ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum, ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum);
+		printk("Transport Expected Seq Count:  0x%4.4x - (%u)\r\n", ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount, ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount);
+		printk("Msg CRC: 0x%8.4x - (%u)\r\n", (unsigned int)ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.unCRC, (unsigned int)ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.unCRC);
+
+		if (bPrintPayLd)
+			print_nai_msg_payload(ptTraverse);
+
+		printk("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\r\n");
+
+		ptTraverse = ptTraverse->ptNext;
+	}	
+	printk("******************************************************************\r\n");
+}
+
+
+static void print_nai_msg_payload(MsgPacket *ptMsgPacket)
+{
+	s32 i = 0;
+	u16 usPayloadLengthInWords = 0;
+
+	if (ptMsgPacket != NULL)
+	{
+		usPayloadLengthInWords = convert_bytes_to_words(ptMsgPacket->tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength);
+		printk("Payload Length (in WORDS): %u\r\n", usPayloadLengthInWords);
+		
+		for (i=0; i < usPayloadLengthInWords; i++)		
+			printk("Msg Payload[%d] = %4.4x\r\n", (unsigned int)i, (unsigned short)ptMsgPacket->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[i]);	
+	}
+}
+#endif
+
+static s32 compute_nai_msg_crc(MsgPacketList *ptMsgPacketList)
+{
+	s32 unCRC = 0;
+
+#ifdef _COMPUTE_CRC
+	MsgPacket *ptTraverse = ptMsgPacketList->ptStart;
+	NAIMsg *ptMsgCopy = NULL;
+//	ptMsgCopy = (NAIMsg *)malloc(sizeof(NAIMsg));
+	ptMsgCopy = (NAIMsg *)aligned_malloc(sizeof(NAIMsg), 4);
+
+	while (ptTraverse != NULL)
+	{	
+		/* Let's make sure our buffer is all zero to start */
+		memset(ptMsgCopy->msg, 0, sizeof(NAIMsg));
+
+		/* Make a copy of the message we want to perform a CRC on...we do this because we need to 
+           strip some information that is ok to change during transit before we compute the CRC */
+		memcpy(ptMsgCopy->msg, ptTraverse->tNAIMsg.msg, sizeof(NAIMsg));
+		ptMsgCopy->tSerdesHdr.usSERDES0 &= 0x3F; /* This zeros out SeqNumRx (bit 7) and SeqNumTx (bit 6) */
+		ptMsgCopy->tSerdesHdr.usSERDES4 &= 0x0F; /* This zeros out COMPLETER_ID (bits 4 - 7) */
+		ptMsgCopy->tSerdesPayLd.tTransportHdr.unCRC = 0; /* Do not take CRC into account when computing CRC (since it is not present when we 1st calculate CRC */
+
+		unCRC = crc32(unCRC, (void *)ptMsgCopy->msg, ptMsgCopy->tSerdesHdr.ucPayloadLength);
+		ptTraverse = ptTraverse->ptNext;
+	}
+#else
+#ifdef _VERBOSE
+	printk("***COMPUTING OF CRC HAS BEEN TURNED OFF***\r\n");	
+#endif
+#endif
+	return unCRC;
+}
+
+
+
+static s32 validate_nai_msgs(MsgList *ptMsgList)
+{
+	s32 nStatus = NAI__SUCCESS;
+	s32 nTempStatus = NAI__SUCCESS;
+	MsgPacketList *ptTraverse = ptMsgList->ptStart;
+
+	while ( (ptTraverse != NULL) && (nStatus == NAI__SUCCESS) )
+	{
+		nTempStatus = validate_nai_msg(ptTraverse);
+		if (nTempStatus != NAI__SUCCESS)
+			nStatus = nTempStatus;
+		ptTraverse = ptTraverse->ptNext;
+	}
+
+	return nStatus;
+}
+
+static s32 validate_nai_msg(MsgPacketList *ptMsgPacketList)
+{
+	s32 nStatus = NAI__SUCCESS;
+#ifdef _VALIDATE_CRC
+	s32 unMsgCRC = 0;
+
+	unMsgCRC = compute_nai_msg_crc(ptMsgPacketList);
+	if (unMsgCRC > 0 && unMsgCRC == ptMsgPacketList->ptStart->tNAIMsg.tSerdesPayLd.tTransportHdr.unCRC)
+	{
+#ifdef _VERBOSE
+		printk("Transport ID: 0x%4.4x PASSED CRC! - Calculated: 0x%8.4x  Expected: 0x%8.4x\r\n", ptMsgPacketList->ptStart->tNAIMsg.tSerdesPayLd.tTransportHdr.usID, unMsgCRC, ptMsgPacketList->ptStart->tNAIMsg.tSerdesPayLd.tTransportHdr.unCRC);
+#endif
+	}		
+	else
+	{
+#ifdef _VERBOSE
+		printk("**Transport ID: 0x%4.4x FAILED CRC!** - Calculated: %8.4x  Expected: %8.4x\r\n", ptMsgPacketList->ptStart->tNAIMsg.tSerdesPayLd.tTransportHdr.usID, unMsgCRC, ptMsgPacketList->ptStart->tNAIMsg.tSerdesPayLd.tTransportHdr.unCRC);
+#endif
+		nStatus = -1;
+	}
+#else
+#ifdef _VERBOSE
+		printk("**VALIDATION OF CRC IS TURNED OFF**\r\n");
+#endif
+#endif
+	return nStatus;
+}
+
+
+static bool nai_msg_requires_finished_response(MsgPacketList *ptMsgPacketList)
+{
+	bool bRequiresResponse = false;		
+	MsgPacket *ptMsgPacket = NULL;
+
+	if (ptMsgPacketList != NULL)
+	{
+		ptMsgPacket = ptMsgPacketList->ptStart;
+		if (ptMsgPacket != NULL)
+		{
+			switch (ptMsgPacket->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType)
+			{
+				case COMMAND_TYPECODE_WRITEEEPROM :
+				case COMMAND_TYPECODE_ERASEFLASH  :
+				case COMMAND_TYPECODE_WRITEFLASH  :
+				case COMMAND_TYPECODE_CONFIG_MICRO :
+				case COMMAND_TYPECODE_ERASE_MICRO  :
+					bRequiresResponse = true;				
+					break;
+
+				default:
+					bRequiresResponse = false;
+					break;
+			}
+		}
+	}
+
+	return bRequiresResponse;
+}
+
+static s32 nai_send_msg(MsgPacketList *ptMsgPackets)
+{
+	s32 nStatus = NAI__SUCCESS;
+	bool bWaitForStatusReply = false;
+	s32 i = 0;
+	volatile s32 unAddr = 0;
+	volatile s32 unBeginTxAddr = 0; 
+	s32 nNumLoops = 0; 
+	s32 unMsgCRC = 0;
+	u8 ucCompleterID = 0;
+	u8 ucRequesterID = 0;
+	s32 ulTimer = 0;
+	MsgList tMsgList;
+	MsgPacket *ptTraverse = NULL;
+	uint32_t unCompletionTimeout = 0;
+	
+#ifdef _DEBUG_X
+	s32 unTemp = 0;
+#endif
+
+#ifdef _VERBOSE
+	s32 nLoopCount = 0;
+	printk("**************nai_send_msg**************\r\n");
+	printk("Sending cmd: %x\n", ptMsgPackets->ptStart->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType);
+#endif
+
+	bWaitForStatusReply = nai_msg_requires_finished_response(ptMsgPackets);
+	unMsgCRC = compute_nai_msg_crc(ptMsgPackets);
+	ptTraverse = ptMsgPackets->ptStart;
+	
+	while (ptTraverse != NULL)
+	{
+		ucRequesterID = nai_get_serdes_requester_id(ptTraverse);
+		ucCompleterID = nai_get_serdes_completer_id(ptTraverse);
+
+#ifdef _VERBOSE
+		if (nLoopCount == 0)
+		{
+			printk("RequesterID = 0x%1x\r\n", ucRequesterID);			
+			printk("CompleterID = 0x%1x\r\n", ucCompleterID);
+		}
+		nLoopCount++;	
+#endif		
+		//ulTimer = nai_get_timer(0);
+		ulTimer = jiffies;
+		/* We have a message to send...but the FIFO is not ready...need to wait!*/	
+		while (!nai_tx_fifo_empty(ucRequesterID, ucCompleterID))
+		{
+			/* If FIFO did not get serviced within a reasonable amount of time..get out */
+			if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT)
+			{
+				nStatus = NAI_TX_FIFO_NOT_EMPTY_TIMEOUT;
+				break;
+			}	
+		}
+
+		if (nStatus != NAI__SUCCESS)
+			break;
+		
+		ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.unCRC = unMsgCRC; /* Store the calculated MSG CRC in each packet that makes up the entire MSG */			
+		unAddr = nai_get_tx_fifo_address(ucRequesterID, ucCompleterID);
+		unBeginTxAddr = nai_get_tx_fifo_pkt_ready_address(ucRequesterID, ucCompleterID);
+
+		nNumLoops = ((TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS + (ptTraverse->tNAIMsg.tSerdesHdr.ucPayloadLength))); /* TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS = 6 Words + Num Words in Serdes PayLoad */
+#ifdef _VERBOSE
+		printk("Sending Msg Sequence #: %u\r\n", ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum);
+		printk("Num Words for FIFO    : %d\r\n", nNumLoops); 
+#endif
+		for (i=0; i <nNumLoops; i++)
+		{
+			FIFOValue tFIFOVal;
+			tFIFOVal.usLoWord = ptTraverse->tNAIMsg.msg[i++];
+			tFIFOVal.usHiWord = ptTraverse->tNAIMsg.msg[i];
+
+#ifdef _DEBUG_X
+			printk("FIFO VAL = 0x%8x\r\n", tFIFOVal.unValue);
+#endif
+			nai_write32_SW(unAddr, tFIFOVal.unValue);
+		}
+
+		/* Now force transfer of data now that the FIFO is filled with current message*/
+		nai_write32_SW(unBeginTxAddr, (s32)1);
+		ptTraverse = ptTraverse->ptNext;				
+	}
+
+	/* OK - if we got here and no errors...then we need to wait to get completion status on the msg that was sent */
+	if (bWaitForStatusReply && (nStatus == NAI__SUCCESS))
+	{		
+		/*NOTE: Each command may have different requirements regarding how long they will take to complete.
+		 *      Hence, we now attempt to specify a reasonable wait time based upon our knowledge of how long
+		 *      a given command typically takes. */
+		unCompletionTimeout = nai_get_completion_timeout(ptMsgPackets->ptStart);
+				
+		/* Wait for packet! */
+		ulTimer = jiffies;
+		while (!nai_rx_fifo_pkt_ready(ucRequesterID, ucCompleterID))
+		{
+			/* If FIFO did not get serviced within a reasonable amount of time..get out */
+			/* NOTE: We make this timeout longer than majority as we don't know how long module "should" take to fulfill request */
+			if (((s32)jiffies - (s32)ulTimer) > unCompletionTimeout)
+			{
+				nStatus = NAI_RX_FIFO_PKT_NOT_READY_TIMEOUT;
+				break;
+			}			
+		}	
+
+		if (nStatus == NAI__SUCCESS)	
+		{				
+			/* Prepare for response! */
+			init_nai_msgs(&tMsgList);
+			nStatus = nai_receive_msg_packet(ucRequesterID, ucCompleterID, &tMsgList);
+
+			if (nStatus == NAI__SUCCESS)
+			{
+#ifdef _VERBOSE
+				print_nai_msgs(&tMsgList, true);
+#endif
+				if (validate_nai_msgs(&tMsgList) == 0)
+				{
+					/* NOTE: Shound only have 1 message (1 packet) being returned */
+					MsgPacketList *ptFirstMsg = tMsgList.ptStart;
+					if (ptFirstMsg != NULL)
+					{
+						/* Extract the "Execution Status" out of the payload */
+						MsgPacket *ptTraverse = ptFirstMsg->ptStart;
+						if (ptTraverse != NULL && (ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength >= 2))
+						{			
+							FIFOValue tFIFOValue;
+							tFIFOValue.usLoWord = ptTraverse->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[0];
+							tFIFOValue.usHiWord = ptTraverse->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[1];
+							nStatus = (s32)tFIFOValue.unValue; 
+						}
+					}				
+				}
+			}
+
+			delete_nai_msgs(&tMsgList);
+		}
+	}
+
+#ifdef _VERBOSE
+	printk("**************END nai_send_msg**************\r\n");
+#endif
+
+	return nStatus;
+}
+
+static s32 nai_receive_msg_packet(u8 ucRequesterID, u8 ucCompleterID, MsgList *ptMsgList)
+{	
+	s32 nStatus = NAI__SUCCESS;
+	volatile s32 unAddr = 0;	
+	NAIMsg tReceiveMsg;
+	FIFOValue tFIFOVal;
+	s32 unWordsRead = 0;	
+	u16  usSerdesHdrWordsRead = 0;
+	s32 i = 0;
+	MsgPacketList *ptMsgPacketList = NULL;
+	u8 bAddMsgPacketList = 0;
+	u16 usPacketLength = 0;
+
+#ifdef _VERBOSE
+printk("**************nai_receive_msg_packet**************\r\n");
+#endif
+
+	if (ptMsgList == NULL)
+		return NAI_INVALID_PARAMETER_VALUE;
+
+	nai_rx_fifo_clear_pkt_ready(ucRequesterID, ucCompleterID);
+	memset(tReceiveMsg.msg, 0x0000, sizeof(tReceiveMsg.msg));
+
+	unAddr = nai_get_rx_fifo_address(ucCompleterID);
+
+	/* First we read just the SERDES Header info as we should be guaranteed this is present */
+    /* From there, we can determine how many words are part of this SERDES packet */
+	for (i=0; i < TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS; i++)
+	{	
+		tFIFOVal.unValue = nai_read32_SW(unAddr);	
+
+#ifdef _DEBUG_X
+//#ifdef _VERBOSE
+		printk("Read SERDES HDR FIFO Value: 0x%8x\r\n", tFIFOVal.unValue);
+#endif
+		tReceiveMsg.msg[i++] = 	tFIFOVal.usLoWord;
+		tReceiveMsg.msg[i] = tFIFOVal.usHiWord;
+		usSerdesHdrWordsRead += 2;
+	}
+		
+	/* Now we read enough to know how many words are part of this SERDES packet...so let's read the desired amount off of the FIFO */
+	usPacketLength = (tReceiveMsg.tSerdesHdr.ucPayloadLength); /* Payload Length for SERDES are bits 0 - 7 */
+	while (unWordsRead < usPacketLength)
+	{
+		tFIFOVal.unValue = nai_read32_SW(unAddr);
+
+#ifdef _DEBUG_X
+//#ifdef _VERBOSE
+		printk("Read FIFO Value: 0x%8x\r\n", tFIFOVal.unValue);		
+#endif
+
+		tReceiveMsg.msg[i++] = 	tFIFOVal.usLoWord;
+		unWordsRead++;
+		if (unWordsRead < usPacketLength)
+		{
+			tReceiveMsg.msg[i++] = tFIFOVal.usHiWord;
+			unWordsRead++;
+		}
+	}
+	unWordsRead += usSerdesHdrWordsRead; /* Add back in number of SERDES Header words read */
+
+#ifdef _VERBOSE
+	/* Create a new msg packet list and fill it with FIFO data... */
+	printk("Transport ID: 0x%4x\r\n", tReceiveMsg.tSerdesPayLd.tTransportHdr.usID);
+#endif
+
+	ptMsgPacketList = find_nai_msg_packet_list(ptMsgList, tReceiveMsg.tSerdesPayLd.tTransportHdr.usID);
+	if (ptMsgPacketList == NULL)
+	{
+		ptMsgPacketList = create_nai_msg_packet_list();
+		ptMsgPacketList->unWordsLeftToRead = tReceiveMsg.tSerdesPayLd.tTransportHdr.unMsgLength;
+		bAddMsgPacketList = 1;
+	}
+    
+	if (unWordsRead > ptMsgPacketList->unWordsLeftToRead)
+		ptMsgPacketList->unWordsLeftToRead = 0;
+	else
+		ptMsgPacketList->unWordsLeftToRead -= unWordsRead;
+
+	create_and_append_nai_msg_packet(ptMsgPacketList, &(tReceiveMsg.msg[0]));
+
+	if (bAddMsgPacketList)
+		add_nai_msg(ptMsgList, ptMsgPacketList);
+#ifdef _VERBOSE
+	printk("Transport ID: 0x%4x Remaining Words 0x%8.4x\r\n", tReceiveMsg.tSerdesPayLd.tTransportHdr.usID, ptMsgPacketList->unWordsLeftToRead);
+	printk("**************END nai_receive_msg_packet**************\r\n");
+#endif
+
+	return nStatus;
+}
+
+static u8 nai_get_serdes_completer_id(MsgPacket *ptMsgPacket)
+{
+	/* Bits 4 - 7 of Serdes Header 4 is the completer ID */
+	return  (u8)ptMsgPacket->tNAIMsg.tSerdesHdr.ucCompleterID;
+}
+
+static u8 nai_get_serdes_requester_id(MsgPacket *ptMsgPacket)
+{
+	/* Bits 0 - 3 of Serdes Header 4 is the Requester ID */
+	return (u8)ptMsgPacket->tNAIMsg.tSerdesHdr.ucRequesterID;
+}
+
+static u16 calculate_nai_expected_sequence_count(s32 unPayloadWordLength)
+{
+	u16 usExpectedSequenceCount = 0;
+	u16 usTempCount = 0;
+	s32 unPayloadWithHdr = 0;
+
+#ifdef _DANT
+	if (unPayloadWordLength != 0)
+	{
+#endif
+		usTempCount = (u16)(unPayloadWordLength / MAX_SERDES_MSG_IN_WORDS);
+		if ((unPayloadWordLength % MAX_SERDES_MSG_IN_WORDS) > 0)
+			usTempCount++;	
+
+		unPayloadWithHdr = ((usTempCount * CONFIG_TOTAL_PKT_HDR_IN_WORDS) + unPayloadWordLength);
+		usExpectedSequenceCount = (u16)(unPayloadWithHdr / MAX_SERDES_MSG_IN_WORDS);
+		if ((unPayloadWithHdr % MAX_SERDES_MSG_IN_WORDS) > 0)
+			usExpectedSequenceCount++;
+#ifdef _DANT
+	}
+	else /* Even with a zero payload...if we are looking to send a command in our CmdHeader...we need to have a sequence count of 1 */
+		usExpectedSequenceCount = 1;
+#endif		
+	return usExpectedSequenceCount;
+}
+
+
+static s32 make_read_request(u16 usCommandType, u8 ucRequesterID, u8 ucCompleterID, u16 usChipID, u32 unOffset, u8 *pucBuf, s32 nLen)
+{
+	s32 nStatus = NAI__SUCCESS;
+	s32 nMsgPacketCount = 0;	
+	MsgList tMsgList;
+	MsgPacketList *ptMsgPacketList = NULL;
+	u16 usID = get_next_tran_id();
+	u16 usExpectedSequenceCount = 0;	
+	u16 usPacketPayLdLength = 0;
+	s32 ulTimer;
+	NAIMsg tNAIMsg;
+	
+	init_nai_msgs(&tMsgList);
+
+	/* Create Retrieve Request */
+	ptMsgPacketList = create_nai_msg_packet_list();
+	nMsgPacketCount = 0;		
+		
+	/* Determine expected sequence count...NOTE this takes into account all header info */
+	usExpectedSequenceCount = 1;
+
+	nMsgPacketCount++;
+			
+	memset(&tNAIMsg, 0, sizeof(NAIMsg));
+
+	/* SERDES HEADER */
+#ifdef _VERBOSE
+	printk("IN make_read_request\r\n");
+	printk("RequesterID = 0x%2.2x(%u)\r\n", ucRequesterID, ucRequesterID);
+	printk("CompleterID = 0x%2.2x(%u)\r\n", ucCompleterID, ucCompleterID);
+#endif
+	tNAIMsg.tSerdesHdr.ucType = 3;
+	tNAIMsg.tSerdesHdr.ucToHPS = 1;
+	tNAIMsg.tSerdesHdr.ucPayloadLength = (u8)(CONFIG_TOTAL_PKT_HDR_IN_WORDS - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
+	tNAIMsg.tSerdesHdr.usSERDES2 = 0;
+	tNAIMsg.tSerdesHdr.usSERDES3 = 0;
+	tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+	tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+	tNAIMsg.tSerdesHdr.usSERDES5 = 0;
+
+	/* Serdes Payload length must be a multiple of 2 */
+	if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)
+		tNAIMsg.tSerdesHdr.ucPayloadLength++;
+
+	/* TRANSPORT HEADER */
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
+	tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = CONFIG_TOTAL_PKT_HDR_IN_WORDS;    /* Length in Words - Single Packet Request with no payload!*/
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;
+
+	/* COMMAND HEADER */
+	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = usChipID;
+	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = usCommandType;
+	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = (s32)unOffset;
+    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = (s32)nLen;
+
+	/* COMMAND PAYLOAD */
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = 0; /* Packet payload length stored in bytes - No Payload since just a request */
+
+	/* Let's build a linked list of message packets that will represent a full message */
+	create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);
+
+	/* Send request for data */
+	nStatus = nai_send_msg(ptMsgPacketList); /*Don't need to wait for read request..as we will be waiting below!*/
+	delete_nai_msg_packets(ptMsgPacketList);
+	aligned_free(ptMsgPacketList);
+	ptMsgPacketList = NULL;
+
+	if (nStatus == NAI__SUCCESS)
+	{
+		/* Prepare for response! */
+		init_nai_msgs(&tMsgList);
+
+		/* Wait for packet! */		
+		do 
+		{
+			ulTimer = jiffies;
+			while (!nai_rx_fifo_pkt_ready(ucRequesterID, ucCompleterID))
+			{
+				/* If FIFO did not get serviced within a reasonable amount of time..get out */
+				if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT)
+				{
+					nStatus = NAI_RX_FIFO_PKT_NOT_READY_TIMEOUT;
+					break;
+				}			
+			}
+
+			/* Now fetch the next message packet and append it to the MsgList */
+			if (nStatus == NAI__SUCCESS)
+				nStatus = nai_receive_msg_packet(ucRequesterID, ucCompleterID, &tMsgList);
+
+		} while	(nStatus == NAI__SUCCESS && tMsgList.ptEnd->unWordsLeftToRead > 0);
+
+		if (nStatus == NAI__SUCCESS)
+		{
+#ifdef _VERBOSE
+			print_nai_msgs(&tMsgList, true);
+#endif
+			if (validate_nai_msgs(&tMsgList) == 0)
+			{
+				/* NOTE: Shound only have 1 message (1 + more packets) being returned */
+				MsgPacketList *ptFirstMsg = tMsgList.ptStart;
+				if (ptFirstMsg != NULL)
+				{
+					MsgPacket *ptTraverse = ptFirstMsg->ptStart;
+					u16 usBufOffset = 0;
+					while (ptTraverse != NULL)
+					{			
+						usPacketPayLdLength = ptTraverse->tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength;
+						memcpy((pucBuf + usBufOffset), &(ptTraverse->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[0]), usPacketPayLdLength); /* Copy specified number of bytes from response message into output param */		
+						usBufOffset += usPacketPayLdLength; /* Increment offset so we don't overwrite what we already have written */
+						ptTraverse = ptTraverse->ptNext;
+					}
+				}				
+			}
+		}
+
+		delete_nai_msgs(&tMsgList);
+	}
+
+	return nStatus;
+}
+
+static s32 make_write_request(u16 usCommandType, u8 ucRequesterID, u8 ucCompleterID, u16 usChipID, u32 unOffset, u8 *pucBuf, s32 nLen)
+{
+	s32 nStatus = NAI__SUCCESS;
+	s32 unMsgPayloadWordLength = convert_bytes_to_words(nLen); /* # of words to write */
+	s32 i = 0, k = 0;	
+	s32 nMsgPacketCount = 0;
+	s32 nPayloadWordsLeftToRead = 0;
+	s32 nPayloadWordCount = 0;
+	MsgPacketList *ptMsgPacketList = NULL;
+	NAIMsg tNAIMsg;		
+	u16 usID = get_next_tran_id();
+	u16 usExpectedSequenceCount = 0;
+	WORDValue tWordValue;
+
+	ptMsgPacketList = create_nai_msg_packet_list();
+
+	nMsgPacketCount = 0;		
+	nPayloadWordsLeftToRead = (s32)unMsgPayloadWordLength;		
+
+	/* Determine expected sequence count...NOTE this takes into account all header info */
+	usExpectedSequenceCount = calculate_nai_expected_sequence_count(unMsgPayloadWordLength);
+
+	do
+	{		
+		nMsgPacketCount++;
+		memset(&tNAIMsg, 0, sizeof(NAIMsg));
+
+		/* SERDES HEADER */
+#ifdef _VERBOSE
+	printk("IN make_write_request\r\n");
+	printk("RequesterID = 0x%2.2x(%u)\r\n", ucRequesterID, ucRequesterID);
+	printk("CompleterID = 0x%2.2x(%u)\r\n", ucCompleterID, ucCompleterID);
+#endif
+		tNAIMsg.tSerdesHdr.ucType = 3;
+		tNAIMsg.tSerdesHdr.ucToHPS = 1;
+		tNAIMsg.tSerdesHdr.ucPayloadLength = (u8)(MIN((nPayloadWordsLeftToRead+CONFIG_TOTAL_PKT_HDR_IN_WORDS), MAX_SERDES_MSG_IN_WORDS) - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
+		tNAIMsg.tSerdesHdr.usSERDES2 = 0;
+		tNAIMsg.tSerdesHdr.usSERDES3 = 0;
+		tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+		tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+		tNAIMsg.tSerdesHdr.usSERDES5 = 0;
+
+		/* Serdes Payload length must be a multiple of 2 */
+		if ((tNAIMsg.tSerdesHdr.ucPayloadLength % 2) != 0)	
+			tNAIMsg.tSerdesHdr.ucPayloadLength++;
+
+		/* TRANSPORT HEADER */
+		tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
+		tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = (unMsgPayloadWordLength + (usExpectedSequenceCount * CONFIG_TOTAL_PKT_HDR_IN_WORDS));    /* Length in Words */
+		tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = nMsgPacketCount;
+		tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = usExpectedSequenceCount;
+
+		/* COMMAND HEADER */
+		tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = usChipID;
+		tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = usCommandType;
+		tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = (s32)unOffset;
+	    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = 0x0;
+
+		/* COMMAND PAYLOAD */
+#ifdef _VERBOSE
+		printk("Num Msg Words To Read: %ld\r\n", nPayloadWordsLeftToRead);
+#endif
+		nPayloadWordCount = MIN(nPayloadWordsLeftToRead, CONFIG_MAX_PAYLOAD_IN_WORDS);
+		
+		for (i=0; i < nPayloadWordCount; i++)
+		{
+			tWordValue.ucLoByte = pucBuf[k++];
+			/* It is possible a buffer of "odd" size was passed in...let's make sure we don't try to access more than what we were given */
+			if (k < nLen) 
+				tWordValue.ucHiByte = pucBuf[k++];
+			else
+				tWordValue.ucHiByte = 0x00;
+		   	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandPayLd.usData[i] = tWordValue.usValue;
+		}
+
+		tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = (nPayloadWordCount * 2); /*Packet payload length stored in bytes */
+
+		/* Let's build a linked list of message packets that will represent a full message */
+		create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);
+		nPayloadWordsLeftToRead -= nPayloadWordCount;
+#ifdef _VERBOSE
+		printk("Num Msg Words Left To Read: %ld\r\n", nPayloadWordsLeftToRead);
+#endif
+
+	} while (nPayloadWordsLeftToRead > 0);
+
+	/* Send request to write data */
+//printk("make_write_request ... about to send message\r\n");
+	nStatus = nai_send_msg(ptMsgPacketList); 
+//printk("make_write_request ... after send message\r\n");
+	delete_nai_msg_packets(ptMsgPacketList);
+	aligned_free(ptMsgPacketList);
+
+	return nStatus;
+}
+
+s32 nai_read_module_eeprom_request(u16 usChipID, u8 ucRequesterID, u8 ucCompleterID, u32 unEepromOffset, u8 *pucBuf, s32 nLen) 
+{
+	s32 nStatus = NAI__SUCCESS;
+	nStatus = make_read_request(COMMAND_TYPECODE_READEEPROM, ucRequesterID, ucCompleterID, usChipID, unEepromOffset, pucBuf, nLen);
+	return nStatus;
+}
+
+
+
+s32 nai_write_module_eeprom_request(u16 usChipID, u8 ucRequesterID, u8 ucCompleterID, u32 unEepromOffset, u8 *pucBuf, s32 nLen)
+{
+	s32 nStatus = NAI__SUCCESS;
+	nStatus = make_write_request(COMMAND_TYPECODE_WRITEEEPROM, ucRequesterID, ucCompleterID, usChipID, unEepromOffset, pucBuf, nLen);
+	return nStatus;
+}
+
+s32 nai_erase_flash_request(u8 ucRequesterID, u8 ucCompleterID, u32 unFlashOffset, u8 ucNumPages)
+{
+	s32 nStatus = NAI__SUCCESS;
+	MsgPacketList *ptMsgPacketList = NULL;
+	u16 usID = get_next_tran_id();
+	NAIMsg tNAIMsg;
+		
+	ptMsgPacketList = create_nai_msg_packet_list();
+	
+	memset(&tNAIMsg, 0, sizeof(NAIMsg));
+
+	/* SERDES HEADER */
+	tNAIMsg.tSerdesHdr.ucType = 3;
+	tNAIMsg.tSerdesHdr.ucToHPS = 1;
+	tNAIMsg.tSerdesHdr.ucPayloadLength = (u8)(CONFIG_TOTAL_PKT_HDR_IN_WORDS - TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS);
+	tNAIMsg.tSerdesHdr.usSERDES2 = 0;
+	tNAIMsg.tSerdesHdr.usSERDES3 = 0;
+	tNAIMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+	tNAIMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+	tNAIMsg.tSerdesHdr.usSERDES5 = 0;
+
+	/* TRANSPORT HEADER */
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usID = usID;
+	tNAIMsg.tSerdesPayLd.tTransportHdr.unMsgLength = CONFIG_TOTAL_PKT_HDR_IN_WORDS;    /* Length in Words */
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usSequenceNum = 1;
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usExpectedSequenceCount = 1;
+
+	/* COMMAND HEADER */
+	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID = 0;
+	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType = COMMAND_TYPECODE_ERASEFLASH;
+	tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unOffset = unFlashOffset;
+    tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.unPayLdRequestLength = (s32)ucNumPages;  /* Stuff num pages into PayLdRequestLength just to get the data across */
+
+	/* COMMAND PAYLOAD */
+	tNAIMsg.tSerdesPayLd.tTransportHdr.usPacketPayLdLength = 0; /*Packet payload length stored in bytes */
+
+	/* Let's build a linked list of message packets that will represent a full message */
+	create_and_append_nai_msg_packet(ptMsgPacketList, tNAIMsg.msg);
+
+	/* Send request to write data */
+	nStatus = nai_send_msg(ptMsgPacketList); 
+	delete_nai_msg_packets(ptMsgPacketList);
+	aligned_free(ptMsgPacketList);
+
+	return nStatus;
+}
+
+s32 nai_read_module_flash_request(u8 ucRequesterID, u8 ucCompleterID, u32 unFlashOffset, u8 *pucBuf, s32 nLen)
+{
+	s32 nStatus = NAI__SUCCESS;
+	nStatus = make_read_request(COMMAND_TYPECODE_READFLASH, ucRequesterID, ucCompleterID, 0, unFlashOffset, pucBuf, nLen);
+	return nStatus;
+}
+
+s32 nai_write_module_flash_request(u8 ucRequesterID, u8 ucCompleterID, u32 unFlashOffset, u8 *pucBuf, s32 nLen)
+{
+	s32 nStatus = NAI__SUCCESS;
+	nStatus = make_write_request(COMMAND_TYPECODE_WRITEFLASH, ucRequesterID, ucCompleterID, 0, unFlashOffset, pucBuf, nLen);
+	return nStatus;
+}
+
+s32 nai_write_micro_request(u8 ucRequesterID, u8 ucCompleterID, u8 ucChannel, u32 unOffset, u8 *pucBuf, s32 nLen)
+{
+	s32 nStatus = NAI__SUCCESS;
+	nStatus = make_write_request(COMMAND_TYPECODE_CONFIG_MICRO, ucRequesterID, ucCompleterID, (u16)ucChannel, unOffset, pucBuf, nLen);
+	return nStatus;
+}
+
+s32 nai_get_micro_request(u8 ucRequesterID, u8 ucCompleterID, u8 ucChannel, u8 *pucBuf, s32 nLen)
+{
+	s32 nStatus = NAI__SUCCESS;
+	/*NOTE: We pass ucChannel in as chip ID - this will allow us to determine on the module side which channel user is requesting version info from */
+	nStatus = make_read_request(COMMAND_TYPECODE_GET_MICRO, ucRequesterID, ucCompleterID, (u16)ucChannel, 0, pucBuf, nLen);
+	return nStatus;
+}
+
+s32 nai_erase_micro_request(u8 ucRequesterID, u8 ucCompleterID, u8 ucChannel)
+{
+	s32 nStatus = NAI__SUCCESS;
+	nStatus = make_write_request(COMMAND_TYPECODE_ERASE_MICRO, ucRequesterID, ucCompleterID, (u16)ucChannel, 0, NULL, 0);
+	return nStatus;	
+}
+
+static u32 nai_get_completion_timeout(MsgPacket *ptMsgPacket)
+{
+	/* Default timeout */
+//	u32 unCompletionTimeout = (COMPLETION_TIMEOUT * 4);
+	u32 unCompletionTimeout = (COMPLETION_TIMEOUT * 10); /*DANT used to be multiplied by 4 until X2 module with Micron QSPI now takes longer for erase! */
+	u8 ucNumChannels = 1;
+	
+	if (ptMsgPacket != NULL)
+	{	    
+		switch (ptMsgPacket->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usCommandType)
+		{
+			case COMMAND_TYPECODE_CONFIG_MICRO :
+			case COMMAND_TYPECODE_ERASE_MICRO :
+			if (ptMsgPacket->tNAIMsg.tSerdesPayLd.tTransportPayLd.tCommandHdr.usChipID == (uint32_t)ALL_CHANNELS)
+				ucNumChannels = NUM_DT_CHANNELS;			
+			else
+				ucNumChannels = 1;
+			unCompletionTimeout *= (ucNumChannels + 2);  /* Multiply the standard timeout by the number of channels we will be processing + 2 (buffer) */
+			break;
+			
+			default :			
+			break;
+		}
+	}
+	
+	return unCompletionTimeout;
+}
diff --git a/drivers/misc/nai_serdes_config.h b/drivers/misc/nai_serdes_config.h
new file mode 100644
index 0000000..bf1acad
--- /dev/null
+++ b/drivers/misc/nai_serdes_config.h
@@ -0,0 +1,32 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __NAI_SERDES_CONFIG_H__
+#define __NAI_SERDES_CONFIG_H__
+
+/* HighLevelAPI */
+extern s32 nai_read_module_eeprom_request(u16 usChipID, u8 ucRequesterID, u8 ucCompleterID, u32 unEepromOffset, u8 *pucBuf, s32 nLen);
+extern s32 nai_write_module_eeprom_request(u16 usChipID, u8 ucRequesterID,u8 ucCompleterID, u32 unEepromOffset, u8 *pucBuf, s32 nLen);
+extern s32 nai_erase_flash_request(u8 ucRequesterID, u8 ucCompleterID, u32 unFlashOffset, u8 ucNumPages);
+extern s32 nai_read_module_flash_request(u8 ucRequesterID, u8 ucCompleterID, u32 unFlashOffset, u8 *pucBuf, s32 nLen);
+extern s32 nai_write_module_flash_request(u8 ucRequesterID, u8 ucCompleterID, u32 unFlashOffset, u8 *pucBuf, s32 nLen);
+
+/* Microcontroller */
+extern s32 nai_write_micro_request(u8 ucRequesterID, u8 ucCompleterID, u8 ucChannel, u32 unOffset, u8 *pucBuf, s32 nLen);
+extern s32 nai_get_micro_request(u8 ucRequesterID, u8 ucCompleterID, u8 ucChannel, u8 *pucBuf, s32 nLen);
+extern s32 nai_erase_micro_request(u8 ucRequesterID, u8 ucCompleterID, u8 ucChannel);
+
+#endif /* __NAI_SERDES_CONFIG_H__ */
diff --git a/drivers/misc/nai_serdes_oper.c b/drivers/misc/nai_serdes_oper.c
new file mode 100644
index 0000000..e2943a9
--- /dev/null
+++ b/drivers/misc/nai_serdes_oper.c
@@ -0,0 +1,1243 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/semaphore.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+
+#include "nai_serdes.h"
+#include "nai_serdes_prv.h"
+#include "nai_serdes_utils.h"
+#include "nai_serdes_oper.h"
+
+#define NAI_MAX_AVAIL_SLOTS         10
+
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+
+static struct semaphore	g_SERDES_Mutex[NAI_MAX_AVAIL_SLOTS + 1];
+
+static s32 nai_send_serdes_oper_msg(NAIOperMsg *ptNAIOperMsg);
+static s32 nai_receive_serdes_oper_msg(NAIOperMsg *ptNAIOperMsg);
+static s32 initSERDES_Mutex(u8 ucSlotID);
+static s32 lockSERDES_Mutex(u8 ucSlotID);
+static s32 unlockSERDES_Mutex(u8 ucSlotID);
+
+static s32 initSERDES_Mutex(u8 ucSlotID) {
+	sema_init(&g_SERDES_Mutex[ucSlotID], 1);
+
+	return NAI__SUCCESS;
+}
+
+static s32 lockSERDES_Mutex(u8 ucSlotID) {
+	s32 nStatus = NAI__SUCCESS;
+
+	if (unlikely(down_timeout(&g_SERDES_Mutex[ucSlotID], 4 * HZ)))
+		nStatus = NAI_UNABLE_TO_LOCK_MUTEX;
+
+	return nStatus;
+}
+
+static s32 unlockSERDES_Mutex(u8 ucSlotID) {
+	up(&g_SERDES_Mutex[ucSlotID]);
+
+	return NAI__SUCCESS;
+}
+
+s32 nai_init_msg_utils(u8 ucID) {
+	u32 i;
+	s32 nStatus;
+
+	nStatus = nai_init_as_slot(ucID);
+	if (nStatus == NAI__SUCCESS)
+		for (i = 0; i <= NAI_MAX_AVAIL_SLOTS; ++i)
+			initSERDES_Mutex(i);
+
+	return nStatus;
+}
+
+s32 nai_read_reg16_request(u32 unAddress, u16 *pusValue) {
+	s32 nStatus = NAI__SUCCESS;
+	u8 ucCompleterID = 0;
+	u32 unModuleOffset = 0;
+
+	nStatus = nai_get_module_id_and_address(unAddress, &ucCompleterID,
+						&unModuleOffset);
+
+	if (nStatus == NAI__SUCCESS)
+		nStatus = nai_read_reg16_by_slot_request(ucCompleterID,
+							 unModuleOffset,
+							 pusValue);
+
+	return nStatus;
+}
+
+s32 nai_write_reg16_request(u32 unAddress, u16 usValue) {
+	s32 nStatus = NAI__SUCCESS;
+	u8 ucCompleterID = 0;
+	u32 unModuleOffset = 0;
+
+	nStatus = nai_get_module_id_and_address(unAddress, &ucCompleterID,
+						&unModuleOffset);
+
+	if (nStatus == NAI__SUCCESS)
+		nStatus = nai_write_reg16_by_slot_request(ucCompleterID,
+							  unModuleOffset,
+							  usValue);
+
+	return nStatus;
+}
+
+s32 nai_read_reg32_request(u32 unAddress, u32 *punValue) {
+	s32 nStatus = NAI__SUCCESS;
+	u8 ucCompleterID = 0;
+	u32 unModuleOffset = 0;	
+	
+	if (nai_is_hw_serdes_capable()) {
+
+		nStatus = nai_get_module_id_and_address(unAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS) {
+			if (lockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS)
+				return NAI_UNABLE_TO_LOCK_MUTEX;
+				
+			/* NOTE: We need to take into account linux open address space starting at 0x70004000 is module 1
+					 so in essence...to access the zero offset of module 1 we need to pass an address of 0x00000000. */
+			if (ucCompleterID > 0 && unAddress >= 0x00004000) {
+				unAddress -= 0x00004000;				
+				*punValue = nai_read32(unAddress);
+			}
+			else
+				nStatus = NAI_COMMAND_FAILED;
+		
+			if (unlockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS) {
+				if (nStatus == NAI__SUCCESS)
+					nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;	
+			}
+		}
+	}
+	/* revert to SW SERDES */
+	else { 
+		NAIOperMsg tNAIOperMsg;
+
+		memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+		nStatus = nai_get_module_id_and_address(unAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS)
+			nStatus = nai_read_reg32_by_slot_request(ucCompleterID,
+								 unModuleOffset,
+								 punValue);		
+	}
+	return nStatus;
+}
+
+s32 nai_write_reg32_request(u32 unAddress, u32 unValue) {
+	s32 nStatus = NAI__SUCCESS;
+	u8 ucCompleterID = 0;
+	u32 unModuleOffset = 0;
+	
+	if (nai_is_hw_serdes_capable()) {
+		nStatus = nai_get_module_id_and_address(unAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS) {
+			if (lockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS)
+				return NAI_UNABLE_TO_LOCK_MUTEX;
+
+			/* NOTE: We need to take into account linux open address space starting at 0x70004000 is module 1
+					 so in essence...to access the zero offset of module 1 we need to pass an address of 0x00000000. */
+			if (ucCompleterID > 0 && unAddress >= 0x00004000) {
+				unAddress -= 0x00004000;			
+				nai_write32(unAddress, unValue);
+			}
+		
+			if (unlockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS) {
+				if (nStatus == NAI__SUCCESS)
+					nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+			}
+		}
+	}
+	/* revert to SW SERDES */
+	else {
+		nStatus = nai_get_module_id_and_address(unAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS)
+			nStatus = nai_write_reg32_by_slot_request(ucCompleterID,
+								  unModuleOffset,
+								  unValue);		
+	}
+	return nStatus;
+}
+
+s32 nai_read_block16_request(u32 unStartAddress, u32 unCount,
+			     u8 ucStride, u16 *pusDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	
+	if (nai_is_hw_block_serdes_capable()) {
+		u32 unAddressOffset = 0;
+		u32 unModuleOffset = 0;
+		u8 ucCompleterID = 0;	
+		u8 ucPackMode = 1;
+		u8 ucExtraRead = 0;
+		u32 unBlockConfigVal = 0;
+		u32 unBlockChunkCount = 0;
+		u32 unNumDataTransactions = 0;
+		u32 unDataTransferLeftInWords = unCount;
+		u16 i = 0;
+		u32 k = 0;
+		FIFOValue tValue;
+		
+		/* Must be 32 bit aligned */
+		if ((unStartAddress & 0x0003) != 0)
+			return NAI_MIS_ALIGNED_BYTE_ENABLE;
+			
+		/* SERDES uses 32 bit addressing so make sure Stide is a multiple of 4 */
+		if ((ucStride % 4) != 0)
+			return NAI_STRIDE_CAUSES_MISALIGNMENT;
+
+		/* If caller requests odd number of 16 bit reads...we need to treat the last read as a non-packing 32 bit read so we don't read more registers than what user requested (bad things could happen if we did under a stride of 0 - FIFO) */
+		if ((unDataTransferLeftInWords % 2) > 0)
+		{
+			ucExtraRead = 1;
+			unDataTransferLeftInWords--; /* Subtract 1 so we get even number of words to transfer using packing */
+		}
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+							
+		if (nStatus == NAI__SUCCESS) {
+			nStatus = nai_get_module_packet_config_address_offset(unStartAddress, ucCompleterID, &unAddressOffset);
+		
+			if (nStatus == NAI__SUCCESS) {
+				/* NOTE: We need to take into account linux open address space starting at 0x70004000 is module 1
+						 so in essence...to access the zero offset of module 1 we need to pass an address of 0x00000000. */
+				if (ucCompleterID > 0 && unStartAddress >= 0x00004000) 
+					unStartAddress -= 0x00004000;	
+										
+				do {
+					/* First we need to tell the hardware what we want regarding block read request */
+					unBlockConfigVal = 0;
+					unBlockChunkCount = MIN(unDataTransferLeftInWords, NAI_OPER_MAX_PAYLOAD_IN_WORDS); 
+					unNumDataTransactions = (unBlockChunkCount/2);					
+					unBlockConfigVal = (unBlockChunkCount | ((ucStride/4) << 8) | (ucPackMode << 16));	/* HW views stride in 32 bit DWORDS not BYTES */
+								
+					/* NOTE: We purposely lock and unlock for each block of packet reads as to not starve out other requests. */
+					if (lockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS)
+						nStatus = NAI_UNABLE_TO_LOCK_MUTEX;										
+					
+					if (nStatus == NAI__SUCCESS) {				
+						
+						nai_write_32_ModPktCfg(unAddressOffset, unBlockConfigVal);
+						
+						/* Now we make desired number of read calls and HW will take care of SERDES packets for a block chunk up to 250 WORDS (or 125 DWORDS) */
+						for (i=0; i < unNumDataTransactions; i++) {	
+							tValue.unValue = nai_read32(unStartAddress);
+							pusDataBuf[k] = tValue.usLoWord;
+							pusDataBuf[k+1] = tValue.usHiWord;
+							unDataTransferLeftInWords -= 2;
+							k += 2;
+								
+							unStartAddress += (ucStride * 2); /* Need to multiply by 2 here since we are packing and Keith willl be splitting our 32 bit value and placing lower 16 in one register and the upper 16 in a 2nd register hence...the need to multipy start address by 2 for next iteration */							
+						}			
+						
+						if (unlockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS) {
+							if (nStatus == NAI__SUCCESS)
+								nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;				
+						}				
+					}
+				} while (unDataTransferLeftInWords > 0 && nStatus == NAI__SUCCESS);
+				
+				/* If we had an odd count requested, we need to read the last 16 bit value straight without packing */
+				if (ucExtraRead > 0)
+				{
+					tValue.unValue = nai_read32(unStartAddress);
+					pusDataBuf[k] = tValue.usLoWord;
+				}				
+			}
+		}		
+	}
+	/* revert to SW SERDES */
+	else {	
+		u8 ucCompleterID = 0;
+		u32 unModuleOffset = 0;
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS)
+			nStatus = nai_read_block16_by_slot_request(ucCompleterID,
+								   unModuleOffset,
+								   unCount, ucStride,
+								   pusDataBuf);
+	}
+	
+	return nStatus;
+}
+
+s32 nai_write_block16_request(u32 unStartAddress, u32 unCount,
+			      u8 ucStride, u16 *pusDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	
+	if (nai_is_hw_block_serdes_capable()) {
+		u32 unAddressOffset = 0;
+		u32 unModuleOffset = 0;
+		u8 ucCompleterID = 0;
+		u8 ucPackMode = 1;	
+		u8 ucExtraWrite = 0;
+		u32 unBlockConfigVal = 0;
+		u32 unBlockChunkCount = 0;
+		u32 unNumDataTransactions = 0;
+		u32 unDataTransferLeftInWords = unCount; 
+		u16 i = 0;
+		u32 k = 0;		
+		FIFOValue tValue;
+				
+		/* Must be 32 bit aligned */
+		if ((unStartAddress & 0x0003) != 0)
+			return NAI_MIS_ALIGNED_BYTE_ENABLE;
+			
+		/* SERDES uses 32 bit addressing so make sure Stide is a multiple of 4 */
+		if ((ucStride % 4) != 0)
+			return NAI_STRIDE_CAUSES_MISALIGNMENT;
+
+		/* If caller requests odd number of 16 bit writes...we need to treat the last write as a non-packing 32 bit write so we don't stomp on more registers than what user requested */
+		if ((unDataTransferLeftInWords % 2) > 0)
+		{
+			ucExtraWrite = 1;
+			unDataTransferLeftInWords--; /* Subtract 1 so we get even number of words to transfer using packing */
+		}
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+							
+		if (nStatus == NAI__SUCCESS) {
+			nStatus = nai_get_module_packet_config_address_offset(unStartAddress, ucCompleterID, &unAddressOffset);
+		
+			if (nStatus == NAI__SUCCESS) {
+				/* NOTE: We need to take into account linux open address space starting at 0x70004000 is module 1
+						 so in essence...to access the zero offset of module 1 we need to pass an address of 0x00000000. */
+				if (ucCompleterID > 0 && unStartAddress >= 0x00004000) 
+					unStartAddress -= 0x00004000;	
+										
+				do {
+					/* First we need to tell the hardware what we want regarding block write request */
+					unBlockConfigVal = 0;
+					unBlockChunkCount = MIN(unDataTransferLeftInWords, NAI_OPER_MAX_PAYLOAD_IN_WORDS);
+					unNumDataTransactions = (unBlockChunkCount/2);
+					unBlockConfigVal = (unBlockChunkCount | ((ucStride/4) << 8) | (ucPackMode << 16)); /* HW views stride in 32 bit DWORDS not BYTES also since we are packing we will only have 1/2 the number of writes */
+												
+					/* NOTE: We purposely lock and unlock for each block of packet writes as to not starve out other requests. */
+					if (lockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS)
+						nStatus = NAI_UNABLE_TO_LOCK_MUTEX;												
+					
+					if (nStatus == NAI__SUCCESS) {				
+						
+						nai_write_32_ModPktCfg(unAddressOffset, unBlockConfigVal);
+						
+						/* Now we make desired number of write calls and HW will take care of SERDES packets for a block chunk up to 250 WORDS (or 125 DWORDS) */
+						for (i=0; i < unNumDataTransactions; i++) {	
+							tValue.usLoWord = pusDataBuf[k];
+							tValue.usHiWord = pusDataBuf[k+1];								
+							nai_write32(unStartAddress, tValue.unValue);
+							unDataTransferLeftInWords -= 2;
+							k += 2;
+							
+							unStartAddress += (ucStride * 2); /* Need to multiply by 2 here since we are packing and Keith willl be splitting our 32 bit value and placing lower 16 in one register and the upper 16 in a 2nd register hence...the need to multipy start address by 2 for next iteration */
+						}			
+						
+						if (unlockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS) {
+							if (nStatus == NAI__SUCCESS)
+								nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;				
+						}				
+					}
+				} while (unDataTransferLeftInWords > 0 && nStatus == NAI__SUCCESS);
+				
+				/* If we had an odd count requested, we need to take the last 16 bit value and write it straight out without packing */
+				if (ucExtraWrite > 0)
+				{
+					tValue.usLoWord = pusDataBuf[k];
+					tValue.usHiWord = 0;
+					nai_write32(unStartAddress, tValue.unValue);
+				}
+			}
+		}		
+	}
+	/* revert to SW SERDES */
+	else {
+		u8 ucCompleterID = 0;
+		u32 unModuleOffset = 0;
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS)
+			nStatus = nai_write_block16_by_slot_request(ucCompleterID,
+									unModuleOffset,
+									unCount, ucStride,
+									pusDataBuf);		
+	}
+	
+	return nStatus;
+}
+
+s32 nai_read_block32_request(u32 unStartAddress, u32 unCount,
+			     u8 ucStride, u32 *punDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	
+	if (nai_is_hw_block_serdes_capable()) {
+		u32 unAddressOffset = 0;
+		u32 unModuleOffset = 0;
+		u8 ucCompleterID = 0;	
+		u32 unBlockConfigVal = 0;
+		u32 unBlockChunkCount = 0;
+		u32 unNumDataTransactions = 0;
+		u32 unDataTransferLeftInWords = (unCount * 2); /* Multiply by 2 since HW expects payload length in 16 bit words and our count is in 32 bit words */ 
+		u16 i = 0;
+		u32 k = 0;
+		
+		/* Must be 32 bit aligned */
+		if ((unStartAddress & 0x0003) != 0)
+			return NAI_MIS_ALIGNED_BYTE_ENABLE;
+			
+		/* SERDES uses 32 bit addressing so make sure Stide is a multiple of 4 */
+		if ((ucStride % 4) != 0)
+			return NAI_STRIDE_CAUSES_MISALIGNMENT;
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+							
+		if (nStatus == NAI__SUCCESS) {
+			nStatus = nai_get_module_packet_config_address_offset(unStartAddress, ucCompleterID, &unAddressOffset);
+		
+			if (nStatus == NAI__SUCCESS) {
+				/* NOTE: We need to take into account linux open address space starting at 0x70004000 is module 1
+						 so in essence...to access the zero offset of module 1 we need to pass an address of 0x00000000. */
+				if (ucCompleterID > 0 && unStartAddress >= 0x00004000) 
+					unStartAddress -= 0x00004000;	
+										
+				do {
+					/* First we need to tell the hardware what we want regarding block read request */
+					unBlockConfigVal = 0;
+					unBlockChunkCount = MIN(unDataTransferLeftInWords, NAI_OPER_MAX_PAYLOAD_IN_WORDS);
+					unNumDataTransactions = (unBlockChunkCount / 2);
+					unBlockConfigVal = (unBlockChunkCount | ((ucStride/4) << 8)); /* HW views stride in 32 bit DWORDS not BYTES */						
+					
+					/* NOTE: We purposely lock and unlock for each block of packet reads as to not starve out other requests. */
+					if (lockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS)
+						nStatus = NAI_UNABLE_TO_LOCK_MUTEX;										
+					
+					if (nStatus == NAI__SUCCESS) {				
+						
+						nai_write_32_ModPktCfg(unAddressOffset, unBlockConfigVal);
+						
+						/* Now we make desired number of read calls and HW will take care of SERDES packets for a block chunk up to 250 WORDS (or 125 DWORDS) */
+						for (i=0; i < unNumDataTransactions; i++) {	
+							punDataBuf[k] = nai_read32(unStartAddress);
+							unStartAddress += ucStride;
+							k++;
+						}			
+						
+						if (unDataTransferLeftInWords >= NAI_OPER_MAX_PAYLOAD_IN_WORDS)
+							unDataTransferLeftInWords -= NAI_OPER_MAX_PAYLOAD_IN_WORDS;
+						else
+							unDataTransferLeftInWords = 0;
+						
+						if (unlockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS) {
+							if (nStatus == NAI__SUCCESS)
+								nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;				
+						}				
+					}
+				} while (unDataTransferLeftInWords > 0 && nStatus == NAI__SUCCESS);
+			}
+		}
+	}
+	/* revert to SW BLOCK Serdes */
+	else {
+		u8 ucCompleterID = 0;
+		u32 unModuleOffset = 0;
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS)
+			nStatus = nai_read_block32_by_slot_request(ucCompleterID,
+								   unModuleOffset,
+								   unCount, ucStride,
+								   punDataBuf);		
+	}
+	return nStatus;
+}
+
+s32 nai_write_block32_request(u32 unStartAddress, u32 unCount,
+			      u8 ucStride, u32 *punDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	
+	if (nai_is_hw_block_serdes_capable()) {	
+		u32 unAddressOffset = 0;
+		u32 unModuleOffset = 0;
+		u8 ucCompleterID = 0;	
+		u32 unBlockConfigVal = 0;
+		u32 unBlockChunkCount = 0;
+		u32 unNumDataTransactions = 0;
+		u32 unDataTransferLeftInWords = (unCount * 2); /* Multiply by 2 since HW expects payload length in 16 bit words and our count is in 32 bit words */ 
+		u16 i = 0;
+		
+		/* Must be 32 bit aligned */
+		if ((unStartAddress & 0x0003) != 0)
+			return NAI_MIS_ALIGNED_BYTE_ENABLE;
+			
+		/* SERDES uses 32 bit addressing so make sure Stide is a multiple of 4 */
+		if ((ucStride % 4) != 0)
+			return NAI_STRIDE_CAUSES_MISALIGNMENT;
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+							
+		if (nStatus == NAI__SUCCESS) {
+			nStatus = nai_get_module_packet_config_address_offset(unStartAddress, ucCompleterID, &unAddressOffset);
+		
+			if (nStatus == NAI__SUCCESS) {
+				/* NOTE: We need to take into account linux open address space starting at 0x70004000 is module 1
+						 so in essence...to access the zero offset of module 1 we need to pass an address of 0x00000000. */
+				if (ucCompleterID > 0 && unStartAddress >= 0x00004000) 
+					unStartAddress -= 0x00004000;	
+										
+				do {
+					/* First we need to tell the hardware what we want regarding block write request */
+					unBlockConfigVal = 0;
+					unBlockChunkCount = MIN(unDataTransferLeftInWords, NAI_OPER_MAX_PAYLOAD_IN_WORDS); 
+					unNumDataTransactions = (unBlockChunkCount / 2);
+					unBlockConfigVal = (unBlockChunkCount | ((ucStride/4) << 8)); /* HW views stride in 32 bit DWORDS not BYTES */
+													
+					/* NOTE: We purposely lock and unlock for each block of packet writes as to not starve out other requests. */
+					if (lockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS)
+						nStatus = NAI_UNABLE_TO_LOCK_MUTEX;												
+					
+					if (nStatus == NAI__SUCCESS) {				
+						
+						nai_write_32_ModPktCfg(unAddressOffset, unBlockConfigVal);
+						
+						/* Now we make desired number of write calls and HW will take care of SERDES packets for a block chunk up to 250 WORDS (or 125 DWORDS) */
+						for (i=0; i < unNumDataTransactions; i++) {	
+							nai_write32(unStartAddress, *punDataBuf);
+							unStartAddress += ucStride;
+							punDataBuf++;
+						}			
+						
+						if (unDataTransferLeftInWords >= NAI_OPER_MAX_PAYLOAD_IN_WORDS)
+							unDataTransferLeftInWords -= NAI_OPER_MAX_PAYLOAD_IN_WORDS;
+						else
+							unDataTransferLeftInWords = 0;
+						
+						if (unlockSERDES_Mutex(ucCompleterID) != NAI__SUCCESS) {
+							if (nStatus == NAI__SUCCESS)
+								nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;				
+						}				
+					}
+				} while (unDataTransferLeftInWords > 0 && nStatus == NAI__SUCCESS);
+			}
+		}
+	}
+	/* revert to SW BLOCK Serdes */
+	else {
+		u8 ucCompleterID = 0;
+		u32 unModuleOffset = 0;
+
+		nStatus = nai_get_module_id_and_address(unStartAddress, &ucCompleterID,
+							&unModuleOffset);
+
+		if (nStatus == NAI__SUCCESS)
+			nStatus = nai_write_block32_by_slot_request(ucCompleterID,
+									unModuleOffset,
+									unCount, ucStride,
+									punDataBuf);		
+	}
+		    
+	return nStatus;
+}
+
+static s32 nai_send_serdes_oper_msg(NAIOperMsg *ptNAIOperMsg) {
+	s32 nStatus = NAI__SUCCESS;
+	u32 i = 0;
+	u32 unAddr = 0;
+	u32 unBeginTxAddr = 0;
+	u32 nNumLoops = 0;
+	FIFOValue tFIFOVal;
+	u32 ulTimer;
+
+	if (ptNAIOperMsg == NULL)
+		return NAI_INVALID_PARAMETER_VALUE;
+
+	ulTimer = jiffies;
+	while (!nai_tx_fifo_empty(ptNAIOperMsg->tSerdesHdr.ucRequesterID,
+				  ptNAIOperMsg->tSerdesHdr.ucCompleterID)) {
+		if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT) {
+			nStatus = NAI_TX_FIFO_NOT_EMPTY_TIMEOUT;
+			break;
+		}
+		schedule();
+	}
+
+	if (nStatus == NAI__SUCCESS) {
+		unAddr = nai_get_tx_fifo_address(ptNAIOperMsg->tSerdesHdr.ucRequesterID,
+						 ptNAIOperMsg->tSerdesHdr.ucCompleterID);
+		unBeginTxAddr = nai_get_tx_fifo_pkt_ready_address(ptNAIOperMsg->tSerdesHdr.ucRequesterID,
+								  ptNAIOperMsg->tSerdesHdr.ucCompleterID);
+
+		if ((ptNAIOperMsg->tSerdesHdr.ucType & 0x01) == 0x01)
+			nNumLoops = ((TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS +
+				      (ptNAIOperMsg->tSerdesHdr.ucPayloadLength)));
+		else
+			nNumLoops = TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS;
+
+		for (i = 0; i <nNumLoops; ++i) {
+			tFIFOVal.usLoWord = ptNAIOperMsg->msg[i++];
+			tFIFOVal.usHiWord = ptNAIOperMsg->msg[i];
+
+			nai_write32_SW(unAddr, tFIFOVal.unValue);
+		}
+
+		nai_write32_SW(unBeginTxAddr, 0x01);
+	}
+
+	return nStatus;
+}
+
+static s32 nai_receive_serdes_oper_msg(NAIOperMsg *ptNAIOperMsg) {
+	s32 nStatus = NAI__SUCCESS;
+	u32 unAddr = 0;
+	FIFOValue tFIFOVal;
+	u32 unWordsRead = 0;
+	u16  usSerdesHdrWordsRead = 0;
+	s32 i = 0;
+	u16 usPacketLength = 0;
+
+	if (ptNAIOperMsg == NULL)
+		return NAI_INVALID_PARAMETER_VALUE;
+
+	nai_rx_fifo_clear_pkt_ready(ptNAIOperMsg->tSerdesHdr.ucRequesterID,
+				    ptNAIOperMsg->tSerdesHdr.ucCompleterID);
+
+	unAddr = nai_get_rx_fifo_address(ptNAIOperMsg->tSerdesHdr.ucCompleterID);
+
+	/* First we read just the SERDES Header info as we should be guaranteed this is present */
+    /* From there, we can determine how many words are part of this SERDES packet */
+	for (i = 0; i < TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS; ++i) {
+		tFIFOVal.unValue = nai_read32_SW(unAddr);
+
+		ptNAIOperMsg->msg[i++] 	= tFIFOVal.usLoWord;
+		ptNAIOperMsg->msg[i] 	= tFIFOVal.usHiWord;
+		usSerdesHdrWordsRead += 2;
+	}
+
+	/* Now we read enough to know how many words are part of this SERDES packet...so let's read the desired amount off of the FIFO */
+	usPacketLength = (ptNAIOperMsg->tSerdesHdr.ucPayloadLength); /* Payload Length for SERDES are bits 0 - 7 */	
+	while (unWordsRead < usPacketLength) {
+		tFIFOVal.unValue = nai_read32_SW(unAddr);
+
+		ptNAIOperMsg->msg[i++] = tFIFOVal.usLoWord;
+		unWordsRead++;
+		if (unWordsRead < usPacketLength) {
+			ptNAIOperMsg->msg[i++] = tFIFOVal.usHiWord;
+			unWordsRead++;
+		}
+	}
+
+	return nStatus;
+}
+
+s32 nai_read_reg16_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+				   u16 *pusValue) {
+	s32 nStatus = NAI__SUCCESS;
+	
+	FIFOValue tFIFOVal;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	u32 ulTimer;
+	NAIOperMsg tNAIOperMsg;
+
+	if (lockSERDES_Mutex(ucSlotID) != NAI__SUCCESS)
+		return NAI_UNABLE_TO_LOCK_MUTEX;
+
+	memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+	tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_READREG;
+	tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+
+	if ((unModuleOffset & 0x0003) == 0)
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = 0x3;
+	else if ((unModuleOffset & 0x0003) == 2)
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = 0xC;
+	else
+		nStatus = NAI_MIS_ALIGNED_BYTE_ENABLE;
+
+	if (nStatus == NAI__SUCCESS) {
+		tNAIOperMsg.tSerdesHdr.ucPayloadLength = (u8)(2); /* No Payload for making the request...but we must tell Keith how much data we are expecting! */
+		tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = 0; /* Make sure we have a zero "stride" for a single register read */
+
+		tFIFOVal.unValue = unModuleOffset;
+		tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+		tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;
+
+		tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+		tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+		/* Send request for data */
+		nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);
+
+		if (nStatus == NAI__SUCCESS) {			
+			/* ** NOW WAIT FOR RESPONSE ** */
+			
+			/* Prepare for response! */
+			memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+			/* Wait for packet! */
+			ulTimer = jiffies;
+			while (!nai_rx_fifo_pkt_ready(ucRequesterID, ucCompleterID)) {
+		     		if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT) {
+					nStatus = NAI_RX_FIFO_PKT_NOT_READY_TIMEOUT;
+					break;
+				}
+				schedule();
+			}
+
+			if (nStatus == NAI__SUCCESS) {
+				tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+				tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+				nStatus = nai_receive_serdes_oper_msg(&tNAIOperMsg);
+
+				if (tNAIOperMsg.tSerdesHdr.ucPayloadLength >= 2) {
+					if (tNAIOperMsg.tSerdesHdr.ucByteEnable == 0x3)
+						*pusValue = tNAIOperMsg.tSerdesPayLd.usData[0];
+					else
+						*pusValue = tNAIOperMsg.tSerdesPayLd.usData[1];
+				}
+				else
+					nStatus = NAI_SERDES_UNEXPECTED_PAYLOAD_COUNT;
+			}
+		}
+	}
+
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
+
+s32 nai_write_reg16_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+				    u16 usValue) {
+	s32 nStatus = NAI__SUCCESS;
+			
+	FIFOValue tFIFOVal;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	NAIOperMsg tNAIOperMsg;
+
+	if (lockSERDES_Mutex(ucSlotID) != NAI__SUCCESS)
+		return NAI_UNABLE_TO_LOCK_MUTEX;
+
+	memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+	/* NOTE: We initialized the entire tNAIOperMsg to zero above..so here we just flesh out those items that need to be set for this write command */
+	tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_WRITEREG;
+	tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+
+	if ((unModuleOffset & 0x0003) == 0)
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = 0x3;
+	else if ((unModuleOffset & 0x0003) == 2)
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = 0xC;
+	else
+		nStatus = NAI_MIS_ALIGNED_BYTE_ENABLE;
+
+	if (nStatus == NAI__SUCCESS) {
+		tNAIOperMsg.tSerdesHdr.ucPayloadLength = 2;    /* 2 Words (32 bit value) (Keith expects 32 bit value for now)*/
+		tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = 0; /* Make sure we have a zero "stride" for a sing register write */
+
+		tFIFOVal.unValue = unModuleOffset;
+		tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+		tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;
+
+		tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+		tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+		/* Assign Payload */
+		/* Depending on ByteEnable...we need to either write lower order or upper order bits */
+		if (tNAIOperMsg.tSerdesHdr.ucByteEnable == 0x3)	{
+			tNAIOperMsg.tSerdesPayLd.usData[0] = usValue;
+			tNAIOperMsg.tSerdesPayLd.usData[1] = 0;
+		}
+		else {
+			tNAIOperMsg.tSerdesPayLd.usData[0] = 0;
+			tNAIOperMsg.tSerdesPayLd.usData[1] = usValue;
+		}
+
+		nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);
+	}
+
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
+
+s32 nai_read_reg32_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+				   u32 *punValue) {
+	s32 nStatus = NAI__SUCCESS;
+	FIFOValue tFIFOVal;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	u32 ulTimer;
+	NAIOperMsg tNAIOperMsg;
+
+	if (lockSERDES_Mutex(ucSlotID) != NAI__SUCCESS)
+		return NAI_UNABLE_TO_LOCK_MUTEX;
+
+	memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+	tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_READREG;
+	tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+	tNAIOperMsg.tSerdesHdr.ucByteEnable = NAI_SERDES_32BITDATA;
+	tNAIOperMsg.tSerdesHdr.ucPayloadLength = 2; /* No Payload for making the request...but we must tell Keith how much data we are expecting! */
+	tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = 0; /* Make sure we have a zero "stride" for a single register read */
+
+	tFIFOVal.unValue = unModuleOffset;
+	tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+	tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;
+
+	tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+	tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+	/* Send request for data */
+	nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);
+
+	if (nStatus == NAI__SUCCESS) {
+		/* ** NOW WAIT FOR RESPONSE ** */
+
+		/* Prepare for response! */		
+		memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+		/* Wait for packet! */
+		ulTimer = jiffies;
+		while (!nai_rx_fifo_pkt_ready(ucRequesterID, ucCompleterID)) {
+			/* If FIFO did not get serviced within a reasonable amount of time..get out */
+			if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT) {
+				nStatus = NAI_RX_FIFO_PKT_NOT_READY_TIMEOUT;
+				break;
+			}
+			schedule();
+		}
+
+		if (nStatus == NAI__SUCCESS) {
+			tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+			tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+			/* Now receive the packet */
+			nStatus = nai_receive_serdes_oper_msg(&tNAIOperMsg);
+
+			if (tNAIOperMsg.tSerdesHdr.ucPayloadLength >= 2) /* One 32 bit value = 2 Words (4 Bytes) */ {
+				tFIFOVal.usLoWord = tNAIOperMsg.tSerdesPayLd.usData[0];
+				tFIFOVal.usHiWord = tNAIOperMsg.tSerdesPayLd.usData[1];
+				*punValue = (u32)tFIFOVal.unValue;
+			}
+			else
+				nStatus = NAI_SERDES_UNEXPECTED_PAYLOAD_COUNT;
+		}
+	}
+
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
+
+s32 nai_write_reg32_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+				    u32 unValue) {
+	s32 nStatus = NAI__SUCCESS;
+	FIFOValue tFIFOVal;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	NAIOperMsg tNAIOperMsg;
+
+	if (lockSERDES_Mutex(ucSlotID) != NAI__SUCCESS)
+		return NAI_UNABLE_TO_LOCK_MUTEX;
+
+	memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+	tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_WRITEREG;
+	tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+	tNAIOperMsg.tSerdesHdr.ucByteEnable = NAI_SERDES_32BITDATA;
+	tNAIOperMsg.tSerdesHdr.ucPayloadLength = 2; /* 2 Words (32 bit value) */
+	tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = 0; /* Make sure we have a zero "stride" for a sing register write */
+
+	tFIFOVal.unValue = unModuleOffset;
+	tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+	tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;
+
+	tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+	tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+	tFIFOVal.unValue = unValue;
+	tNAIOperMsg.tSerdesPayLd.usData[0] = tFIFOVal.usLoWord;
+	tNAIOperMsg.tSerdesPayLd.usData[1] = tFIFOVal.usHiWord;
+
+	nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);
+
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
+
+s32 nai_read_block16_by_slot_request(u8 ucSlotID, u32 unModuleOffsetStart,
+				     u32 unCount, u8 ucStride,
+				     u16 *pusDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	s32 nPayloadLeftToRead = (s32)(unCount);
+	u16 i;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	u32 ulTimer = 0;
+	u16 usChunkIndex = 0;
+	
+	/* SERDES HEADER */
+	FIFOValue tFIFOVal;
+	uint16_t usDataIndex = 0;
+
+	NAIOperMsg tNAIOperMsg;
+	memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+		
+	if (lockSERDES_Mutex(ucSlotID) != NAI__SUCCESS)
+		return NAI_UNABLE_TO_LOCK_MUTEX;
+
+	/* Must be 32 bit aligned */
+	if ((unModuleOffsetStart & 0x0003) != 0)
+		return NAI_MIS_ALIGNED_BYTE_ENABLE;
+								
+	/* Make sure Stide is a multiple of 4 for 32 bit alignment */
+    if ((ucStride % 4) != 0)
+		return NAI_STRIDE_CAUSES_MISALIGNMENT;
+		
+	while (nPayloadLeftToRead > 0 && nStatus == NAI__SUCCESS)
+	{
+		memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+		
+		/* NOTE: We expect data to be "packed" */
+		tNAIOperMsg.tSerdesHdr.ucDataMode = 1;
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = NAI_SERDES_32BITDATA;
+						
+		tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_READREG;
+		tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+		tNAIOperMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN(nPayloadLeftToRead, NAI_OPER_MAX_PAYLOAD_IN_WORDS)); /* No Payload for making the request!...but we must tell Keith how much data we are expecting! */
+		tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = (ucStride/4); 
+
+		tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+		tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;		
+
+		if (ucStride == 0)
+			tFIFOVal.unValue = unModuleOffsetStart;
+		else
+			tFIFOVal.unValue = (unModuleOffsetStart + (usChunkIndex * NAI_OPER_MAX_PAYLOAD_IN_WORDS * ucStride));
+
+		tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+		tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;	
+
+		/* Send request for data */
+		nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);
+
+		if (nStatus == NAI__SUCCESS)
+		{
+			/* Prepare for response! */
+			memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+			/* Wait for packet! */
+			ulTimer = jiffies;
+			while (!nai_rx_fifo_pkt_ready(ucRequesterID, ucCompleterID))
+			{
+				/* If FIFO did not get serviced within a reasonable amount of time..get out */
+				if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT)
+				{
+					nStatus = NAI_RX_FIFO_PKT_NOT_READY_TIMEOUT;
+					break;
+				}				
+			}
+
+			if (nStatus != NAI__SUCCESS)
+				break;
+				
+			tNAIOperMsg.tSerdesHdr.ucPayloadLength = (uint8_t)(MIN(nPayloadLeftToRead, NAI_OPER_MAX_PAYLOAD_IN_WORDS)); /* We must tell Keith how much data we are expecting! */
+			tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+			tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+			/* Now receive the packet */
+			nStatus = nai_receive_serdes_oper_msg(&tNAIOperMsg);
+		
+			if (nStatus == NAI__SUCCESS)
+			{
+				for (i=0; i < tNAIOperMsg.tSerdesHdr.ucPayloadLength; i++)
+					pusDataBuf[usDataIndex++] = tNAIOperMsg.tSerdesPayLd.usData[i];
+					
+				nPayloadLeftToRead -= tNAIOperMsg.tSerdesHdr.ucPayloadLength;
+			}
+			
+			usChunkIndex++;
+		}
+	}
+		
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
+
+s32 nai_write_block16_by_slot_request(u8 ucSlotID, u32 unModuleOffsetStart,
+				      u32 unCount, u8 ucStride,
+				      u16 *pusDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	u16 i;
+	FIFOValue tFIFOVal;
+	s32 nPayloadWordsLeftToWrite = (s32)(unCount * 2);
+	u16 usDataIndex = 0;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	u16 usChunkIndex = 0;
+		
+	if (lockSERDES_Mutex(ucSlotID) != NAI__SUCCESS)
+		return NAI_UNABLE_TO_LOCK_MUTEX;
+
+	/* Must be 32 bit aligned */
+	if ((unModuleOffsetStart & 0x0003) != 0)
+		return NAI_MIS_ALIGNED_BYTE_ENABLE;
+		
+    /* Make sure Stide is a multiple of 4 - 32 bit addressing */
+    if ((ucStride % 4) != 0)
+		return NAI_STRIDE_CAUSES_MISALIGNMENT;
+		
+	while (nStatus == NAI__SUCCESS && nPayloadWordsLeftToWrite > 0)
+	{
+		NAIOperMsg tNAIOperMsg;
+		memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+		tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_WRITEREG;
+		tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+		tNAIOperMsg.tSerdesHdr.ucPayloadLength = (uint8_t)MIN(nPayloadWordsLeftToWrite, NAI_OPER_MAX_PAYLOAD_IN_WORDS);
+		tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = (ucStride/4); 
+
+		if (ucStride == 0)
+			tFIFOVal.unValue = unModuleOffsetStart;
+		else
+			tFIFOVal.unValue = (unModuleOffsetStart + (usChunkIndex * NAI_OPER_MAX_PAYLOAD_IN_WORDS * ucStride));
+					
+		tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+		tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;	
+	
+		tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+		tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+		
+		/* Use Packing! */
+		tNAIOperMsg.tSerdesHdr.ucDataMode = 1;
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = NAI_SERDES_32BITDATA;
+
+		/* Assign Payload */
+		for (i=0; i < tNAIOperMsg.tSerdesHdr.ucPayloadLength; i++)
+			tNAIOperMsg.tSerdesPayLd.usData[i] = pusDataBuf[usDataIndex++];
+
+		nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);
+
+		nPayloadWordsLeftToWrite -= tNAIOperMsg.tSerdesHdr.ucPayloadLength;
+		usChunkIndex++;
+	}
+	
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
+
+s32 nai_read_block32_by_slot_request(u8 ucSlotID, u32 unModuleOffsetStart,
+				     u32 unCount, u8 ucStride,
+				     u32 *punDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	s32 nPayloadLeftToRead = (s32)(unCount * 2);  /*Number of Words (not 32 bit values)!*/
+	u16 i;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	u32 ulTimer;
+	u16 usChunkIndex = 0;
+	u16 usDataIndex = 0;	
+	FIFOValue tFIFOVal;
+	NAIOperMsg tNAIOperMsg;
+	
+	/* Must be 32 bit aligned */
+	if ((unModuleOffsetStart & 0x0003) != 0)
+		return NAI_MIS_ALIGNED_BYTE_ENABLE;
+			
+    /* SERDES uses 32 bit addressing so make sure Stride is a multiple of 4 */
+    if ((ucStride % 4) != 0)
+		return NAI_STRIDE_CAUSES_MISALIGNMENT;	
+				
+	/* SERDES HEADER */	
+	while (nPayloadLeftToRead > 0 && nStatus == NAI__SUCCESS) {
+		memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+		tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_READREG;
+		tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = NAI_SERDES_32BITDATA;
+		tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = (ucStride/4); 
+
+		tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+		tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;			
+		tNAIOperMsg.tSerdesHdr.ucPayloadLength = (u8)(MIN(nPayloadLeftToRead, NAI_OPER_MAX_PAYLOAD_IN_WORDS)); /* No Payload for making the request!...but we must tell Keith how much data we are expecting! */
+
+		if (ucStride == 0)
+			tFIFOVal.unValue = unModuleOffsetStart;
+		else
+			tFIFOVal.unValue = (unModuleOffsetStart + (usChunkIndex * (NAI_OPER_MAX_PAYLOAD_IN_WORDS/2) * ucStride));
+			
+		tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+		tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;	
+
+		/* Send request for data */
+		nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);		
+			
+		if (nStatus == NAI__SUCCESS) {			
+			/* Prepare for response! */
+			memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+			/* Wait for packet! */
+			ulTimer = jiffies;
+			while (!nai_rx_fifo_pkt_ready(ucRequesterID, ucCompleterID)) {
+				/* If FIFO did not get serviced within a reasonable amount of time..get out */
+				if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT) {
+					nStatus = NAI_RX_FIFO_PKT_NOT_READY_TIMEOUT;				
+					break;
+				}
+			}
+
+			if (nStatus != NAI__SUCCESS)
+				break;
+
+			tNAIOperMsg.tSerdesHdr.ucPayloadLength = (u8)(MIN(nPayloadLeftToRead, NAI_OPER_MAX_PAYLOAD_IN_WORDS)); /* We must tell Keith how much data we are expecting! */
+			tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+			tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+			/* Now receive the packet */
+			nStatus = nai_receive_serdes_oper_msg(&tNAIOperMsg);
+			
+			if (nStatus == NAI__SUCCESS) {
+				for (i=0; i < tNAIOperMsg.tSerdesHdr.ucPayloadLength; i++) {
+					tFIFOVal.usLoWord = tNAIOperMsg.tSerdesPayLd.usData[i++];
+					tFIFOVal.usHiWord = tNAIOperMsg.tSerdesPayLd.usData[i];
+					punDataBuf[usDataIndex++] = (u32)tFIFOVal.unValue;
+				}
+
+				nPayloadLeftToRead -= tNAIOperMsg.tSerdesHdr.ucPayloadLength;
+			}
+			
+			usChunkIndex++;
+		}
+	}		
+
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
+
+s32 nai_write_block32_by_slot_request(u8 ucSlotID, u32 unModuleOffsetStart,
+				      u32 unCount, u8 ucStride,
+				      u32 *punDataBuf) {
+	s32 nStatus = NAI__SUCCESS;
+	u16 i;
+	FIFOValue tFIFOVal;
+	s32 nPayloadWordsLeftToWrite = (s32)(unCount * 2); /*Number of Words (not 32 bit values)!*/
+	u16 usDataIndex = 0;
+	u8 ucCompleterID = ucSlotID;
+	u8 ucRequesterID = nai_get_global_slot_id();
+	u16 usChunkIndex = 0;
+	
+	if (lockSERDES_Mutex(ucSlotID) != NAI__SUCCESS)
+		return NAI_UNABLE_TO_LOCK_MUTEX;
+
+	/* Must be 32 bit aligned */
+	if ((unModuleOffsetStart & 0x0003) != 0)
+		return NAI_MIS_ALIGNED_BYTE_ENABLE;
+		
+    /* SERDES uses 32 bit addressing so make sure Stide is a multiple of 4 */
+    if ((ucStride % 4) != 0)
+		return NAI_STRIDE_CAUSES_MISALIGNMENT;
+
+	while (nStatus == NAI__SUCCESS && nPayloadWordsLeftToWrite > 0) {
+		NAIOperMsg tNAIOperMsg;
+		memset(&tNAIOperMsg.msg, 0, sizeof(tNAIOperMsg.msg));
+
+		/* NOTE: We initialized the entire tNAIOperMsg to zero above..so here we just flesh out those items that need to be set for this write command */
+		tNAIOperMsg.tSerdesHdr.ucType = NAI_SERDES_WRITEREG;
+        tNAIOperMsg.tSerdesHdr.ucToHPS = 0;
+		tNAIOperMsg.tSerdesHdr.ucByteEnable = NAI_SERDES_32BITDATA;
+		tNAIOperMsg.tSerdesHdr.ucPayloadLength = (u8)MIN(nPayloadWordsLeftToWrite, NAI_OPER_MAX_PAYLOAD_IN_WORDS);
+		tNAIOperMsg.tSerdesHdr.ucBlockAddrIncrVal = (ucStride/4); 
+
+		if (ucStride == 0)
+			tFIFOVal.unValue = unModuleOffsetStart;
+		else
+			tFIFOVal.unValue = (unModuleOffsetStart + (usChunkIndex * (NAI_OPER_MAX_PAYLOAD_IN_WORDS/2) * ucStride));
+			
+		tNAIOperMsg.tSerdesHdr.usAddressLo = tFIFOVal.usLoWord;
+		tNAIOperMsg.tSerdesHdr.usAddressHi = tFIFOVal.usHiWord;	
+	
+		tNAIOperMsg.tSerdesHdr.ucRequesterID = ucRequesterID;
+		tNAIOperMsg.tSerdesHdr.ucCompleterID = ucCompleterID;
+
+		/* Assign Payload */
+		for (i=0; i < tNAIOperMsg.tSerdesHdr.ucPayloadLength; i++) {
+			tFIFOVal.unValue = (u32)punDataBuf[usDataIndex++];
+			tNAIOperMsg.tSerdesPayLd.usData[i++] = tFIFOVal.usLoWord;
+			tNAIOperMsg.tSerdesPayLd.usData[i] = tFIFOVal.usHiWord;
+		}
+
+		nStatus = nai_send_serdes_oper_msg(&tNAIOperMsg);
+
+		nPayloadWordsLeftToWrite -= tNAIOperMsg.tSerdesHdr.ucPayloadLength;
+		usChunkIndex++;
+	}
+
+	if (unlockSERDES_Mutex(ucSlotID) != NAI__SUCCESS) {
+		if (nStatus == NAI__SUCCESS)
+			nStatus = NAI_UNABLE_TO_UNLOCK_MUTEX;
+	}
+
+	return nStatus;
+}
diff --git a/drivers/misc/nai_serdes_oper.h b/drivers/misc/nai_serdes_oper.h
new file mode 100644
index 0000000..30f4b34
--- /dev/null
+++ b/drivers/misc/nai_serdes_oper.h
@@ -0,0 +1,67 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAI_SERDES_OPER_H__
+#define __NAI_SERDES_OPER_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+/* Operational Message Utils */
+extern s32 nai_init_msg_utils(u8 ucID);
+
+/* Addressing Scheme */
+extern s32 nai_read_reg16_request(u32 unAddress, u16 *pusValue);
+extern s32 nai_write_reg16_request(u32 unAddress, u16 usValue);
+extern s32 nai_read_reg32_request(u32 unAddress, u32 *punValue);
+extern s32 nai_write_reg32_request(u32 unAddress, u32 unValue);
+extern s32 nai_read_block16_request(u32 unStartAddress, u32 unCount,
+				    u8 ucStride, u16 *pusDataBuf);
+extern s32 nai_write_block16_request(u32 unStartAddress, u32 unCount,
+				     u8 ucStride, u16 *pusDataBuf);
+extern s32 nai_read_block32_request(u32 unStartAddress, u32 unCount,
+				    u8 ucStride, u32 *punDataBuf);
+extern s32 nai_write_block32_request(u32 unStartAddress, u32 unCount,
+				     u8 ucStride, u32 *punDataBuf);
+
+/* Module Slot Scheme */
+extern s32 nai_read_reg16_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+					  u16 *pusValue);
+extern s32 nai_write_reg16_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+					   u16 usValue);
+extern s32 nai_read_reg32_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+					   u32 *punValue);
+extern s32 nai_write_reg32_by_slot_request(u8 ucSlotID, u32 unModuleOffset,
+					   u32 unValue);
+extern s32 nai_read_block16_by_slot_request(u8 ucSlotID,
+					    u32 unModuleOffsetStart,
+					    u32 unCount, u8 ucStride,
+					    u16 *pusDataBuf);
+extern s32 nai_write_block16_by_slot_request(u8 ucSlotID,
+					     u32 unModuleOffsetStart,
+					     u32 unCount, u8 ucStride,
+					     u16 *pusDataBuf);
+extern s32 nai_read_block32_by_slot_request(u8 ucSlotID,
+					    u32 unModuleOffsetStart,
+					    u32 unCount, u8 ucStride,
+					    u32 *punDataBuf);
+extern s32 nai_write_block32_by_slot_request(u8 ucSlotID,
+					     u32 unModuleOffsetStart,
+					     u32 unCount, u8 ucStride,
+					     u32 *punDataBuf);
+
+#endif /* __NAI_SERDES_OPER_H__ */
diff --git a/drivers/misc/nai_serdes_prv.h b/drivers/misc/nai_serdes_prv.h
new file mode 100644
index 0000000..824e1c8
--- /dev/null
+++ b/drivers/misc/nai_serdes_prv.h
@@ -0,0 +1,307 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAI_SERDES_PRV_H__
+#define __NAI_SERDES_PRV_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/param.h>
+
+/* Johnny?? */
+#define NAI_IGNORE_MISSING_TOP_MODULE                  1
+/* Operation timeout In milliseconds (converted to jiffies) */
+/* 5 seconds timeout */
+//#define COMPLETION_TIMEOUT                         (5000 / HZ)
+#define COMPLETION_TIMEOUT                         (5 * HZ)
+
+/* Total number of words in SERDES header */
+#define TOTAL_SERDES_READWRITEREQ_HDR_IN_WORDS     6
+
+/* Maximum number of words in the payload when in operational mode */
+#define NAI_OPER_MAX_PAYLOAD_IN_WORDS	               250
+
+/* Maximum number of words in the SERDES message */
+#define MAX_SERDES_MSG_IN_WORDS 	               256
+
+/* SERDES Command Types */
+#define NAI_SERDES_READREG                             0x0002
+#define NAI_SERDES_WRITEREG                            0x0003
+
+/* SERDES Byte Enable */
+#define NAI_SERDES_32BITDATA                           0x0F
+
+/* SERDES protocol data structures */
+typedef struct {
+	/* Bits  0-3 : Type
+	 * Bit     4 : Credit Limit
+	 * Bit     5 : SPARE
+	 * Bit     6 : SeqNumTx
+	 * Bit     7 : SeqNumRx
+	 * Bits 8-15 : Byte Enable
+	 */
+	union {
+   		u16 usSERDES0;	/* 2 Bytes */
+		struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+			u8 ucType        : 4;
+			u8 ucCreditLimit : 1;
+			u8 ucToHPS 	 	: 1;
+			u8 ucSeqNumTx 	: 1;
+			u8 ucSeqNumRx 	: 1;
+			u8 ucByteEnable : 4;
+			u8 ucSpare1		: 1;
+			u8 ucSpare2		: 1;
+			u8 ucSpare3		: 1;
+			u8 ucDataMode	: 1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+			u8 ucDataMode	: 1;
+			u8 ucSpare3		: 1;
+			u8 ucSpare2   	: 1;
+			u8 ucSpare1		: 1;
+			u8 ucByteEnable  : 4;
+			u8 ucSeqNumRx 	 : 1;
+			u8 ucSeqNumTx 	 : 1;
+			u8 ucToHPS 	 : 1;
+			u8 ucCreditLimit : 1;
+			u8 ucType 	 : 4;
+#else
+#error "Asjust your <asm/byteorder.h> defines"
+#endif
+		};
+	};
+
+	/* Bits    0-7 : Payload Max Length
+	 * Bits   8-11 : Requester ID
+	 * Bits  12-15 : Completer ID
+	  */
+	union {
+		u16 usSERDES1;    /* 2 Bytes */
+		struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+			u8 ucPayloadLength : 8;
+			u8 ucRequesterID   : 4;
+			u8 ucCompleterID   : 4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+			u8 ucCompleterID   : 4;
+			u8 ucRequesterID   : 4;
+			u8 ucPayloadLength : 8;
+#else
+#error "Asjust your <asm/byteorder.h> defines"
+#endif
+		};
+	};
+
+	/* Bits  0-1 : Reserved
+	 * Bits 2-15 : Address Lo
+	 */
+	union {
+   		u16 usSERDES2;	/* 2 Bytes */
+		u16 usAddressLo;
+	};
+
+	/* Bits 0-15 : Address Hi */
+	union {
+   		u16 usSERDES3;	/* 2 Bytes */
+		u16 usAddressHi;
+	};
+
+	/* Bits   0-7 : Block Address Increment Value
+	 * Bits  8-15 : Spare
+	 */
+	union {
+   		u16 usSERDES4;	/* 2 Bytes */
+		struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+			u8 ucBlockAddrIncrVal : 8;
+			u8 usSPARE1	      : 8;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+			u8 usSPARE1	      : 8;
+			u8 ucBlockAddrIncrVal : 8;
+#else
+#error "Asjust your <asm/byteorder.h> defines"
+#endif
+		};
+	};
+
+	/* Bits  0-15 : Spare */
+	union {
+   		u16 usSERDES5;	/* 2 Bytes */
+		u16 usSPARE2;
+	};
+} SerdesHdr;
+
+
+typedef struct {
+	/* Array of payload data of size: OPER_MAX_PAYLOAD_IN_WORDS */
+	u16 usData[NAI_OPER_MAX_PAYLOAD_IN_WORDS];
+} SerdesOperPayLd;
+
+typedef union {
+	/* Array representation of the entire NAIMsg */
+	u16 msg[MAX_SERDES_MSG_IN_WORDS];
+	struct {
+		SerdesHdr       tSerdesHdr;
+		SerdesOperPayLd tSerdesPayLd;
+	};
+} NAIOperMsg;
+
+typedef union {
+	/* 32-bit value which is comprised of the unioned Lo Word and Hi Word */
+	u32 unValue;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u32 usLoWord : 16;
+		u32 usHiWord : 16;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u32 usHiWord : 16;
+		u32 usLoWord : 16;
+#else
+#error "Asjust your <asm/byteorder.h> defines"
+#endif
+	};
+} FIFOValue;
+
+typedef union {
+	/* 16-bit value which is comprised of the unioned Lo Byte and Hi Byte */
+	u16 usValue;
+	struct {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+		u16 ucLoByte : 8;
+		u16 ucHiByte : 8;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+		u16 ucHiByte : 8;
+		u16 ucLoByte : 8;
+#else
+#error "Asjust your <asm/byteorder.h> defines"
+#endif
+	};
+} WORDValue;
+
+/* Comms protocol definitions and data structures */
+
+/* Handshake address in "Common" area */
+#define MODULE_COMMON_HANDSHAKE_ADDR  0x0000025C
+
+/* No of words in the packet header: 6W-Serdes, 8W-Transport, 6W-Command */
+#define CONFIG_TOTAL_PKT_HDR_IN_WORDS	       20
+
+/* No of words in TRANSPORT header in configuration mode */
+#define CONFIG_TOTAL_TRANSPORT_HDR_IN_WORDS        8
+
+/* No of words in COMMAND header in configuration mode **/
+#define CONFIG_TOTAL_COMMAND_HDR_IN_WORDS          6
+
+/* Max of payload words in configuration mode **/
+#define CONFIG_MAX_PAYLOAD_IN_WORDS                236
+
+/* Command Types */
+/* READ EEPROM command : used to read from the EEPROM storage */
+#define	COMMAND_TYPECODE_READEEPROM		       0x0001
+/* WRITE EEPROM command : used to write to the EEPROM storage */
+#define	COMMAND_TYPECODE_WRITEEEPROM	       0x0002
+/* ERASE FLASH command : used to erase FLASH pages */
+#define COMMAND_TYPECODE_ERASEFLASH		       0x0003
+/* READ FLASH command : used to read from the FLASH storage */
+#define	COMMAND_TYPECODE_READFLASH		       0x0004
+/* WRITE FLASH command : used to write to the FLASH storage */
+#define	COMMAND_TYPECODE_WRITEFLASH		       0x0005
+/* ASSIGN SLOT command : used to tell a module what slot it is located in */
+#define COMMAND_TYPECODE_ASSIGNSLOT		       0x0006
+/* RETRIEVE SLOT command : used to retrieve the current slot */
+#define COMMAND_TYPECODE_RETRIEVESLOT	       0x0007
+/* EXIT CONFIG MODE command : used to force exit of the CONFIG MODE app */
+#define COMMAND_TYPECODE_EXIT_CONFIG_MODE	   0x0008
+/* RESET command : used to reset this module's CPU */
+#define COMMAND_TYPECODE_RESET_MODULE	       0x0009
+/* REQUEST FINISHED command : used to send response back to caller */
+#define COMMAND_TYPECODE_REQUEST_FINISHED      0x000A
+/* CONFIG microcontroller command : used to configure all channels on a microcontroller */
+#define COMMAND_TYPECODE_CONFIG_MICRO 0x000B
+/* GET microcontroller command : used to fetch version of microcontroller bootloader and supported bootloader commands */
+#define COMMAND_TYPECODE_GET_MICRO    0x000C
+/* ERASE microcontroller command : used to erase entire EPROM in microcontroller*/
+#define COMMAND_TYPECODE_ERASE_MICRO  0x000D
+/* DEBUG command : used to run some debug tests */
+#define COMMAND_TYPECODE_DEBUG		           0x0FFF
+
+typedef struct {
+	u16 usID;
+	u16 usSequenceNum;
+	u32 unMsgLength;
+	u16 usPacketPayLdLength;
+	u16 usExpectedSequenceCount;
+	u32 unCRC;
+} TransportHdr;
+
+typedef struct {
+	u16  usCommandType;
+	u16  usChipID;
+	u32  unOffset;
+	u32  unPayLdRequestLength;
+} CommandHdr;
+
+typedef struct {
+	u16 usData[CONFIG_MAX_PAYLOAD_IN_WORDS];
+} CommandPayLd;
+
+typedef struct {
+	CommandHdr   tCommandHdr;
+	CommandPayLd tCommandPayLd;
+} TransportPayLd;
+
+typedef struct {
+	TransportHdr   tTransportHdr;
+	TransportPayLd tTransportPayLd;
+} SerdesConfigPayLd;
+
+
+typedef union {
+	/* Array representation of the entire NAIMsg */
+	u16 msg[MAX_SERDES_MSG_IN_WORDS];
+	struct {
+		/* SerdesHdr encapsulates SERDES specific information */
+		SerdesHdr   tSerdesHdr;
+		/* SerdesConfigPayLd encapsulates all of the other layers of the
+		 * message protocol including the Transport mechanism and
+		 * Command information
+		 */
+		SerdesConfigPayLd tSerdesPayLd;
+	};
+} NAIMsg;
+
+
+typedef struct _MsgPacket {
+	NAIMsg tNAIMsg;
+	struct _MsgPacket *ptNext;
+} MsgPacket;
+
+typedef struct _MsgPacketList {
+	s32 nCount;
+	s32 unWordsLeftToRead;
+	MsgPacket *ptStart;
+	MsgPacket *ptEnd;
+	struct _MsgPacketList *ptNext;
+} MsgPacketList;
+
+typedef struct {
+	s32 nCount;
+	MsgPacketList *ptStart;
+	MsgPacketList *ptEnd;
+} MsgList;
+
+#endif /* __NAI_SERDES_PRV_H__ */
diff --git a/drivers/misc/nai_serdes_utils.c b/drivers/misc/nai_serdes_utils.c
new file mode 100644
index 0000000..c0fe02c
--- /dev/null
+++ b/drivers/misc/nai_serdes_utils.c
@@ -0,0 +1,611 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/semaphore.h>
+#include <asm/io.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+#include <linux/printk.h>
+
+#include "nai_serdes.h"
+#include "nai_serdes_prv.h"
+#include "nai_serdes_utils.h"
+
+static void* g_LWHPS2FPGA_VirtualBaseHW = NULL; /*Hardware SERDES*/
+static void* g_LWHPS2FPGA_VirtualBaseSW = NULL; /*Software SERDES*/
+static void* g_MODULEPKTCFG_VirtualBase = NULL; /*Module Pkt Config*/
+ 
+#define NAI_ACTUAL_MAX_SLOTS		 6
+
+static u16 g_usMaxSlotCount        = NAI_THEORETICAL_MAX_SLOTS;
+static u8  g_ucMsgUtilsInitialized = 0;
+static u8  ucHardCodedModuleSlot   = 0;
+static u8  g_ucSlotID              = NAI_INVALID_SLOT;
+static u32 g_unModuleStartAddresses[NAI_THEORETICAL_MAX_SLOTS];
+
+static u32 nai_is_mb(u8 ucSlotID);
+
+static u32 nai_is_mb(u8 ucSlotID) {
+	u32 is_mb = 0;
+
+	if ((ucSlotID == NAI_MB_SLOT) || (ucSlotID == NAI_PPC_MB_SLOT))
+		is_mb = 1;
+
+	return is_mb;
+}
+
+void nai_set_virtual_base_hw(void *addr) {
+	g_LWHPS2FPGA_VirtualBaseHW = addr;
+	if (g_LWHPS2FPGA_VirtualBaseHW != NULL)
+		pr_debug("SERDES HW: base addr=%p\n", g_LWHPS2FPGA_VirtualBaseHW);
+	else
+		pr_debug("SERDES HW IS NOT SUPPORTED\n");
+}
+
+void nai_set_virtual_base_sw(void *addr) {	
+	g_LWHPS2FPGA_VirtualBaseSW = addr;
+	if (g_LWHPS2FPGA_VirtualBaseSW != NULL)
+		pr_debug("SERDES SW: base addr=%p\n", g_LWHPS2FPGA_VirtualBaseSW);
+	else
+		pr_debug("SERDES SW IS NOT SUPPORTED\n");
+}
+
+void nai_set_virtual_base_module_pkt_config(void *addr) {
+	g_MODULEPKTCFG_VirtualBase = addr;
+	if (g_MODULEPKTCFG_VirtualBase != NULL)
+		pr_debug("MOUDLE PKT CONFIG: base addr=%p\n", g_MODULEPKTCFG_VirtualBase);
+	else
+		pr_debug("SERDES HW BLOCK IS NOT SUPPORTED\n");
+}
+
+void nai_assign_hard_coded_module_slot(uint8_t ucSlotID) {
+	ucHardCodedModuleSlot = ucSlotID;
+}
+
+s32 nai_perform_init_slot_addressing(u32 *puModAddresses, u8 ucSize) {
+	s32 nStatus = NAI__SUCCESS;
+    
+	if (ucHardCodedModuleSlot == 0) {
+		u32 i = 0;
+
+		if (g_ucMsgUtilsInitialized == 1) {
+			goto exit;
+		}
+
+		if (ucSize < NAI_ACTUAL_MAX_SLOTS)
+		{
+			nStatus = NAI_INVALID_PARAMETER_VALUE;
+			goto exit;
+		}
+			
+		for (i = 0; i < NAI_THEORETICAL_MAX_SLOTS; ++i) {
+			/* First initialize the entry to all F's */
+			g_unModuleStartAddresses[i] = 0xFFFFFFFF;
+
+			if (i < NAI_ACTUAL_MAX_SLOTS) {
+				g_unModuleStartAddresses[i] = puModAddresses[i];
+			}
+		}
+	}
+	
+	if (nStatus == NAI__SUCCESS)
+		g_ucMsgUtilsInitialized = 1;	
+exit:
+	return nStatus;
+}
+
+s32 nai_retreive_module_slots_status_request(u16 *pusSlotIDs) {
+	s32 nStatus = NAI__SUCCESS;
+	u32 unModuleDetectedStatus = 0x00000100;
+	FIFOValue tFIFOVal;
+	u32 ulTimer;
+
+	ulTimer = jiffies;
+	while (1) {
+		tFIFOVal.unValue = nai_read32(unModuleDetectedStatus);
+		if ((tFIFOVal.unValue & 0x3F00) == 0x3F00)
+			break;
+
+		if (((s32)jiffies - (s32)ulTimer) > COMPLETION_TIMEOUT) {
+			nStatus = NAI_DETECT_MODULES_TIMEOUT;
+			break;
+		}
+		schedule();
+	}
+
+	if (nStatus == NAI__SUCCESS) {
+		/* Now that detection process is complete..we can get the module status */
+		*pusSlotIDs = (u16)(tFIFOVal.unValue & 0x003F);
+	}
+
+	return nStatus;
+}
+
+s32 nai_get_start_address_for_slot(u8 ucSlotID, u32 *punModuleStartAddress) {
+	s32 nStatus = NAI__SUCCESS;
+	
+	if (ucSlotID == 0 || ucSlotID >= NAI_THEORETICAL_MAX_SLOTS)
+		nStatus = NAI_ERROR_WRONG_SLOT_NUM;
+		
+	*punModuleStartAddress = g_unModuleStartAddresses[(ucSlotID-1)];
+	
+	return nStatus;
+}
+
+s32 nai_get_module_id_and_address(u32 unAddress, u8 *pucModuleID,
+				  u32 *punModuleAddress) {
+	s32 nStatus = NAI__SUCCESS;
+
+	if (!ucHardCodedModuleSlot)	{
+		u8 i = 0;
+		u8 k = 0;
+		u32 bFound = 0;
+
+		for (i = 0; i < NAI_THEORETICAL_MAX_SLOTS; ++i) {
+			/* Skip over any unused module slots */
+			if (g_unModuleStartAddresses[i] == 0xFFFFFFFF)
+				continue;
+
+			if (unAddress == g_unModuleStartAddresses[i]) {
+				*pucModuleID = (i + 1);
+				*punModuleAddress = unAddress -
+					g_unModuleStartAddresses[i];
+				bFound = 1;
+				break;
+			}
+
+			k = i + 1;
+			while ((k < NAI_THEORETICAL_MAX_SLOTS) &&
+			       (g_unModuleStartAddresses[k] == 0xFFFFFFFF))
+				k++;
+
+			/* If no more slots to check...break */
+			if (k == NAI_THEORETICAL_MAX_SLOTS) {
+				if (unAddress > g_unModuleStartAddresses[i]) {
+					*pucModuleID = (i + 1);
+					*punModuleAddress = unAddress -
+						g_unModuleStartAddresses[i];
+					bFound = 1;
+				}
+				break;
+			}
+
+			/* Now let's check to see if we found the slot the given address belongs to */
+			if ((unAddress > g_unModuleStartAddresses[i]) &&
+			    (unAddress < g_unModuleStartAddresses[k])) {
+				*pucModuleID = (i + 1);
+				*punModuleAddress = unAddress -
+					g_unModuleStartAddresses[i];
+				bFound = 1;
+				break;
+			}
+
+			i = k - 1;
+		}
+
+		if (!bFound)
+			nStatus = NAI_MODULE_NOT_FOUND;
+	}
+	else {
+		*pucModuleID = ucHardCodedModuleSlot;
+		*punModuleAddress = unAddress;
+	}
+
+	return nStatus;
+}
+
+s32 nai_get_module_packet_config_address_offset(u32 unAddress, u8 ucCompleterID, u32 *punPacketConfigAddressOffset) {
+	s32 nStatus = NAI__SUCCESS;
+
+	switch (ucCompleterID) {
+		case 1 :
+			*punPacketConfigAddressOffset = 0x00000000; /*0x43C100A0*/
+			break;
+		case 2 :
+			*punPacketConfigAddressOffset = 0x00000004; /*0x43C100A4*/
+			break;
+		case 3 :
+			*punPacketConfigAddressOffset = 0x00000008; /*0x43C100A8*/
+			break;
+		case 4 :
+			*punPacketConfigAddressOffset = 0x0000000C; /*0x43C100AC*/
+			break;
+		case 5 :
+			*punPacketConfigAddressOffset = 0x00000010; /*0x43C100B0*/
+			break;
+		case 6 :
+			*punPacketConfigAddressOffset = 0x00000014; /*0x43C100B4*/
+			break;
+		default :
+			nStatus = NAI_INVALID_ADDRESS;
+			break;		
+	}
+    
+	return nStatus;
+}
+
+void nai_write16(u32 unAddress, u16 usValue) {
+	if (g_LWHPS2FPGA_VirtualBaseSW != NULL) {
+		pr_debug("SERDES SW: WR16 addr=%p val=0x%04X\n",
+			 (void *)(g_LWHPS2FPGA_VirtualBaseSW + unAddress), usValue);
+
+		iowrite16(usValue, g_LWHPS2FPGA_VirtualBaseSW + unAddress);
+	}
+	else
+		pr_debug("SERDES SW IS NOT SUPPORTED\n");
+}
+
+u16 nai_read16(u32 unAddress) {
+	u16 val = 0;
+	if (g_LWHPS2FPGA_VirtualBaseSW != NULL) {
+		val = ioread16(g_LWHPS2FPGA_VirtualBaseSW + unAddress);
+
+		pr_debug("SERDES SW: RD16 addr=%p val=0x%04X\n",
+			 (void *)(g_LWHPS2FPGA_VirtualBaseSW + unAddress), val);
+	}
+	else
+		pr_debug("SERDES SW IS NOT SUPPORTED\n");
+		
+	return val;
+}
+
+void nai_write32(u32 unAddress, u32 unValue) {
+	if (g_LWHPS2FPGA_VirtualBaseHW != NULL) {	
+		pr_debug("SERDES HW: WR32 addr=%p val=0x%08X\n",
+			 (void *)(g_LWHPS2FPGA_VirtualBaseHW + unAddress), unValue);
+		
+		iowrite32(unValue, g_LWHPS2FPGA_VirtualBaseHW + unAddress);
+	}
+	else
+		pr_debug("SERDES HW IS NOT SUPPORTED\n");
+}
+
+u32 nai_read32(u32 unAddress) {
+	u32 val = 0;
+	if (g_LWHPS2FPGA_VirtualBaseHW != NULL) {
+		val = ioread32(g_LWHPS2FPGA_VirtualBaseHW + unAddress);
+
+		pr_debug("SERDES HW: RD32 addr=%p val=0x%08X\n",
+			 (void *)(g_LWHPS2FPGA_VirtualBaseHW + unAddress), val);
+	}
+	else
+		pr_debug("SERDES HW IS NOT SUPPORTED\n");
+			 
+	return val;
+}
+
+void nai_write32_SW(u32 unAddress, u32 unValue) {
+	if (g_LWHPS2FPGA_VirtualBaseSW != NULL) {
+		pr_debug("SERDES SW: WR32 addr=%p val=0x%08X\n",
+			 (void *)(g_LWHPS2FPGA_VirtualBaseSW + unAddress), unValue);
+		
+		iowrite32(unValue, g_LWHPS2FPGA_VirtualBaseSW + unAddress);
+	}
+	else
+		pr_debug("SERDES SW IS NOT SUPPORTED\n");
+}
+
+u32 nai_read32_SW(u32 unAddress) {
+	u32 val = 0;
+	if (g_LWHPS2FPGA_VirtualBaseSW != NULL) {
+		val = ioread32(g_LWHPS2FPGA_VirtualBaseSW + unAddress);
+
+		pr_debug("SERDES SW: RD32 addr=%p val=0x%08X\n",
+			 (void *)(g_LWHPS2FPGA_VirtualBaseSW + unAddress), val);
+	}
+	else
+		pr_debug("SERDES SW IS NOT SUPPORTED\n");
+			 
+	return val;
+}
+
+void nai_write_32_ModPktCfg(u32 unAddressOffset, u32 unValue) {
+	if (g_MODULEPKTCFG_VirtualBase != NULL) {
+		pr_debug("MOUDLE PKT CONFIG: WR32 addr=%p val=0x%08X\n",
+			 (void *)(g_MODULEPKTCFG_VirtualBase + unAddressOffset), unValue);
+		
+		iowrite32(unValue, g_MODULEPKTCFG_VirtualBase + unAddressOffset);	
+	}
+	else
+		pr_debug("SERDES HW BLOCK IS NOT SUPPORTED\n");
+}
+
+u32 nai_read32_ModPktCfg(u32 unAddressOffset) {
+	u32 val = 0;
+	if (g_MODULEPKTCFG_VirtualBase != NULL) {
+		val = ioread32(g_MODULEPKTCFG_VirtualBase + unAddressOffset);
+
+		pr_debug("MOUDLE PKT CONFIG: RD32 addr=%p val=0x%08X\n",
+			 (void *)(g_MODULEPKTCFG_VirtualBase + unAddressOffset), val);
+	}
+			 
+	return val;
+}
+
+u32 nai_get_tx_fifo_address(u8 ucRequesterID, u8 ucCompleterID) {
+	u32 unTxAddr = 0;
+
+	if (nai_is_mb(ucRequesterID)) {
+		switch (ucCompleterID) {
+		case NAI_MODULE_1_SLOT:
+			unTxAddr = 0x00000000;
+			break;
+
+		case NAI_MODULE_2_SLOT:
+			unTxAddr = 0x00000004;
+			break;
+
+		case NAI_MODULE_3_SLOT:
+			unTxAddr = 0x00000008;
+			break;
+
+		case NAI_MODULE_4_SLOT:
+			unTxAddr = 0x0000000C;
+			break;
+
+		case NAI_MODULE_5_SLOT:
+			unTxAddr = 0x00000010;
+			break;
+
+		case NAI_MODULE_6_SLOT:
+			unTxAddr = 0x00000014;
+			break;
+		}
+	}
+
+	return unTxAddr;
+}
+
+u32 nai_get_tx_fifo_pkt_ready_address(u8 ucRequesterID, u8 ucCompleterID) {
+	u32 unTxPktReadyAddr = 0x00000020;
+
+	if (nai_is_mb(ucRequesterID)) {
+		switch (ucCompleterID) {
+		case NAI_MODULE_1_SLOT:
+			unTxPktReadyAddr = 0x00000020;
+			break;
+
+		case NAI_MODULE_2_SLOT:
+			unTxPktReadyAddr = 0x00000024;
+			break;
+
+		case NAI_MODULE_3_SLOT:
+			unTxPktReadyAddr = 0x00000028;
+			break;
+
+		case NAI_MODULE_4_SLOT:
+			unTxPktReadyAddr = 0x0000002C;
+			break;
+
+		case NAI_MODULE_5_SLOT:
+			unTxPktReadyAddr = 0x00000030;
+			break;
+
+		case NAI_MODULE_6_SLOT:
+			unTxPktReadyAddr = 0x00000034;
+			break;
+		}
+	}
+
+	return unTxPktReadyAddr;
+}
+
+u32 nai_get_rx_fifo_address(u8 ucCompleterID) {
+	u32 unRxAddr = 0x00000080;
+
+	if (nai_is_mb(g_ucSlotID)) {
+		switch (ucCompleterID) {
+		case NAI_MODULE_1_SLOT:
+			unRxAddr = 0x00000080;
+			break;
+
+		case NAI_MODULE_2_SLOT:
+			unRxAddr = 0x00000084;
+			break;
+
+		case NAI_MODULE_3_SLOT:
+			unRxAddr = 0x00000088;
+			break;
+
+		case NAI_MODULE_4_SLOT:
+			unRxAddr = 0x0000008C;
+			break;
+
+		case NAI_MODULE_5_SLOT:
+			unRxAddr = 0x00000090;
+			break;
+
+		case NAI_MODULE_6_SLOT:
+			unRxAddr = 0x00000094;
+			break;
+		}
+	}
+
+	return unRxAddr;
+}
+
+u32 nai_get_rx_fifo_num_words_address(u8 ucRequesterID, u8 ucCompleterID) {
+	u32 unRxNumWordsAddr = 0x000000A0;
+
+	if (nai_is_mb(ucRequesterID)) {
+		switch (ucCompleterID) {
+		case NAI_MODULE_1_SLOT:
+			unRxNumWordsAddr = 0x000000A0;
+			break;
+
+		case NAI_MODULE_2_SLOT:
+			unRxNumWordsAddr = 0x000000A4;
+			break;
+
+		case NAI_MODULE_3_SLOT:
+			unRxNumWordsAddr = 0x000000A8;
+			break;
+
+		case NAI_MODULE_4_SLOT:
+			unRxNumWordsAddr = 0x000000AC;
+			break;
+
+		case NAI_MODULE_5_SLOT:
+			unRxNumWordsAddr = 0x000000B0;
+			break;
+
+		case NAI_MODULE_6_SLOT:
+			unRxNumWordsAddr = 0x000000B4;
+			break;
+		}
+	}
+
+	return unRxNumWordsAddr;
+}
+
+u32 nai_tx_fifo_empty(u8 ucRequesterID, u8 ucCompleterID) {
+	u32 bFIFOEmpty = 1;
+	u32 unFIFOsEmptyStatusRegister = 0x00000040;
+	u8 ucTemp;
+
+	if (ucRequesterID == NAI_ASSIGNED_SLOT)
+		ucRequesterID = g_ucSlotID;
+
+	if (nai_is_mb(ucRequesterID)) {
+		if (ucCompleterID > g_usMaxSlotCount)
+			return 0;
+
+		unFIFOsEmptyStatusRegister = 0x00000040;
+
+		ucTemp = (u8)(nai_read16(unFIFOsEmptyStatusRegister));
+		bFIFOEmpty = (((ucTemp >> (ucCompleterID-1)) & 0x01) == 0x01);
+	}
+	else {
+		ucTemp = (u8)(nai_read16(unFIFOsEmptyStatusRegister));
+		bFIFOEmpty = (ucTemp == 0x01);
+	}
+
+	return bFIFOEmpty;
+}
+
+u32 nai_rx_fifo_empty(u8 ucRequesterID, u8 ucCompleterID) {
+	u32 bFIFOEmpty = 1;
+	u32 unFIFOsEmptyStatusRegister = 0x000000C0;
+	u8 ucTemp;
+
+	if (ucRequesterID == NAI_ASSIGNED_SLOT)
+		ucRequesterID = g_ucSlotID;
+
+	if (nai_is_mb(ucRequesterID)) {
+		if (ucCompleterID > g_usMaxSlotCount)
+			return 0;
+
+		unFIFOsEmptyStatusRegister = 0x000000C0;
+
+		ucTemp = (u8)(nai_read16(unFIFOsEmptyStatusRegister));
+		bFIFOEmpty = (((ucTemp >> (ucCompleterID-1)) & 0x01) == 0x01);
+	}
+	else {
+		u8 ucTemp = (u8)(nai_read16(unFIFOsEmptyStatusRegister));
+		bFIFOEmpty = (ucTemp == 0x01);
+	}
+
+	return bFIFOEmpty;
+}
+
+u32 nai_rx_fifo_pkt_ready(u8 ucRequesterID, u8 ucCompleterID) {
+	u32 bPktReady = 0;
+	u32 unFIFOsPktReadyStatusRegister = 0x000000E4;
+	u8 ucTemp;
+
+	if (ucRequesterID == NAI_ASSIGNED_SLOT)
+		ucRequesterID = g_ucSlotID;
+
+	if (nai_is_mb(ucRequesterID)) {
+		if (ucCompleterID > g_usMaxSlotCount)
+			return 0;
+
+		unFIFOsPktReadyStatusRegister = 0x000000E4;
+
+		ucTemp = (u8)(nai_read16(unFIFOsPktReadyStatusRegister));
+		bPktReady = (((ucTemp >> (ucCompleterID-1)) & 0x01) == 0x01);
+	}
+	else {
+		ucTemp = (u8)(nai_read16(unFIFOsPktReadyStatusRegister));
+		bPktReady = (ucTemp == 0x01);
+	}
+
+	return bPktReady;
+}
+
+void nai_rx_fifo_clear_pkt_ready(u8 ucRequesterID, u8 ucCompleterID) {
+	u32 unFIFOsClearPktReadyStatusRegister = 0x000000E4;
+
+	if (ucRequesterID == NAI_ASSIGNED_SLOT)
+		ucRequesterID = g_ucSlotID;
+
+	if (nai_is_mb(ucRequesterID)) {
+		if (ucCompleterID > g_usMaxSlotCount)
+			return;
+
+		unFIFOsClearPktReadyStatusRegister = 0x000000E4;
+
+		/* Write a 1 to clear pkt Ready Status register */
+		nai_write16(unFIFOsClearPktReadyStatusRegister,
+			    (u16)(0x01 << (ucCompleterID-1)));
+	}
+	else {
+		nai_write16(unFIFOsClearPktReadyStatusRegister, (u16)0x0001);
+	}
+}
+
+s32 nai_init_as_slot(u8 ucSlotID) {
+	if (ucSlotID > g_usMaxSlotCount)
+		return NAI_INVALID_SLOT_ID;
+		
+	g_ucSlotID = ucSlotID;
+
+	return NAI__SUCCESS;
+}
+
+u8 nai_get_global_slot_id(void) {
+	return g_ucSlotID;
+}
+
+u16 nai_get_max_slot_count(void) {
+	return g_usMaxSlotCount;
+}
+
+u32 convert_bytes_to_words(u32 unBytes) {
+	u32 unWordCount = 0;
+
+	if (unBytes & 0x01)
+		unWordCount = 1;
+
+	unWordCount += unBytes / 2;
+
+	return unWordCount;
+}
+
+u8 nai_is_hw_serdes_capable(void) {
+	return ((g_LWHPS2FPGA_VirtualBaseHW != NULL)?1:0);
+}
+
+u8 nai_is_sw_serdes_capable(void) {
+	return ((g_LWHPS2FPGA_VirtualBaseSW != NULL)?1:0);
+}
+
+u8 nai_is_hw_block_serdes_capable(void) {
+	return (((g_MODULEPKTCFG_VirtualBase != NULL) && (g_LWHPS2FPGA_VirtualBaseHW != NULL))?1:0);
+}
diff --git a/drivers/misc/nai_serdes_utils.h b/drivers/misc/nai_serdes_utils.h
new file mode 100644
index 0000000..19a0c35
--- /dev/null
+++ b/drivers/misc/nai_serdes_utils.h
@@ -0,0 +1,66 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAI_SERDES_UTILS_H__
+#define __NAI_SERDES_UTILS_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#define NAI_THEORETICAL_MAX_SLOTS   10
+/* MessageUtils */
+extern u32 convert_bytes_to_words(u32 ulBytes);
+
+/* MessageProcessing */
+extern s32 nai_perform_init_slot_addressing(u32 *puModAddresses, u8 ucSize);
+extern s32 nai_get_start_address_for_slot(u8 ucSlotID, u32 *punModuleStartAddress);
+extern s32 nai_get_module_id_and_address(u32 unAddress, u8 *pucModuleID, u32 *punModuleAddress);
+extern s32 nai_get_module_packet_config_address_offset(u32 unAddress, u8 ucCompleterID, u32 *punPacketConfigAddressOffset);
+					 
+extern void nai_write16(u32 unAddress, u16 usValue);
+extern u16 nai_read16(u32 unAddress);
+extern void nai_write32(u32 unAddress, u32 unValue);		/* Uses hardware serdes */
+extern u32 nai_read32(u32 unAddress);						/* Uses hardware serdes */
+extern void nai_write32_SW(u32 unAddress, u32 unValue);		/* Uses software serdes */
+extern u32 nai_read32_SW(u32 unAddress);  					/* Uses software serdes */
+extern void nai_write_32_ModPktCfg(u32 unAddressOffset, u32 unValue);
+extern u32 nai_read32_ModPktCfg(u32 unAddressOffset);
+
+extern u32 nai_get_tx_fifo_address(u8 ucRequesterID, u8 ucCompleterID);
+extern u32 nai_get_tx_fifo_pkt_ready_address(u8 ucRequesterID,
+					     u8 ucCompleterID);
+extern u32 nai_get_rx_fifo_address(u8 ucCompleterID);
+extern u32 nai_get_rx_fifo_num_words_address(u8 ucRequesterID,
+					     u8 ucCompleterID);
+extern u32 nai_tx_fifo_empty(u8 ucRequesterID, u8 ucCompleterID);
+extern u32 nai_rx_fifo_empty(u8 ucRequesterID, u8 ucCompleterID);
+extern u32 nai_rx_fifo_pkt_ready(u8 ucRequesterID, u8 ucCompleterID);
+extern void nai_rx_fifo_clear_pkt_ready(u8 ucRequesterID, u8 ucCompleterID);
+
+/* HighLevelAPI */
+extern void nai_assign_hard_coded_module_slot(u8 ucSlotID);
+extern s32 nai_retreive_module_slots_status_request(u16 *pusSlotIDs);
+extern s32 nai_init_as_slot(u8 ucSlotID);
+extern u16 nai_get_max_slot_count(void);
+extern u8 nai_get_global_slot_id(void);
+extern void nai_set_virtual_base_hw(void *addr);
+extern void nai_set_virtual_base_sw(void *addr);
+extern void nai_set_virtual_base_module_pkt_config(void *addr);
+extern u8 nai_is_hw_serdes_capable(void);
+extern u8 nai_is_sw_serdes_capable(void);
+extern u8 nai_is_hw_block_serdes_capable(void);
+#endif /* __NAI_SERDES_UTILS_H__ */
diff --git a/drivers/net/ethernet/cadence/Makefile b/drivers/net/ethernet/cadence/Makefile
index 1f33cdc..b26c83e 100644
--- a/drivers/net/ethernet/cadence/Makefile
+++ b/drivers/net/ethernet/cadence/Makefile
@@ -8,5 +8,5 @@ ifeq ($(CONFIG_MACB_USE_HWSTAMP),y)
 macb-y	+= macb_ptp.o
 endif
 
-obj-$(CONFIG_MACB) += macb.o
+obj-$(CONFIG_MACB) += macb.o macb_mdio.o
 obj-$(CONFIG_MACB_PCI) += macb_pci.o
diff --git a/drivers/net/ethernet/cadence/macb.h b/drivers/net/ethernet/cadence/macb.h
index 70252f2..1173310 100644
--- a/drivers/net/ethernet/cadence/macb.h
+++ b/drivers/net/ethernet/cadence/macb.h
@@ -1047,6 +1047,7 @@ struct macb {
 	struct mii_bus		*mii_bus;
 	struct phy_device	*phy_dev;
 	struct device_node	*phy_node;
+	int 			phy_irq;
 	int 			link;
 	int 			speed;
 	int 			duplex;
diff --git a/drivers/net/ethernet/cadence/macb_main.c b/drivers/net/ethernet/cadence/macb_main.c
index 2624fc2..4731735 100644
--- a/drivers/net/ethernet/cadence/macb_main.c
+++ b/drivers/net/ethernet/cadence/macb_main.c
@@ -321,117 +321,6 @@ static void macb_get_hwaddr(struct macb *bp)
 	eth_hw_addr_random(bp->dev);
 }
 
-static int macb_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
-{
-	struct macb *bp = bus->priv;
-	int value;
-	int err;
-	ulong timeout;
-
-	err = pm_runtime_get_sync(&bp->pdev->dev);
-	if (err < 0)
-		return err;
-
-	timeout = jiffies + msecs_to_jiffies(1000);
-	/* wait for end of transfer */
-	do {
-		if (MACB_BFEXT(IDLE, macb_readl(bp, NSR)))
-			break;
-
-		cpu_relax();
-	} while (!time_after_eq(jiffies, timeout));
-
-	if (time_after_eq(jiffies, timeout)) {
-		netdev_err(bp->dev, "wait for end of transfer timed out\n");
-		pm_runtime_mark_last_busy(&bp->pdev->dev);
-		pm_runtime_put_autosuspend(&bp->pdev->dev);
-		return -ETIMEDOUT;
-	}
-
-	macb_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF)
-			      | MACB_BF(RW, MACB_MAN_READ)
-			      | MACB_BF(PHYA, mii_id)
-			      | MACB_BF(REGA, regnum)
-			      | MACB_BF(CODE, MACB_MAN_CODE)));
-
-	timeout = jiffies + msecs_to_jiffies(1000);
-	/* wait for end of transfer */
-	do {
-		if (MACB_BFEXT(IDLE, macb_readl(bp, NSR)))
-			break;
-
-		cpu_relax();
-	} while (!time_after_eq(jiffies, timeout));
-
-	if (time_after_eq(jiffies, timeout)) {
-		netdev_err(bp->dev, "wait for end of transfer timed out\n");
-		pm_runtime_mark_last_busy(&bp->pdev->dev);
-		pm_runtime_put_autosuspend(&bp->pdev->dev);
-		return -ETIMEDOUT;
-	}
-
-	value = MACB_BFEXT(DATA, macb_readl(bp, MAN));
-
-	pm_runtime_mark_last_busy(&bp->pdev->dev);
-	pm_runtime_put_autosuspend(&bp->pdev->dev);
-	return value;
-}
-
-static int macb_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
-			   u16 value)
-{
-	struct macb *bp = bus->priv;
-	int err;
-	ulong timeout;
-
-	err = pm_runtime_get_sync(&bp->pdev->dev);
-	if (err < 0)
-		return err;
-
-	timeout = jiffies + msecs_to_jiffies(1000);
-	/* wait for end of transfer */
-	do {
-		if (MACB_BFEXT(IDLE, macb_readl(bp, NSR)))
-			break;
-
-		cpu_relax();
-	} while (!time_after_eq(jiffies, timeout));
-
-	if (time_after_eq(jiffies, timeout)) {
-		netdev_err(bp->dev, "wait for end of transfer timed out\n");
-		pm_runtime_mark_last_busy(&bp->pdev->dev);
-		pm_runtime_put_autosuspend(&bp->pdev->dev);
-		return -ETIMEDOUT;
-	}
-
-	macb_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF)
-			      | MACB_BF(RW, MACB_MAN_WRITE)
-			      | MACB_BF(PHYA, mii_id)
-			      | MACB_BF(REGA, regnum)
-			      | MACB_BF(CODE, MACB_MAN_CODE)
-			      | MACB_BF(DATA, value)));
-
-	timeout = jiffies + msecs_to_jiffies(1000);
-	/* wait for end of transfer */
-	do {
-		if (MACB_BFEXT(IDLE, macb_readl(bp, NSR)))
-			break;
-
-		cpu_relax();
-	} while (!time_after_eq(jiffies, timeout));
-
-	if (time_after_eq(jiffies, timeout)) {
-		netdev_err(bp->dev, "wait for end of transfer timed out\n");
-		pm_runtime_mark_last_busy(&bp->pdev->dev);
-		pm_runtime_put_autosuspend(&bp->pdev->dev);
-		return -ETIMEDOUT;
-	}
-
-	pm_runtime_mark_last_busy(&bp->pdev->dev);
-	pm_runtime_put_autosuspend(&bp->pdev->dev);
-	return 0;
-}
-
 /**
  * macb_set_tx_clk - Set a clock to a new frequency
  * @clk:	Pointer to the clock to change
@@ -546,42 +435,25 @@ static void macb_handle_link_change(struct net_device *dev)
 static int macb_mii_probe(struct net_device *dev)
 {
 	struct macb *bp = netdev_priv(dev);
-	struct macb_platform_data *pdata;
 	struct phy_device *phydev;
-	int phy_irq;
 	int ret;
 
-	if (bp->phy_node) {
-		phydev = of_phy_connect(dev, bp->phy_node,
-					&macb_handle_link_change, 0,
-					bp->phy_interface);
-		if (!phydev)
-			return -ENODEV;
-	} else {
-		phydev = phy_find_first(bp->mii_bus);
-		if (!phydev) {
-			netdev_err(dev, "no PHY found\n");
-			return -ENXIO;
-		}
-
-		pdata = dev_get_platdata(&bp->pdev->dev);
-		if (pdata && gpio_is_valid(pdata->phy_irq_pin)) {
-			ret = devm_gpio_request(&bp->pdev->dev,
-						pdata->phy_irq_pin, "phy int");
-			if (!ret) {
-				phy_irq = gpio_to_irq(pdata->phy_irq_pin);
-				phydev->irq = (phy_irq < 0) ?
-					      PHY_POLL : phy_irq;
-			}
-		}
+	if (bp->phy_dev)
+		return 0;
 
-		/* attach the mac to the phy */
-		ret = phy_connect_direct(dev, phydev, &macb_handle_link_change,
-					 bp->phy_interface);
-		if (ret) {
-			netdev_err(dev, "Could not attach to PHY\n");
-			return ret;
-		}
+	phydev = of_phy_find_device(bp->phy_node);
+	if (!phydev) {
+		netdev_err(dev, "no PHY found\n");
+		return -ENXIO;
+	}
+	if (bp->phy_irq)
+		phydev->irq = bp->phy_irq;
+	/* attach the mac to the phy */
+	ret = phy_connect_direct(dev, phydev, &macb_handle_link_change,
+				 bp->phy_interface);
+	if (ret) {
+		netdev_err(dev, "Could not attach to PHY\n");
+		return ret;
 	}
 
 	/* mask with MAC supported features */
@@ -600,86 +472,9 @@ static int macb_mii_probe(struct net_device *dev)
 	bp->duplex = -1;
 	bp->phy_dev = phydev;
 
-	return 0;
-}
-
-static int macb_mii_init(struct macb *bp)
-{
-	struct macb_platform_data *pdata;
-	struct device_node *np, *mdio_np;
-	int err = -ENXIO, i;
-
-	/* Enable management port */
-	macb_writel(bp, NCR, MACB_BIT(MPE));
-
-	bp->mii_bus = mdiobus_alloc();
-	if (!bp->mii_bus) {
-		err = -ENOMEM;
-		goto err_out;
-	}
-
-	bp->mii_bus->name = "MACB_mii_bus";
-	bp->mii_bus->read = &macb_mdio_read;
-	bp->mii_bus->write = &macb_mdio_write;
-	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
-		 bp->pdev->name, bp->pdev->id);
-	bp->mii_bus->priv = bp;
-	bp->mii_bus->parent = &bp->dev->dev;
-	pdata = dev_get_platdata(&bp->pdev->dev);
-
-	dev_set_drvdata(&bp->dev->dev, bp->mii_bus);
-
-	np = bp->pdev->dev.of_node;
-	mdio_np = of_get_child_by_name(np, "mdio");
-	if (mdio_np) {
-		of_node_put(mdio_np);
-		err = of_mdiobus_register(bp->mii_bus, mdio_np);
-		if (err)
-			goto err_out_unregister_bus;
-	} else if (np) {
-		/* try dt phy registration */
-		err = of_mdiobus_register(bp->mii_bus, np);
-
-		/* fallback to standard phy registration if no phy were
-		 * found during dt phy registration
-		 */
-		if (!err && !phy_find_first(bp->mii_bus)) {
-			for (i = 0; i < PHY_MAX_ADDR; i++) {
-				struct phy_device *phydev;
-
-				phydev = mdiobus_scan(bp->mii_bus, i);
-				if (IS_ERR(phydev) &&
-				    PTR_ERR(phydev) != -ENODEV) {
-					err = PTR_ERR(phydev);
-					break;
-				}
-			}
-
-			if (err)
-				goto err_out_unregister_bus;
-		}
-	} else {
-		if (pdata)
-			bp->mii_bus->phy_mask = pdata->phy_mask;
-
-		err = mdiobus_register(bp->mii_bus);
-	}
-
-	if (err)
-		goto err_out_free_mdiobus;
-
-	err = macb_mii_probe(bp->dev);
-	if (err)
-		goto err_out_unregister_bus;
+	phy_attached_info(bp->phy_dev);
 
 	return 0;
-
-err_out_unregister_bus:
-	mdiobus_unregister(bp->mii_bus);
-err_out_free_mdiobus:
-	mdiobus_free(bp->mii_bus);
-err_out:
-	return err;
 }
 
 static void macb_update_stats(struct macb *bp)
@@ -2076,15 +1871,18 @@ static void macb_init_rings(struct macb *bp)
 static void macb_reset_hw(struct macb *bp)
 {
 	struct macb_queue *queue;
-	unsigned int q;
+	unsigned int q, ctrl;
 
 	/* Disable RX and TX (XXX: Should we halt the transmission
 	 * more gracefully?)
 	 */
-	macb_writel(bp, NCR, 0);
+	ctrl = macb_readl(bp, NCR);
+	ctrl &= ~(MACB_BIT(RE) | MACB_BIT(TE));
+	macb_writel(bp, NCR, ctrl);
 
 	/* Clear the stats registers (XXX: Update stats first?) */
-	macb_writel(bp, NCR, MACB_BIT(CLRSTAT));
+	ctrl |= MACB_BIT(CLRSTAT);
+	macb_writel(bp, NCR, ctrl);
 
 	/* Clear all status flags */
 	macb_writel(bp, TSR, -1);
@@ -2434,7 +2232,8 @@ static int macb_open(struct net_device *dev)
 	netif_carrier_off(dev);
 
 	/* if the phy is not yet register, retry later*/
-	if (!bp->phy_dev)
+	err = macb_mii_probe(dev);
+	if (err)
 		return -EAGAIN;
 
 	/* RX buffers initialization */
@@ -3655,16 +3454,16 @@ static int macb_probe(struct platform_device *pdev)
 	unsigned int queue_mask, num_queues;
 	struct macb_platform_data *pdata;
 	bool native_io;
-	struct phy_device *phydev;
 	struct net_device *dev;
 	struct resource *regs;
 	void __iomem *mem;
 	const char *mac;
 	struct macb *bp;
+	int phy_irq;
 	int err;
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mem = devm_ioremap_resource(&pdev->dev, regs);
+	mem = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));
 	if (IS_ERR(mem))
 		return PTR_ERR(mem);
 
@@ -3802,9 +3601,18 @@ static int macb_probe(struct platform_device *pdev)
 		goto err_out_unregister_netdev;
 	}
 
-	err = macb_mii_init(bp);
-	if (err)
-		goto err_out_unregister_netdev;
+	bp->phy_node = of_parse_phandle(bp->pdev->dev.of_node,
+					"phy-handle", 0);
+
+	pdata = dev_get_platdata(&bp->pdev->dev);
+	if (pdata && gpio_is_valid(pdata->phy_irq_pin)) {
+		err = devm_gpio_request(&bp->pdev->dev, pdata->phy_irq_pin,
+					"phy int");
+		if (!err) {
+			phy_irq = gpio_to_irq(pdata->phy_irq_pin);
+			bp->phy_irq = (phy_irq < 0) ? PHY_POLL : phy_irq;
+		}
+	}
 
 	netif_carrier_off(dev);
 
@@ -3818,8 +3626,6 @@ static int macb_probe(struct platform_device *pdev)
 		    macb_is_gem(bp) ? "GEM" : "MACB", macb_readl(bp, MID),
 		    dev->base_addr, dev->irq, dev->dev_addr);
 
-	phydev = bp->phy_dev;
-	phy_attached_info(phydev);
 	pm_runtime_mark_last_busy(&bp->pdev->dev);
 	pm_runtime_put_autosuspend(&bp->pdev->dev);
 
@@ -3858,9 +3664,6 @@ static int macb_remove(struct platform_device *pdev)
 		bp = netdev_priv(dev);
 		if (bp->phy_dev)
 			phy_disconnect(bp->phy_dev);
-		mdiobus_unregister(bp->mii_bus);
-		dev->phydev = NULL;
-		mdiobus_free(bp->mii_bus);
 
 		/* Shutdown the PHY if there is a GPIO reset */
 		if (bp->reset_gpio)
@@ -3996,12 +3799,6 @@ static int __maybe_unused macb_runtime_suspend(struct device *dev)
 	struct net_device *netdev = platform_get_drvdata(pdev);
 	struct macb *bp = netdev_priv(netdev);
 
-	if (!(device_may_wakeup(&bp->dev->dev))) {
-		clk_disable_unprepare(bp->tx_clk);
-		clk_disable_unprepare(bp->hclk);
-		clk_disable_unprepare(bp->pclk);
-		clk_disable_unprepare(bp->rx_clk);
-	}
 	clk_disable_unprepare(bp->tsu_clk);
 
 	return 0;
@@ -4013,12 +3810,6 @@ static int __maybe_unused macb_runtime_resume(struct device *dev)
 	struct net_device *netdev = platform_get_drvdata(pdev);
 	struct macb *bp = netdev_priv(netdev);
 
-	if (!(device_may_wakeup(&bp->dev->dev))) {
-		clk_prepare_enable(bp->pclk);
-		clk_prepare_enable(bp->hclk);
-		clk_prepare_enable(bp->tx_clk);
-		clk_prepare_enable(bp->rx_clk);
-	}
 	clk_prepare_enable(bp->tsu_clk);
 
 	return 0;
diff --git a/drivers/net/ethernet/cadence/macb_mdio.c b/drivers/net/ethernet/cadence/macb_mdio.c
new file mode 100644
index 0000000..1434474
--- /dev/null
+++ b/drivers/net/ethernet/cadence/macb_mdio.c
@@ -0,0 +1,276 @@
+/*
+ * Cadence Macb mdio controller driver
+ *
+ * Copyright (C) 2014 - 2018 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/netdevice.h>
+#include <linux/of_address.h>
+#include <linux/of_mdio.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ptp_clock_kernel.h>
+#include "macb.h"
+
+
+struct macb_mdio_data {
+	void __iomem *regs;
+
+	struct clk *pclk;
+	struct clk *hclk;
+};
+
+#define macb_mdio_reg_writel(bp, offset, value)	\
+	writel_relaxed(value, bp->regs + offset)
+#define macb_mdio_writel(bp, reg, value)	\
+	macb_mdio_reg_writel(bp, MACB_##reg, value)
+
+#define macb_mdio_reg_readl(bp, offset)	readl_relaxed(bp->regs + offset)
+#define macb_mdio_readl(bp, reg)	macb_mdio_reg_readl(bp, MACB_##reg)
+
+#define MACB_MDIO_TIMEOUT	1000
+
+static int macb_mdio_wait_for_idle(struct macb_mdio_data *bp)
+{
+	ulong timeout;
+
+	timeout = jiffies + msecs_to_jiffies(MACB_MDIO_TIMEOUT);
+	/* wait for end of transfer */
+	while (1) {
+		if (MACB_BFEXT(IDLE, macb_mdio_readl(bp, NSR)))
+			break;
+
+		if (time_after_eq(jiffies, timeout)) {
+			//netdev_err(bp->dev, "wait for end of transfer timed out\n");
+			return -ETIMEDOUT;
+		}
+
+		cpu_relax();
+	}
+
+	return 0;
+}
+
+static int macb_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+{
+	struct macb_mdio_data *bp = bus->priv;
+	int value;
+	int err;
+
+	err = macb_mdio_wait_for_idle(bp);
+	if (err < 0)
+		return err;
+
+	macb_mdio_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF) |
+				   MACB_BF(RW, MACB_MAN_READ) |
+				   MACB_BF(PHYA, mii_id) |
+				   MACB_BF(REGA, regnum) |
+				   MACB_BF(CODE, MACB_MAN_CODE)));
+
+	err = macb_mdio_wait_for_idle(bp);
+	if (err < 0)
+		return err;
+
+	value = MACB_BFEXT(DATA, macb_mdio_readl(bp, MAN));
+
+	return value;
+}
+
+static int macb_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
+			   u16 value)
+{
+	struct macb_mdio_data *bp = bus->priv;
+	int err;
+
+	err = macb_mdio_wait_for_idle(bp);
+	if (err < 0)
+		return err;
+
+	macb_mdio_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF) |
+				   MACB_BF(RW, MACB_MAN_WRITE) |
+				   MACB_BF(PHYA, mii_id) |
+				   MACB_BF(REGA, regnum) |
+				   MACB_BF(CODE, MACB_MAN_CODE) |
+				   MACB_BF(DATA, value)));
+
+	err = macb_mdio_wait_for_idle(bp);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static u32 gem_mdc_clk_div(struct macb_mdio_data *bp)
+{
+	u32 config;
+	unsigned long pclk_hz = clk_get_rate(bp->pclk);
+
+	if (pclk_hz <= 20000000)
+		config = GEM_BF(CLK, GEM_CLK_DIV8);
+	else if (pclk_hz <= 40000000)
+		config = GEM_BF(CLK, GEM_CLK_DIV16);
+	else if (pclk_hz <= 80000000)
+		config = GEM_BF(CLK, GEM_CLK_DIV32);
+	else if (pclk_hz <= 120000000)
+		config = GEM_BF(CLK, GEM_CLK_DIV48);
+	else if (pclk_hz <= 160000000)
+		config = GEM_BF(CLK, GEM_CLK_DIV64);
+	else
+		config = GEM_BF(CLK, GEM_CLK_DIV96);
+
+	return config;
+}
+
+static int macb_mdio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct mii_bus *bus;
+	struct macb_mdio_data *bp;
+	struct resource *res;
+	int ret;
+	u32 config, i;
+
+	bus = mdiobus_alloc_size(sizeof(*bus));
+	if (!bus)
+		return -ENOMEM;
+
+	bus->name = "macb_mii_bus";
+	bus->read = &macb_mdio_read;
+	bus->write = &macb_mdio_write;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii", dev_name(&pdev->dev));
+	bus->parent = &pdev->dev;
+
+	bp = bus->priv;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	bp->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+	if (IS_ERR(bp->regs)) {
+		ret = PTR_ERR(bp->regs);
+		goto err_out_free_mdiobus;
+	}
+
+	bp->pclk = devm_clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(bp->pclk)) {
+		ret = PTR_ERR(bp->pclk);
+		dev_err(&pdev->dev, "failed to get macb_clk (%u)\n", ret);
+		goto err_out_free_mdiobus;
+	}
+
+	bp->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(bp->hclk)) {
+		ret = PTR_ERR(bp->hclk);
+		dev_err(&pdev->dev, "failed to get hclk (%u)\n", ret);
+		goto err_out_free_mdiobus;
+	}
+
+	ret = clk_prepare_enable(bp->pclk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable pclk (%u)\n", ret);
+		goto err_out_free_mdiobus;
+	}
+
+	ret = clk_prepare_enable(bp->hclk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable hclk (%u)\n", ret);
+		goto err_disable_pclk;
+	}
+
+	platform_set_drvdata(pdev, bus);
+
+	/* Enable management port */
+	config = macb_mdio_readl(bp, NCR);
+	config |= MACB_BIT(MPE);
+	macb_mdio_writel(bp, NCR, config);
+	config = gem_mdc_clk_div(bp);
+	macb_mdio_writel(bp, NCFGR, config);
+
+	np = pdev->dev.of_node;
+	if (np) {
+		/* try dt phy registration */
+		ret = of_mdiobus_register(bus, np);
+
+		/* Fallback to standard phy registration if no phy were
+		 * found during dt phy registration
+		 */
+		if (!ret && !phy_find_first(bus)) {
+			for (i = 0; i < PHY_MAX_ADDR; i++) {
+				struct phy_device *phydev;
+
+				phydev = mdiobus_scan(bus, i);
+				if (IS_ERR(phydev) &&
+				    PTR_ERR(phydev) != -ENODEV) {
+					ret = PTR_ERR(phydev);
+					break;
+				}
+			}
+
+			if (ret)
+				goto err_out_unregister_bus;
+		}
+	} else {
+		ret = of_mdiobus_register(bus, np);
+	}
+
+	if (ret)
+		goto err_disable_pclk;
+
+	return 0;
+
+err_out_unregister_bus:
+	mdiobus_unregister(bus);
+err_disable_pclk:
+	clk_disable_unprepare(bp->pclk);
+	clk_disable_unprepare(bp->hclk);
+err_out_free_mdiobus:
+	mdiobus_free(bus);
+	return ret;
+}
+
+static int macb_mdio_remove(struct platform_device *pdev)
+{
+	struct mii_bus *bus = platform_get_drvdata(pdev);
+	struct macb_mdio_data *bp = bus->priv;
+	u32 config;
+
+	/* Disable management port */
+	config = macb_mdio_readl(bp, NCR);
+	config &= ~MACB_BIT(MPE);
+	macb_mdio_writel(bp, NCR, config);
+	mdiobus_unregister(bus);
+	clk_disable_unprepare(bp->hclk);
+	clk_disable_unprepare(bp->pclk);
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static const struct of_device_id macb_mdio_dt_ids[] = {
+	{ .compatible = "cdns,macb-mdio" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, macb_mdio_dt_ids);
+
+static struct platform_driver macb_mdio_driver = {
+	.probe = macb_mdio_probe,
+	.remove = macb_mdio_remove,
+	.driver = {
+		.name = "macb-mdio",
+		.of_match_table = macb_mdio_dt_ids,
+	},
+};
+
+module_platform_driver(macb_mdio_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cadence MACB MDIO driver");
+MODULE_AUTHOR("Xilinx");
+
diff --git a/drivers/nvmem/core.c b/drivers/nvmem/core.c
index d12e5de..d5d4bcc 100644
--- a/drivers/nvmem/core.c
+++ b/drivers/nvmem/core.c
@@ -44,6 +44,7 @@ struct nvmem_device {
 	void *priv;
 };
 
+#define FLAG_FRAM		BIT(1)
 #define FLAG_COMPAT		BIT(0)
 
 struct nvmem_cell {
@@ -411,7 +412,7 @@ static int nvmem_setup_compat(struct nvmem_device *nvmem,
 		nvmem->eeprom = bin_attr_ro_root_nvmem;
 	else
 		nvmem->eeprom = bin_attr_rw_root_nvmem;
-	nvmem->eeprom.attr.name = "eeprom";
+	nvmem->eeprom.attr.name = nvmem->flags & FLAG_FRAM ? "fram" : "eeprom";
 	nvmem->eeprom.size = nvmem->size;
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	nvmem->eeprom.attr.key = &eeprom_lock_key;
@@ -471,6 +472,8 @@ struct nvmem_device *nvmem_register(const struct nvmem_config *config)
 	nvmem->priv = config->priv;
 	nvmem->reg_read = config->reg_read;
 	nvmem->reg_write = config->reg_write;
+	if (config->fram)
+		nvmem->flags |= FLAG_FRAM;
 	np = config->dev->of_node;
 	nvmem->dev.of_node = np;
 	dev_set_name(&nvmem->dev, "%s%d",
diff --git a/drivers/pci/host/Kconfig b/drivers/pci/host/Kconfig
index 34415fb..221a5c1 100644
--- a/drivers/pci/host/Kconfig
+++ b/drivers/pci/host/Kconfig
@@ -84,6 +84,13 @@ config PCIE_XDMA_PL
 	  Say 'Y' here if you want kernel to enable support the
 	  Xilinx XDMA PL PCIe Host Bridge driver.
 
+config PCI_EP430D
+	bool "Eureka Technology EP430 PCI host controller"
+	depends on ARM && OF
+	help
+	  Say Y here if you want to support for the Eureka Technology
+	  EP430  PCI host controller.
+
 config PCI_XGENE
 	bool "X-Gene PCIe controller"
 	depends on ARM64
diff --git a/drivers/pci/host/Makefile b/drivers/pci/host/Makefile
index eec90c1..e814465 100644
--- a/drivers/pci/host/Makefile
+++ b/drivers/pci/host/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_PCI_HOST_GENERIC) += pci-host-generic.o
 obj-$(CONFIG_PCIE_XDMA_PL) += pcie-xdma-pl.o
 obj-$(CONFIG_PCIE_XILINX) += pcie-xilinx.o
 obj-$(CONFIG_PCIE_XILINX_NWL) += pcie-xilinx-nwl.o
+obj-$(CONFIG_PCI_EP430D) += pci-ep430d.o
 obj-$(CONFIG_PCI_XGENE_MSI) += pci-xgene-msi.o
 obj-$(CONFIG_PCI_VERSATILE) += pci-versatile.o
 obj-$(CONFIG_PCIE_IPROC) += pcie-iproc.o
diff --git a/drivers/pci/host/pci-ep430d.c b/drivers/pci/host/pci-ep430d.c
new file mode 100644
index 0000000..1500de0
--- /dev/null
+++ b/drivers/pci/host/pci-ep430d.c
@@ -0,0 +1,454 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+
+#define EP430_CFG_SLAVE_REG_OFFSET              0x00000004
+#define EP430_CFG_MASTER_REG_OFFSET             0x00000008
+
+#define EP430_CFG_SLAVE_UW_MASK                 0xFF000000
+#define EP430_CFG_SLAVE_UW_SHIFT                24
+#define EP430_CFG_SLAVE_READ_BYTE_EN_MASK       0x00F00000
+#define EP430_CFG_SLAVE_READ_BYTE_EN_SHIFT      20
+#define EP430_CFG_SLAVE_FAST                    0x00000040
+#define EP430_CFG_SLAVE_CS2                     0x00000020
+#define EP430_CFG_SLAVE_CS1                     0x00000010
+#define EP430_CFG_SLAVE_CS0                     0x00000008
+#define EP430_CFG_SLAVE_CMD1                    0x00000004
+#define EP430_CFG_SLAVE_CMD0                    0x00000002
+#define EP430_CFG_SLAVE_MIO                     0x00000001
+
+/* TODO what are ready and read_err? */
+#define EP430_CFG_STATUS_DETECTED_PARITY_ERR    0x00000080
+#define EP430_CFG_STATUS_SIGNALED_SYSTEM_ERR    0x00000040
+#define EP430_CFG_STATUS_RECEIVED_MASTER_ABORT  0x00000020
+#define EP430_CFG_STATUS_RECEIVED_TARGET_ABORT  0x00000010
+#define EP430_CFG_STATUS_SIGNALED_TARGET_ABORT  0x00000008
+#define EP430_CFG_STATUS_MASTER_DATA_PARITY_ERR 0x00000004
+#define EP430_CFG_STATUS_READY                  0x00000002
+#define EP430_CFG_STATUS_READ_ERR               0x00000001
+
+
+#define EP430_CORE_BASE_SIZE                    0x04
+#define EP430_CORE_DATA_RW_EN                   0x80000000
+
+#define EP430_MEM_BASE_ADDR                     0x60000000
+#define EP430_MEM_BASE_SIZE                     0x04000000
+
+#define NAI_75G5_PCI_DEVICE_ID					0x758115AC
+
+#define NAI_IS_PCI_MASTER_COMMON_AREA_OFFSET	0x160	
+
+/* TODO do we have a separate IO space?
+ *      toggling a chip select may not work, investigate!
+ */
+#define PCI_IO_BUS              0x00000000
+#define PCI_IO_PHY              0x00000000
+#define PCI_IO_SIZE             0x00010000
+
+static void __iomem *mb_common_addr = NULL;
+static void __iomem *cfg_base_addr = NULL;
+static void __iomem *core_base_addr = NULL;
+static int pci_irq = 0;
+static u8 ignoreSlot = 0;
+
+static u32 ep430_config_addr(u8 busnum, int devfn, int where) {
+	u32 addr;
+
+	addr = busnum << 16;
+	addr |= PCI_SLOT(devfn) << 11;
+	addr |= PCI_FUNC(devfn) << 8;
+	addr |= (where & ~0x03);
+
+        return addr;
+}
+
+static int ep430_get_byte_en(int size) {
+	int byte_en;
+
+	/* TODO Verify the rationale (1/2/4 byte access) and
+	 *      endianness with Frank.
+	 */
+	switch (size) {
+	case 1:
+		byte_en = 0x08;
+		break;
+
+	case 2:
+		byte_en = 0x0C;
+		break;
+
+	default: /* 4 */
+		byte_en = 0x0F;
+		break;
+	}
+
+	return byte_en;
+}
+
+/*
+ * EP430 Core Register Configure
+ * 
+ * */
+static void ep430_csr_config(u32 config_addr, u32 size) {
+	
+	u8 byte_en;
+	
+	config_addr |= EP430_CORE_DATA_RW_EN;
+
+	byte_en = ep430_get_byte_en(size) <<
+		EP430_CFG_SLAVE_READ_BYTE_EN_SHIFT;
+
+	/* Enable slave byte read and CS1 */
+	/* 0x00f00010 */
+	iowrite32(EP430_CFG_SLAVE_READ_BYTE_EN_MASK |
+		  EP430_CFG_SLAVE_CS1,
+		  cfg_base_addr + EP430_CFG_SLAVE_REG_OFFSET);
+
+	/* Set device addr to config_addr */
+	iowrite32(config_addr, core_base_addr);
+
+	/* Change to config_data */
+	/* 0x00f00020 */
+	iowrite32(byte_en | EP430_CFG_SLAVE_CS2,
+		  cfg_base_addr + EP430_CFG_SLAVE_REG_OFFSET);
+		  
+}
+
+/*
+ * EP430 enable 
+ * 
+ * */
+static void ep430_en_memory_mode(void) {
+	
+	/* Change chip select to cs0 and set mio to 1 for memory mode */
+	/* bit 3 ~ 0
+	 * 3 = cs0
+	 * 2 = cmd1
+	 * 1 = cmd0
+		 * 0 = mio
+	 */
+	iowrite32((EP430_MEM_BASE_ADDR & EP430_CFG_SLAVE_UW_MASK) |
+		  EP430_CFG_SLAVE_READ_BYTE_EN_MASK |
+		  EP430_CFG_SLAVE_CS0 |
+		  EP430_CFG_SLAVE_MIO,
+		  cfg_base_addr + EP430_CFG_SLAVE_REG_OFFSET);
+		  
+}
+
+static int ep430_read_config(struct pci_bus *bus, unsigned int devfn,
+			     int where,	int size, u32 *value) {
+	u32 config_addr;
+	//u8 byte_en;
+	u32 retval;
+	u8 slot = PCI_SLOT(devfn);
+	
+	if ( slot == ignoreSlot) {
+		//printk("NAI SLOT_ID %x \n", slot);
+		switch (size) {
+		case 1:
+			retval = 0xff;
+			break;
+
+		case 2:
+			retval = 0xffff;
+			break;
+
+		default: /* 4*/
+			retval = 0xffffffff;
+			break;
+		}
+		goto ignore_slot;
+	} 
+
+	config_addr = ep430_config_addr(bus->number, devfn, where);
+	ep430_csr_config(config_addr,size);
+	/* Read from config_data */
+	switch (size) {
+	case 1:
+		//*value = ioread8(core_base_addr);
+		retval = ioread32(core_base_addr);
+		if (where & 2) retval >>= 16;
+		if (where & 1) retval >>= 8;
+		retval &= 0xff;
+		break;
+
+	case 2:
+		//*value = ioread16(core_base_addr);
+		retval = ioread32(core_base_addr);
+		if (where & 2) retval >>= 16;
+		retval &= 0xffff;
+		break;
+
+	default: /* 4*/
+		retval = ioread32(core_base_addr);
+		break;
+	}
+
+	//enable memory mode
+	ep430_en_memory_mode();
+	
+ignore_slot:	
+	*value = retval;	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ep430_write_config(struct pci_bus *bus, unsigned int devfn,
+			      int where, int size, u32 value) {
+	u32 config_addr;
+	//u8 byte_en;
+	u8 slot = PCI_SLOT(devfn);
+	
+	if ( slot == ignoreSlot ) {	
+		goto ignore_slot;
+	}
+
+	
+	config_addr = ep430_config_addr(bus->number, devfn, where);
+	ep430_csr_config(config_addr,size);
+	
+	/* Write to config_data register */
+	switch (size) {
+	case 1:
+		iowrite8((u8)value, core_base_addr);
+		break;
+
+	case 2:
+		iowrite16((u16)value, core_base_addr);
+		break;
+
+	default: /* 4 */
+		iowrite32(value, core_base_addr);
+		break;
+	}
+
+
+	
+	//enable memory mode
+	ep430_en_memory_mode();
+	
+ignore_slot:	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/*
+ * Host Master Setup
+ * */
+static void ep430_host_bus_master_setup(void) {
+
+	//enable 4 bytes config access
+	u32 byte_en_size = 4;
+	u32 config_addr = 0;
+	u32 retval = 0;
+	u8 	devfn = 0;
+	u8 	bus = 0;
+	u8 slot = 0;
+	u32 i;
+	/* Search all 32 slots on PCI bus 
+	 * and look for 75G5 in Slot 2
+	 * TODO: Verify with HW if there is going to be a 75XX 
+	 * in slot 1
+	 */	  
+	 for (i=0; i<32; i++){		
+		
+		bus = 0; //bus number
+		devfn = i << 3; //dev
+		devfn |= 0 << 0; //func 	
+		config_addr = ep430_config_addr(0,devfn, PCI_VENDOR_ID);
+		slot = PCI_SLOT(devfn);
+		
+		//printk("ep430: config 0x: %x is 0x=%x\n", config_addr, ignore_slot);
+		
+		ep430_csr_config(config_addr, byte_en_size);
+		retval = ioread32(core_base_addr);
+		
+		if ( (retval == NAI_75G5_PCI_DEVICE_ID ) && (slot == ignoreSlot) ) {
+			printk("ep430: pci core device: 0x%x slot: 0x%x\n", retval, slot);
+			//enable bus master 
+			config_addr = ep430_config_addr(0,devfn, PCI_COMMAND);
+			ep430_csr_config(config_addr, byte_en_size);
+			
+			retval = ioread32(core_base_addr);
+			retval |=  PCI_COMMAND_MASTER;
+			
+			iowrite32(retval, core_base_addr);
+			break;
+		}
+	 }
+	 
+}
+
+static struct pci_ops ep430_ops = {
+	.read	= ep430_read_config,
+	.write	= ep430_write_config,
+};
+
+static int __init ep430_map_irq(const struct pci_dev *dev, u8 slot, u8 pin) {
+	return pci_irq;
+}
+
+static void __init ep430_preinit(void) {
+
+}
+
+static int ep430_setup(int nr, struct pci_sys_data *sys) {
+	int ret;
+	struct device_node *parentnode, *childnode;
+	struct resource *res;
+	int childnodecount = 0;
+	const char *desc;
+	u32 isPCIFlag = 0;
+	
+	if (nr != 0) {
+		pr_err("EP430: unexpected nr = %d\n", nr);
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	parentnode = of_find_compatible_node(NULL, NULL, "nai,ep430d");
+	if (!parentnode) {
+		pr_err("ep430_setup: Unable to find nai,ep430d in dtb\n");
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	//read master slot from dtb property
+	ret = of_property_read_u8(parentnode, "ignore_slot", &ignoreSlot);
+	if ( ret < 0 ){
+		pr_err("ep430_setup: Unable to find ignore_slot property in dtb\n");
+		goto err;
+	}
+	printk("EP430: Ignore Slot 0x%x \n", ignoreSlot);
+	
+	pci_irq = irq_of_parse_and_map(parentnode,0);
+	printk("EP430: PCI_IRQ %d\n", pci_irq);
+	if (pci_irq == 0)
+	{
+		pr_err("ep430_setup: Unable to find IRQ in dtb\n");
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	childnodecount = of_get_child_count(parentnode);
+	printk("EP430: child count %d\n", childnodecount);
+
+	childnode = of_get_child_by_name(parentnode,"mb_common_addr");
+	desc = of_get_property(childnode, "label", NULL);
+	printk("EP430: mb_common_addr %s\n", desc);
+	mb_common_addr = of_iomap(childnode,0);
+	if (!mb_common_addr) {
+		pr_err("EP430: mb_common_addr ioremap failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	childnode = of_get_child_by_name(parentnode,"cfg_base_addr");
+	desc = of_get_property(childnode, "label", NULL);
+	printk("EP430: base addr desc %s\n", desc);
+	cfg_base_addr = of_iomap(childnode,0);
+	if (!cfg_base_addr) {
+		pr_err("EP430: cfg ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_cfg_mem;
+	}
+				 
+	childnode = of_get_child_by_name(parentnode,"core_base_addr");
+	desc = of_get_property(childnode, "label", NULL);
+	printk("EP430: base addr desc %s\n", desc);
+	core_base_addr = of_iomap(childnode,0);
+	if (!core_base_addr) {
+		pr_err("EP430: core ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_core_mem;
+	}
+
+	res = kzalloc(sizeof(*res), GFP_KERNEL);
+	if (!res) {
+		pr_err("EP430: res alloc failed\n");
+		ret = -ENOMEM;
+		goto err_res_alloc;
+	}
+
+
+	res->name  = "EP430 PCI Memory Space";
+	res->start = (resource_size_t)EP430_MEM_BASE_ADDR;
+	res->end   = (resource_size_t)(EP430_MEM_BASE_ADDR +
+				       EP430_MEM_BASE_SIZE - 1);
+	res->flags = IORESOURCE_MEM;
+
+	ret = request_resource(&iomem_resource, res);
+	if (ret) {
+		pr_err("EP430: failed to request resource\n");
+		goto err_req_res;
+	}
+
+	//enable host bus master
+	ep430_host_bus_master_setup();
+	
+	pci_add_resource_offset(&sys->resources, res, sys->mem_offset);
+	
+	//set PCI Master Flag in MB Common Area 
+	isPCIFlag = ioread32(mb_common_addr+NAI_IS_PCI_MASTER_COMMON_AREA_OFFSET);
+	isPCIFlag |= 0x1;
+	iowrite32(isPCIFlag, mb_common_addr+NAI_IS_PCI_MASTER_COMMON_AREA_OFFSET);
+	printk("EP430: Set PCI Master Flag %x \n", isPCIFlag);
+	
+	
+	/* TODO do we need platform_notify and platform_notify_remove? */
+
+	return 1;
+err_req_res:
+	kfree(res);
+err_res_alloc:
+	iounmap(core_base_addr);
+err_core_mem:
+	iounmap(cfg_base_addr);
+err_cfg_mem:
+	iounmap(mb_common_addr);
+err:
+	return ret;
+}
+
+static struct hw_pci ep430_hw_pci __initdata = {
+	.setup		= ep430_setup,
+	.map_irq	= ep430_map_irq,
+	.nr_controllers = 1,
+	.ops		= &ep430_ops,
+	.preinit	= ep430_preinit,
+};
+
+int __init ep430_init(void) {
+	pci_common_init(&ep430_hw_pci);
+
+	return 0;
+}
+
+subsys_initcall(ep430_init);
+
+MODULE_DESCRIPTION("Eureka Technology EP430 PCI host driver");
+MODULE_AUTHOR("Obi Okafor <ookafor@naii.com>");
+MODULE_LICENSE("GPLv2");
diff --git a/drivers/pci/host/pcie-xilinx.c b/drivers/pci/host/pcie-xilinx.c
index 94e13cb..3a91cb0 100644
--- a/drivers/pci/host/pcie-xilinx.c
+++ b/drivers/pci/host/pcie-xilinx.c
@@ -108,6 +108,7 @@
  */
 struct xilinx_pcie_port {
 	void __iomem *reg_base;
+	void __iomem *cfg_reg_base;
 	u32 irq;
 	unsigned long msi_pages;
 	u8 root_busno;
@@ -189,6 +190,7 @@ static void __iomem *xilinx_pcie_map_bus(struct pci_bus *bus,
 {
 	struct xilinx_pcie_port *port = bus->sysdata;
 	int relbus;
+	void __iomem *reg_base = NULL;
 
 	if (!xilinx_pcie_valid_device(bus, devfn))
 		return NULL;
@@ -196,7 +198,12 @@ static void __iomem *xilinx_pcie_map_bus(struct pci_bus *bus,
 	relbus = (bus->number << ECAM_BUS_NUM_SHIFT) |
 		 (devfn << ECAM_DEV_NUM_SHIFT);
 
-	return port->reg_base + relbus + where;
+	if ((bus->number == port->root_busno) || (port->cfg_reg_base == NULL))
+		reg_base =  (void __iomem *)port->reg_base + relbus + where;
+	else
+		reg_base =  (void __iomem *)port->cfg_reg_base + relbus + where;
+
+	return reg_base;
 }
 
 /* PCIe operations */
@@ -489,6 +496,41 @@ static irqreturn_t xilinx_pcie_intr_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+/*** JK ***/
+static irqreturn_t xilinx_pcie_INTA_handler(int irq, void *data)
+{
+	struct xilinx_pcie_port *port = (struct xilinx_pcie_port *)data;
+			   
+	generic_handle_irq(irq_find_mapping(port->leg_domain, 1));
+
+	return IRQ_HANDLED;
+}
+static irqreturn_t xilinx_pcie_INTB_handler(int irq, void *data)
+{
+	struct xilinx_pcie_port *port = (struct xilinx_pcie_port *)data;
+			   
+	generic_handle_irq(irq_find_mapping(port->leg_domain, 2));
+
+	return IRQ_HANDLED;
+}
+static irqreturn_t xilinx_pcie_INTC_handler(int irq, void *data)
+{
+	struct xilinx_pcie_port *port = (struct xilinx_pcie_port *)data;
+			   
+	generic_handle_irq(irq_find_mapping(port->leg_domain, 3));
+
+	return IRQ_HANDLED;
+}
+static irqreturn_t xilinx_pcie_INTD_handler(int irq, void *data)
+{
+	struct xilinx_pcie_port *port = (struct xilinx_pcie_port *)data;
+			   
+	generic_handle_irq(irq_find_mapping(port->leg_domain, 4));
+
+	return IRQ_HANDLED;
+}
+/**********/
+
 /**
  * xilinx_pcie_init_irq_domain - Initialize IRQ domain
  * @port: PCIe port information
@@ -564,6 +606,18 @@ static void xilinx_pcie_init_port(struct xilinx_pcie_port *port)
 		   XILINX_PCIE_REG_RPSC);
 }
 
+static const struct of_device_id xilinx_pcie_of_match[] = {
+	{
+		.compatible = "xlnx,axi-pcie-host-1.00.a",
+		.data = (void *)0,
+	},
+	{
+		.compatible = "nai,pcie-host-1.00.a",
+		.data = (void *)1,
+	},
+	{}
+};
+
 /**
  * xilinx_pcie_parse_dt - Parse Device tree
  * @port: PCIe port information
@@ -577,6 +631,9 @@ static int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)
 	struct resource regs;
 	const char *type;
 	int err;
+	unsigned int irq;
+	const struct of_device_id *of_id =
+		of_match_device(xilinx_pcie_of_match, dev);
 
 	type = of_get_property(node, "device_type", NULL);
 	if (!type || strcmp(type, "pci")) {
@@ -597,12 +654,56 @@ static int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)
 	port->irq = irq_of_parse_and_map(node, 0);
 	err = devm_request_irq(dev, port->irq, xilinx_pcie_intr_handler,
 			       IRQF_SHARED | IRQF_NO_THREAD,
-			       "xilinx-pcie", port);
+			       "xilinx-pcie-MSI", port);
 	if (err) {
-		dev_err(dev, "unable to request irq %d\n", port->irq);
+		dev_err(dev, "unable to request MSI irq %d\n", port->irq);
 		return err;
 	}
 
+	if ((int)of_id->data == 1) {
+		err = of_address_to_resource(node, 1, &regs);
+		if (err) {
+			dev_err(dev, "missing cfg \"reg\" property\n");
+			return err;
+		}
+
+		port->cfg_reg_base = devm_pci_remap_cfg_resource(dev, &regs);
+		if (IS_ERR(port->cfg_reg_base))
+			return PTR_ERR(port->cfg_reg_base);
+
+		irq = irq_of_parse_and_map(node, 1);
+		err = devm_request_irq(dev, irq, xilinx_pcie_INTA_handler,
+				       IRQF_SHARED, "xilinx-pcie-INTA", port);
+		if (err) {
+			dev_err(dev, "unable to request INTA irq %d\n", irq);
+			return err;
+		}
+
+		irq = irq_of_parse_and_map(node, 2);
+		err = devm_request_irq(dev, irq, xilinx_pcie_INTB_handler,
+				       IRQF_SHARED, "xilinx-pcie-INTB", port);
+		if (err) {
+			dev_err(dev, "unable to request INTB irq %d\n", irq);
+			return err;
+		}
+
+		irq = irq_of_parse_and_map(node, 3);
+		err = devm_request_irq(dev, irq, xilinx_pcie_INTC_handler,
+				       IRQF_SHARED, "xilinx-pcie-INTC", port);
+		if (err) {
+			dev_err(dev, "unable to request INTC irq %d\n", irq);
+			return err;
+		}
+
+		irq = irq_of_parse_and_map(node, 4);
+		err = devm_request_irq(dev, irq, xilinx_pcie_INTD_handler,
+				       IRQF_SHARED, "xilinx-pcie-INTD", port);
+		if (err) {
+			dev_err(dev, "unable to request INTD irq %d\n", irq);
+			return err;
+		}
+	}
+
 	return 0;
 }
 
@@ -688,11 +789,6 @@ static int xilinx_pcie_probe(struct platform_device *pdev)
 	return err;
 }
 
-static const struct of_device_id xilinx_pcie_of_match[] = {
-	{ .compatible = "xlnx,axi-pcie-host-1.00.a", },
-	{}
-};
-
 static struct platform_driver xilinx_pcie_driver = {
 	.driver = {
 		.name = "xilinx-pcie",
diff --git a/drivers/vme/Kconfig b/drivers/vme/Kconfig
index a6a6f95..cbd3f99 100644
--- a/drivers/vme/Kconfig
+++ b/drivers/vme/Kconfig
@@ -14,6 +14,8 @@ source "drivers/vme/bridges/Kconfig"
 
 source "drivers/vme/boards/Kconfig"
 
+source "drivers/vme/devices/Kconfig"
+
 source "drivers/staging/vme/devices/Kconfig"
 
 endif # VME
diff --git a/drivers/vme/Makefile b/drivers/vme/Makefile
index d7bfcb9..3b71a22 100644
--- a/drivers/vme/Makefile
+++ b/drivers/vme/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_VME_BUS)		+= vme.o
 
 obj-y				+= bridges/
 obj-y				+= boards/
+obj-y				+= devices/
diff --git a/drivers/vme/bridges/Kconfig b/drivers/vme/bridges/Kconfig
index f6ddc37..2684ca2 100644
--- a/drivers/vme/bridges/Kconfig
+++ b/drivers/vme/bridges/Kconfig
@@ -21,3 +21,9 @@ config VME_FAKE
 	 provides a virtualised VME Bus for devices with no VME bridge. This
 	 is mainly useful for VME development (in the absence of VME
 	 hardware).
+	 
+config VME_INICORE
+	tristate "IniCore"
+	help
+	 If you say Y here you get support for the IniCore VME bridge
+	 chip.
diff --git a/drivers/vme/bridges/Makefile b/drivers/vme/bridges/Makefile
index b074542..826e5f8 100644
--- a/drivers/vme/bridges/Makefile
+++ b/drivers/vme/bridges/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_VME_CA91CX42)	+= vme_ca91cx42.o
 obj-$(CONFIG_VME_TSI148)	+= vme_tsi148.o
 obj-$(CONFIG_VME_FAKE)		+= vme_fake.o
+obj-$(CONFIG_VME_INICORE)	+= vme_inicore.o
diff --git a/drivers/vme/bridges/vme_inicore.c b/drivers/vme/bridges/vme_inicore.c
new file mode 100644
index 0000000..ffb5458
--- /dev/null
+++ b/drivers/vme/bridges/vme_inicore.c
@@ -0,0 +1,1700 @@
+/*
+ * Support for the Inicore VME Sysytem Controller
+ *
+ * Author: NAII
+ * Copyright 2014 North Atlantic Industries
+ *
+ * Based on work by Martyn Welch <martyn.welch@ge.com>
+ * Copyright 2008 GE Intelligent Platforms Embedded Systems, Inc. 
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mm.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/poll.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/uaccess.h>
+#include <linux/byteorder/generic.h>
+#include <linux/vme.h>
+
+#include "../vme_bridge.h"
+#include "vme_inicore.h"
+
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define DEBUGF(x...) printk(x)
+#else
+#define DEBUGF(x...)
+#endif /* DEBUG */
+
+/* Module parameter */
+static bool err_chk;
+static int geoid = 1;
+
+static const char driver_name[] = "vme_inicore";
+
+/*
+ * Wake up IACK queue.
+ */
+/*TODO: Not implemented yet*/
+#if 0
+static u32 inicore_IACK_irqhandler(struct inicore_driver *bridge)
+{
+	wake_up(&bridge->iack_queue);
+
+	return INICORE_LCSR_INTC_IACKC;
+}
+#endif
+
+/*Clear all pending IRQ*/
+static void inicore_clr_pending_irq(struct vme_bridge *inicore_bridge, u32 clrIrq){
+	
+	struct inicore_driver *bridge;
+
+	bridge = inicore_bridge->driver_priv;
+
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+	
+	DEBUGF("%s:Clear INICORE_LCSR_INT_STATUS:%x \n",__func__,clrIrq);	
+	/*clear pending irq*/
+	iowrite32be(clrIrq,bridge->port + INICORE_LCSR_INT_STATUS);
+	
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+	
+	return;
+}
+
+/*
+ * Calling VME bus interrupt callback if provided.
+ */
+static u32 inicore_VIRQ_irqhandler(struct vme_bridge *inicore_bridge,
+	u32 stat)
+{
+   unsigned int vector, level, serviced = 0;
+   struct inicore_driver *bridge;
+
+   bridge = inicore_bridge->driver_priv;
+
+   for (level = 7; level > 0; level--)
+   {
+      if (stat & INICORE_LCSR_IS_IRQn[level])
+      {
+   
+         /*TODO: Should we check for VME_IRN1_ERR?*/
+         vector = ioread32be(bridge->port + INICORE_LCSR_VME_IRQn_STAT[level]);
+
+         if((vector&INICORE_LCSR_VME_IRQn_STAT_D08_VINTHn_ERR)!=0)
+         {
+            pr_err("level: %d IACK cycle bus err.\n ",level);
+         }
+         else
+         {
+
+            /* Clear serviced interrupt */
+            iowrite32be(INICORE_LCSR_IS_IRQn[level], bridge->port + INICORE_LCSR_INT_STATUS);
+
+
+            if(vector < VME_NUM_STATUSID)
+            {
+               vme_irq_handler(inicore_bridge, level, vector);
+            }
+
+            serviced |= INICORE_LCSR_IS_IRQn[level];
+         }
+      }
+   }
+
+	return serviced;
+}
+
+/*
+ * Top level interrupt handler.  Clears appropriate interrupt status bits and
+ * then calls appropriate sub handler(s).
+ */
+static irqreturn_t inicore_irqhandler(int irq, void *ptr)
+{
+	u32 stat = 0, enable = 0, savedCfgReg = 0, serviced = 0; 
+	
+	struct vme_bridge *inicore_bridge;
+	struct inicore_driver *bridge;
+
+	inicore_bridge = ptr;
+	bridge = inicore_bridge->driver_priv;
+
+	/* Enable Local CSR acces */
+	savedCfgReg = ioread32(bridge->core_cfg_base);
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+	
+	/* Determine which interrupts are unmasked and set */
+	enable = ioread32be(bridge->port + INICORE_LCSR_INT_EBL);
+	stat = ioread32be(bridge->port + INICORE_LCSR_INT_STATUS);
+
+	/* Only look at unmasked interrupts */
+	stat &= enable;
+
+	if (unlikely(!stat))
+		return IRQ_NONE;
+	
+	DEBUGF("%s: stat:0x%x \n",__func__,stat);
+	/* Call subhandlers as appropriate */
+	/* VME bus irqs */
+	if (stat & (INICORE_LCSR_IS_IRQ7 | INICORE_LCSR_IS_IRQ6 |
+			INICORE_LCSR_IS_IRQ5 | INICORE_LCSR_IS_IRQ4 |
+			INICORE_LCSR_IS_IRQ3 | INICORE_LCSR_IS_IRQ2 |
+			INICORE_LCSR_IS_IRQ1)){
+		serviced |= inicore_VIRQ_irqhandler(inicore_bridge, stat);
+	}
+	
+	DEBUGF("%s: serviced:0x%x \n",__func__,serviced);
+	
+	/* Restore core cfg register */
+	iowrite32be(savedCfgReg,bridge->core_cfg_base);
+	
+	return IRQ_HANDLED;
+}
+
+static int inicore_irq_init(struct vme_bridge *inicore_bridge)
+{
+	int result;
+	u32 tmp;
+	struct inicore_driver *bridge;
+
+	bridge = inicore_bridge->driver_priv;
+	
+	/*TODO: Enable VME SW and USER IRQ */
+	result = request_irq(bridge->irq,
+			     inicore_irqhandler,
+			     IRQF_SHARED,
+			     driver_name, inicore_bridge);			 
+			     
+	if (result) {
+		dev_err(inicore_bridge->parent, "Can't get assigned irq "
+			"vector %02X\n", bridge->irq);
+		return result;
+	}
+	
+	/*TODO: Clear all power up pending IRQ*/
+	tmp = INICORE_LCSR_IS_MBOX3 | INICORE_LCSR_IS_MBOX2 | 
+			INICORE_LCSR_IS_MBOX1 | INICORE_LCSR_IS_MBOX0 |
+			INICORE_LCSR_IS_VTIERR | INICORE_LCSR_IS_VBERR |
+			INICORE_LCSR_IS_DMAERR | INICORE_LCSR_IS_DMADONE |
+			INICORE_LCSR_IS_SWIACK | INICORE_LCSR_IS_IRQ1 |
+			INICORE_LCSR_IS_IRQ2 | INICORE_LCSR_IS_IRQ3 |
+			INICORE_LCSR_IS_IRQ4 | INICORE_LCSR_IS_IRQ5 |
+			INICORE_LCSR_IS_IRQ6 | INICORE_LCSR_IS_IRQ7 |
+			INICORE_LCSR_IS_SYSFAL | INICORE_LCSR_IS_ACFAL;
+			
+	inicore_clr_pending_irq(inicore_bridge, tmp);
+	
+	return 0;
+}
+
+static void inicore_irq_exit(struct vme_bridge *inicore_bridge)
+{
+	struct inicore_driver *bridge = inicore_bridge->driver_priv;
+	/*TODO: We need semphore*/
+	
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+	
+	/* Turn off interrupts */
+	iowrite32be(0x0, bridge->port + INICORE_LCSR_INT_EBL);
+	
+	
+	/* Clear all interrupts */
+	iowrite32be(0xFFFFFFFF, bridge->port + INICORE_LCSR_INT_STATUS);
+	
+		/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+	
+	/* Detach interrupt handler */
+	free_irq(bridge->irq, bridge);
+}
+
+/*
+ * Check to see if an IACk has been received, return true (1) or false (0).
+ */
+static int inicore_iack_received(struct inicore_driver *bridge)
+{
+	u32 tmp;
+
+	tmp = ioread32be(bridge->port + INICORE_LCSR_VINT_STATUS);
+	if (tmp & INICORE_LCSR_VINT_STATUS_SWIRQ)
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * Configure VME interrupt
+ */
+static void inicore_irq_set(struct vme_bridge *inicore_bridge, int level,
+	int state, int sync)
+{
+	u32 tmp;
+	struct inicore_driver *bridge;
+
+	bridge = inicore_bridge->driver_priv;
+
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+	
+	tmp = ioread32be(bridge->port + INICORE_LCSR_INT_EBL);
+	DEBUGF("%s:get INT_EBL_REG:0x%x lvl:%d\n",__func__,tmp,level);	
+	if (state == 0) {
+		
+		tmp &= ~INICORE_LCSR_IE_IRQn[level];
+		DEBUGF("%s: clear INT_EBL_REG:0x%x lvl:%d\n",__func__,tmp,level);	
+		iowrite32be(tmp, bridge->port + INICORE_LCSR_INT_EBL);
+		
+		if (sync != 0) {
+			synchronize_irq(bridge->irq);
+		}
+	} else {
+		
+		tmp |= INICORE_LCSR_IE_IRQn[level];
+		DEBUGF("%s: set INT_EBL_REG:0x%x lvl:%d\n",__func__,tmp,level);
+		iowrite32be(tmp, bridge->port + INICORE_LCSR_INT_EBL);
+		
+		/*TODO: as of now we are locking iack cycle to 8bit*/
+		tmp = ioread32be(bridge->port + INICORE_LCSR_VINT_IRQH_CMD);
+		DEBUGF("%s: get VINT_IRQH_CMD:0x%x \n",__func__,tmp);
+		tmp |= INICORE_LCSR_VINT_IRQH_INTx_TYP_D8;
+		DEBUGF("%s: set VINT_IRQH_CMD:0x%x \n",__func__,tmp);
+		iowrite32be(tmp, bridge->port + INICORE_LCSR_VINT_IRQH_CMD);
+		
+	}
+	
+	/*release semapore*/
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+
+
+	return;
+}
+
+/*
+ * Generate a VME bus interrupt at the requested level & vector. Wait for
+ * interrupt to be acked.
+ */
+static int inicore_irq_generate(struct vme_bridge *inicore_bridge, int level,
+	int statid)
+{
+	u32 tmp;
+	struct inicore_driver *bridge;
+
+	bridge = inicore_bridge->driver_priv;
+	
+	mutex_lock(&bridge->vme_int);
+
+
+	
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+	
+	/* Set VME INT MAP */
+	tmp = INICORE_LCSR_VINT_MAP_D32 | INICORE_LCSR_VINT_MAP_SWIRQL[level];
+	iowrite32be(tmp, bridge->port + INICORE_LCSR_VINT_MAP);
+		
+	/* Set Status/ID */
+	iowrite32be(statid, bridge->port + INICORE_LCSR_VINT_STAT_SW);
+	
+	/*check iack*/
+	wait_event_interruptible_timeout(bridge->iack_queue,
+			inicore_iack_received(bridge),
+			msecs_to_jiffies(50));
+			
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+
+	mutex_unlock(&bridge->vme_int);
+
+	return 0;
+}
+
+/*
+ * Initialize a slave window with the requested attributes.
+ */
+static int inicore_slave_set(struct vme_slave_resource *image, int enabled,
+	unsigned long long vme_base, unsigned long long size,
+	dma_addr_t pci_base, u32 aspace, u32 cycle)
+{
+	unsigned int i, addr = 0, granularity = 0;
+	unsigned int temp_ctl = 0;
+	struct vme_bridge *inicore_bridge;
+	struct inicore_driver *bridge;
+
+	inicore_bridge = image->parent;
+	bridge = inicore_bridge->driver_priv;
+
+	i = image->number;
+	
+	/*TODO: Handle multiple window*/
+	switch (aspace) {
+	case VME_A24:
+		granularity = 0x1000;
+		addr |= INICORE_CSRADERn_AM_A24;
+		break;
+	case VME_A32:
+		granularity = 0x10000;
+		addr |= INICORE_CSRADERn_AM_A32;
+		break;
+	case VME_A16:
+	case VME_CRCSR:
+	case VME_USER1:
+	case VME_USER2:
+	case VME_USER3:
+	case VME_USER4:
+	default:
+		dev_err(inicore_bridge->parent, "Invalid address space\n");
+		return -EINVAL;
+		break;
+	}
+	
+	if (cycle & (VME_MBLT| VME_2eVME | VME_2eSST |VME_2eSSTB)){
+			dev_err(inicore_bridge->parent, "Invalid VME cycle\n");
+			return -EINVAL;
+	}
+	
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+		
+	/*disable slave window */
+	temp_ctl = ioread32be(bridge->port + INICORE_LCSR_SLV_ACC_DEC1);
+	temp_ctl &= ~INICORE_LCSR_SLVW_EBL;
+	iowrite32be(temp_ctl, bridge->port + INICORE_LCSR_SLV_ACC_DEC1);
+	
+	/* Setup address space */
+	temp_ctl = addr;
+	
+	/* Setup Cycle and Access */
+	if (cycle & VME_SUPER)
+		temp_ctl |= INICORE_CSRADERn_AM_SUPR ;
+	if (cycle & VME_USER)
+		temp_ctl |= INICORE_CSRADERn_AM_NPRIV;
+	if (cycle & VME_BLT)
+		temp_ctl |= INICORE_CSRADERn_AM_BLT;
+	if (cycle & VME_PROG)
+		temp_ctl |= INICORE_CSRADERn_AM_PGM;
+	if (cycle & VME_DATA)
+		temp_ctl |= INICORE_CSRADERn_AM_DAT;
+	
+	/*setup AM*/
+	iowrite32be(temp_ctl, bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_C_OFFSET));
+	
+	/*setup vme base address*/
+	temp_ctl = (vme_base & 0xFF000000);
+	iowrite32be(temp_ctl, bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_0_OFFSET));
+	temp_ctl = ((vme_base & 0x00FF0000) << 8);
+	iowrite32be(temp_ctl, bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_4_OFFSET));
+	temp_ctl = ((vme_base & 0x0000FF00) << 16);
+	iowrite32be(temp_ctl, bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_8_OFFSET));
+	
+	/*setup vme base decoder mask*/
+	temp_ctl = (vme_base & INICORE_LCSR_SLVW_ADEM_M);
+	iowrite32be(temp_ctl, bridge->port + INICORE_LCSR_SLV_ACC_MSK1);
+	
+	if (enabled){
+		temp_ctl = ioread32be(bridge->port + INICORE_LCSR_SLV_ACC_DEC1);
+		temp_ctl |= INICORE_LCSR_SLVW_EBL;
+		iowrite32be(temp_ctl, bridge->port + INICORE_LCSR_SLV_ACC_DEC1);
+	}
+		
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+
+	return 0;
+}
+
+/*
+ * Get slave window configuration.
+ */
+static int inicore_slave_get(struct vme_slave_resource *image, int *enabled,
+	unsigned long long *vme_base, unsigned long long *size,
+	dma_addr_t *pci_base, u32 *aspace, u32 *cycle)
+{
+	unsigned int i, granularity = 0, ctl = 0;
+	struct inicore_driver *bridge;
+
+	bridge = image->parent->driver_priv;
+
+	i = image->number;
+
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);	
+	
+	/* Get VME Address */
+	*vme_base = 0;
+	/*read csr address decoder register*/
+	ctl = ioread32be(bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_0_OFFSET));
+	*vme_base |= (ctl & INICORE_CSRADERn_ADDRCB_M);
+	/*read csr address decoder register*/
+	ctl = ioread32be(bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_4_OFFSET));
+	*vme_base |= ((ctl & INICORE_CSRADERn_ADDRCB_M) >> 8);
+	/*read csr address decoder register*/
+	ctl = ioread32be(bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_8_OFFSET));
+	*vme_base |= ((ctl & INICORE_CSRADERn_ADDRCB_M) >> 16);
+		
+	/*read slave access decoding register*/
+	ctl = ioread32be(bridge->port + INICORE_LCSR_SLV_ACC_DEC1);
+		
+	*enabled = 0;
+	*aspace = 0;
+	*cycle = 0;
+	
+	/*check slave window enabled*/
+	if (ctl & INICORE_LCSR_SLVW_EBL)
+		*enabled = 1;
+	
+	/*read csr address decoder register*/
+	ctl = ioread32be(bridge->port + (INICORE_CSRADER0 + INICORE_CSRADERn_C_OFFSET));
+	
+	/*get address space*/
+	if ((ctl & INICORE_CSRADERn_AM_AS_M) == INICORE_CSRADERn_AM_A24) {
+		granularity = 0x10;
+		*aspace |= VME_A24;
+	}
+	if ((ctl & INICORE_CSRADERn_AM_AS_M) == INICORE_CSRADERn_AM_A32) {
+		granularity = 0x10000;
+		*aspace |= VME_A32;
+	}
+	
+	/*get cycle*/
+	if ((ctl & INICORE_CSRADERn_AM_AC_M) == INICORE_CSRADERn_AM_SUPR) {
+		*cycle |= VME_SUPER;
+	}
+	if ((ctl & INICORE_CSRADERn_AM_AC_M) == INICORE_CSRADERn_AM_BLT) {
+		*cycle |= VME_BLT;
+	}
+	if ((ctl & INICORE_CSRADERn_AM_AC_M) == INICORE_CSRADERn_AM_PGM) {
+		*cycle |= VME_PROG;
+	}
+	if ((ctl & INICORE_CSRADERn_AM_AC_M) == INICORE_CSRADERn_AM_DAT) {
+		*cycle |= VME_DATA;
+	}
+	if ((ctl & INICORE_CSRADERn_AM_AC_M) == INICORE_CSRADERn_AM_NPRIV) {
+		*cycle |= VME_USER;
+	}
+
+	/*read slave address decoder compare bits*/
+	ctl = ioread32be(bridge->port + INICORE_LCSR_SLV_ACC_MSK1);
+	
+	/*get size*/
+	*size = 0;
+	/*TODO There is no register in VME IP stores the slave size*/
+	/*
+	 * *size = ((ctl & INICORE_LCSR_SLVW_ADEM_M) - *vme_base);
+	 * 
+	 */ 
+	
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+
+	return 0;
+}
+
+/*
+ * Allocate and MAP VME Resource
+ */
+static int inicore_alloc_resource(struct vme_master_resource *image, unsigned long long vme_base,
+	unsigned long long size)
+{
+	unsigned long long existing_size = 0, existing_start = 0, new_start = 0;
+	int retval = 0;
+	struct resource *root;
+	struct vme_bridge *inicore_bridge;
+	struct inicore_driver *bridge;
+
+	inicore_bridge = image->parent;
+	bridge = inicore_bridge->driver_priv;
+	root = bridge->win_resource;
+	
+	existing_size = (unsigned long long)(image->bus_resource.end -
+		image->bus_resource.start);
+	
+	new_start = (unsigned long long)(root->start + vme_base);
+	existing_start = (unsigned long long)(image->bus_resource.start);
+		
+	/* check if it's already map */
+	if ((size != 0) 
+			&& (existing_size == (size - 1))
+			&& (new_start == existing_start)){
+           return -EEXIST;
+	}
+	
+	if (existing_size != 0) {
+		iounmap(image->kern_base);
+		image->kern_base = NULL;
+		kfree(image->bus_resource.name);
+		release_resource(&image->bus_resource);
+		memset(&image->bus_resource, 0, sizeof(struct resource));
+	}
+
+	if (image->bus_resource.name == NULL) {
+		image->bus_resource.name = kmalloc(VMENAMSIZ+3, GFP_ATOMIC);
+		if (image->bus_resource.name == NULL) {
+			dev_err(inicore_bridge->parent, "Unable to allocate "
+				"memory for resource name\n");
+			retval = -ENOMEM;
+			goto err_name;
+		}
+	}
+
+	sprintf((char *)image->bus_resource.name, "%s.%d", inicore_bridge->name,
+		image->number);
+
+	image->bus_resource.start = (root->start + vme_base);
+	image->bus_resource.end = ((root->start + vme_base + size) - 1);
+	image->bus_resource.flags = IORESOURCE_MEM;
+		
+	retval = request_resource(root,&image->bus_resource);
+	
+	if (retval != 0) {
+		dev_err(inicore_bridge->parent, "Failed to allocate "
+		"resource for window %d size 0x%lx start 0x%lx end 0x%lx err:%d\n",
+			image->number, (unsigned long)size,
+			(unsigned long)image->bus_resource.start,
+			(unsigned long)image->bus_resource.end,
+				retval);
+		/*clear image resource*/		
+		image->bus_resource.start = 0;
+		image->bus_resource.end = 0;
+		image->bus_resource.flags = IORESOURCE_MEM;
+		goto err_resource;
+	}
+		
+	image->kern_base = ioremap_nocache(
+		image->bus_resource.start, size);
+		
+	if (image->kern_base == NULL) {
+		dev_err(inicore_bridge->parent, "Failed to remap resource\n");
+		retval = -ENOMEM;
+		goto err_remap;
+	}
+		
+	return 0;
+	
+err_remap:
+	release_resource(&image->bus_resource);
+err_resource:
+	kfree(image->bus_resource.name);
+	memset(&image->bus_resource, 0, sizeof(struct resource));
+err_name:
+	return retval;
+}
+
+/*
+ * Free and Resource
+ */
+static void inicore_free_resource(struct vme_master_resource *image)
+{
+   iounmap(image->kern_base);
+   image->kern_base = NULL;
+   release_resource(&image->bus_resource);
+   kfree(image->bus_resource.name);
+   memset(&image->bus_resource, 0, sizeof(struct resource));
+}
+
+/*
+ * Free Window Resource
+ */
+static int inicore_master_rst_win(struct vme_master_resource *image)
+{
+   struct vme_bridge *inicore_bridge;
+   struct inicore_driver *bridge;
+
+   if(image->bus_resource.parent==NULL)
+   {
+#ifdef VME_DEBUG
+      pr_info("slot %d was not allocated\n",image->number);
+#endif
+      return 1;
+   }
+
+   inicore_bridge = image->parent;
+   bridge = inicore_bridge->driver_priv;
+   
+
+   
+   inicore_free_resource(image);
+
+   /*Clear master window register*/
+   iowrite32(0,bridge->master_win_base + VME_MS_WIN_ST[image->number]);
+   iowrite32(0,bridge->master_win_base + VME_MS_WIN_ED[image->number]);
+
+   
+   return 0;
+}
+
+/*
+ * Set the attributes of an outbound window.
+ */
+static int inicore_master_set(struct vme_master_resource *image, int enabled,
+	unsigned long long vme_base, unsigned long long size, u32 aspace,
+	u32 cycle, u32 dwidth)
+{
+  int retval = 0;
+  unsigned int i = 0, temp_ctl = 0;
+  unsigned int am = 0, dw = 0;
+  struct vme_bridge *inicore_bridge;
+  struct inicore_driver *bridge;
+
+  inicore_bridge = image->parent;
+  bridge = inicore_bridge->driver_priv;
+	
+  /* Verify vme base addr */
+  if (vme_base & 0xFF || vme_base & 0xFFFFFFFFE0000000ULL ) 
+  {
+    dev_err(inicore_bridge->parent, "Invalid VME Window alignment\n");
+    retval = -EINVAL;
+    goto err_window;
+  }
+
+  /* Verify size is not less than 256B*/
+  if((size < 0x100) && (enabled != 0)) 
+  {
+    dev_err(inicore_bridge->parent, "Size must be non-zero for enabled windows\n");
+    retval = -EINVAL;
+    goto err_window;
+  }
+
+  i = image->number;
+
+  
+  retval = inicore_alloc_resource(image, vme_base, size);
+
+  if(retval) 
+  {
+    dev_err(inicore_bridge->parent, "Unable to allocate memory for resource\n");
+    goto err_res;
+  }
+
+  /*Clear master window register*/
+  iowrite32(0,bridge->master_win_base + VME_MS_WIN_ST[i]);
+  iowrite32(0,bridge->master_win_base + VME_MS_WIN_ED[i]);
+
+  /* Setup data width */
+  switch (dwidth) 
+  {
+    case VME_D8:
+     image->width_sel = VME_D8;
+     dw = INICORE_DW08;
+     break;
+    case VME_D16:
+     image->width_sel = VME_D16;
+     dw = INICORE_DW16;
+     break;
+    case VME_D32:
+     image->width_sel = VME_D32;
+     dw = INICORE_DW32;
+     break;
+    default:
+     dev_err(inicore_bridge->parent, "Invalid data width\n");
+     retval = -EINVAL;
+     goto err_dwidth;
+  }
+
+  /* Setup address space */
+  switch (aspace) 
+  {
+    case VME_A16:
+     image->address_sel = VME_A16;
+     am = INICORE_AM_A16;
+     break;
+    case VME_A24:
+     image->address_sel = VME_A24;
+     am = INICORE_AM_A24;
+     break;
+    case VME_A32:
+     image->address_sel = VME_A32;
+     am = INICORE_AM_A32;
+     break;
+    case VME_CRCSR:
+     image->address_sel = VME_CRCSR;
+     am = INICORE_AM_CRCSR;
+     break;
+    case VME_A64:
+    case VME_USER1:
+    case VME_USER2:
+    case VME_USER3:
+    case VME_USER4:
+    default:
+     dev_err(inicore_bridge->parent, "Invalid address space\n");
+     retval = -EINVAL;
+     goto err_aspace;
+     break;
+  }
+  
+  DEBUGF("%s:am:%x\n",__func__,am);
+  
+  /* Setup Cycle  */
+  if(aspace != VME_CRCSR)
+  {
+    if(cycle & VME_SUPER)
+    {
+      image->cycle_sel = VME_SUPER;
+      am |= INICORE_AM_SURP;
+    }
+    if(cycle & VME_USER)
+    {
+      image->cycle_sel = VME_USER;
+      am |= INICORE_AM_NPRIV;
+    }
+    if(cycle & VME_PROG)
+    {
+      image->cycle_sel = VME_PROG;
+      am |= INICORE_AM_PGM;
+    }
+    if(cycle & VME_DATA)
+    {
+      image->cycle_sel = VME_DATA;
+      am |= INICORE_AM_DAT;
+    }
+  }
+
+  DEBUGF("%s:am:%x\n",__func__,am);
+  temp_ctl =  VME_MS_WINn_ST_DW_S(dw) | VME_MS_WINn_ST_AM_S(am);
+  temp_ctl |= (vme_base & VME_MS_WINn_XX_ADDR_M);
+  /* Setup Master Window start address, AM, and data width */
+  iowrite32(temp_ctl,bridge->master_win_base + VME_MS_WIN_ST[i]);
+  /* Setup Master Window end address*/
+  temp_ctl = (vme_base + size) - 1;
+  iowrite32(temp_ctl,bridge->master_win_base + VME_MS_WIN_ED[i]);
+  /*TODO: There is no MST Win enable/disable in VME Controller
+  * should we track enabled state in SW?
+  */
+  
+
+  return 0;
+
+err_res:
+err_aspace:
+err_dwidth:
+err_window:
+
+  return retval;
+}
+
+/*
+ * Set Bus Error Timeout
+ *
+ * XXX Not parsing prefetch information.
+ */
+static void __set_vme_bus_err_timeout(struct vme_bridge *inicore_bridge){
+
+	struct inicore_driver *bridge;
+	u32 tmp;
+	u8 timeout;
+	
+	bridge = inicore_bridge->driver_priv;
+	timeout = bridge->berr_time;
+	
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+	
+	/*setup timeout BERR Timer*/
+	DEBUGF("%s:timeout:%d us\n",__func__,timeout);	
+	tmp = ioread32be(bridge->port + INICORE_LCSR_SYS_CTRL);
+	tmp |= INICORE_LCSR_SYSC_BERRTIMER(timeout);
+	
+	DEBUGF("%s:tmp:0x%08x \n",__func__,tmp);
+	iowrite32be(tmp, bridge->port + INICORE_LCSR_SYS_CTRL);
+	
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+}
+
+
+/*set user side bus to little endian*/
+static void __set_vme_local_bus_lendian(struct vme_bridge *inicore_bridge){
+
+	struct inicore_driver *bridge;
+	u32 tmp;
+	
+	bridge = inicore_bridge->driver_priv;
+	
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT, bridge->core_cfg_base);
+	
+	/*enable little endian*/
+	/*
+	 * NOTE: After enabel little endian mode then 
+	 * all local IP CR/CSR configuration read/write required 
+	 * BE swap
+	 */
+	tmp = ioread32(bridge->port + INICORE_LCSR_DEV_CTRL);
+	/*If LENDIAN mode is not enable then enable little endian mode*/
+	if(tmp != 0x1000000){
+		tmp = INICORE_LCSR_DEV_CTRL_LENDIAN;
+		iowrite32(tmp, bridge->port + INICORE_LCSR_DEV_CTRL);
+	}
+
+	/*enable local csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+}
+
+/*
+ * Set the attributes of an outbound window.
+ *
+ * XXX Not parsing prefetch information.
+ */
+static int __inicore_master_get(struct vme_master_resource *image, int *enabled,
+	unsigned long long *vme_base, unsigned long long *size, u32 *aspace,
+	u32 *cycle, u32 *dwidth)
+{
+	unsigned int i = 0, ctlSt = 0, ctlEd = 0, tmp = 0;
+	struct inicore_driver *bridge;
+
+	bridge = image->parent->driver_priv;
+
+	i = image->number;
+	
+	ctlSt = ioread32(bridge->master_win_base + VME_MS_WIN_ST[i]);
+	*vme_base = (ctlSt & VME_MS_WINn_XX_ADDR_M);
+	ctlEd = ioread32(bridge->master_win_base + VME_MS_WIN_ED[i]);
+	
+	if(ctlEd != 0){
+		/*padded size with 256Byte*/
+		*size = (unsigned long long)(((ctlEd  | 0xFF) - *vme_base)  + 1); 
+	}else{
+		*size = 0;
+	}
+	
+	*enabled = 0;
+	*aspace = 0;
+	*cycle = 0;
+	*dwidth = 0;
+
+	/*TODO: how should we track master win enable in SW*/
+	//if (ctl & inicore_LCSR_OTAT_EN)
+	*enabled = 1;
+
+	/* Setup address space */
+	tmp = (ctlSt & VME_MS_WINn_ST_AM_M);
+	
+	if ((tmp & INICORE_AM_A16) == INICORE_AM_A16){
+		if(tmp == INICORE_AM_CRCSR)
+			*aspace = VME_CRCSR;
+		else
+			*aspace = VME_A16;
+	} else if ((tmp & INICORE_AM_A24) == INICORE_AM_A24){
+		*aspace = VME_A24;
+	} else if ((tmp & INICORE_AM_A32) == INICORE_AM_A32){
+		*aspace = VME_A32;
+	}
+	
+	
+	if(*aspace != VME_CRCSR){
+		if ((tmp & INICORE_AM_SURP) == INICORE_AM_SURP)
+			*cycle |= VME_SUPER;
+		if ((tmp & INICORE_AM_NPRIV) == INICORE_AM_NPRIV)
+			*cycle |= VME_USER;
+		if ((tmp & INICORE_AM_PGM) == INICORE_AM_PGM)
+			*cycle |= VME_PROG;
+		if ((tmp & INICORE_AM_DAT) == INICORE_AM_DAT)
+			*cycle |= VME_DATA;
+	}
+	
+	/* Setup data width */
+	tmp = ctlSt & VME_MS_WINn_ST_DW_M;
+	
+	if (tmp == VME_MS_WINn_ST_DW_S(INICORE_DW08))
+		*dwidth = VME_D8;
+	if (tmp == VME_MS_WINn_ST_DW_S(INICORE_DW16))
+		*dwidth = VME_D16;
+	if (tmp == VME_MS_WINn_ST_DW_S(INICORE_DW32))
+		*dwidth = VME_D32;
+	
+	return 0;
+}
+
+
+static int inicore_master_get(struct vme_master_resource *image, int *enabled,
+	unsigned long long *vme_base, unsigned long long *size, u32 *aspace,
+	u32 *cycle, u32 *dwidth)
+{
+	int retval;
+
+
+	retval = __inicore_master_get(image, enabled, vme_base, size, aspace,
+		cycle, dwidth);
+	
+
+	return retval;
+}
+
+static ssize_t inicore_master_read(struct vme_master_resource *image, void *buf,
+	size_t count, loff_t offset)
+{
+	int retval, enabled;
+	unsigned long long vme_base, size;
+	u32 aspace, cycle, dwidth, tmp;
+	struct vme_error_handler *handler = NULL;
+	struct vme_bridge *inicore_bridge;
+	struct inicore_driver *bridge;
+	void __iomem *addr = image->kern_base + offset;
+	unsigned int done = 0;
+	unsigned long flags;
+	
+	dwidth = image->width_sel;
+	aspace = image->address_sel;
+	
+	inicore_bridge = image->parent;
+	bridge = inicore_bridge->driver_priv;
+	
+	if(count == 0){
+		return -EINVAL;
+	}
+	
+	spin_lock_irqsave(&image->lock, flags);
+
+	if (err_chk) {
+		inicore_master_get(image, &enabled, &vme_base, &size, &aspace,
+				   &cycle, &dwidth);
+		handler = vme_register_error_handler(inicore_bridge, aspace,
+						     vme_base + offset, count);
+		if (!handler) {
+			spin_unlock_irqrestore(&image->lock, flags);
+			return -ENOMEM;
+		}
+	}
+	
+	if(aspace == VME_CRCSR){	
+		switch (dwidth) {
+			case VME_D8:
+				tmp = CORE_CFG_SET_DSIZE_8BIT;
+				break;
+			case VME_D16:
+				tmp = CORE_CFG_SET_DSIZE_16BIT;
+				break;
+			case VME_D32:
+				tmp = CORE_CFG_SET_DSIZE_32BIT;
+				break;
+			default:
+				tmp = CORE_CFG_SET_DSIZE_8BIT;
+		}
+		/*set fpga to ext csr access*/
+		iowrite32(tmp|CORE_CFG_EN_EXT_CSR, bridge->core_cfg_base);
+		
+	}else{	
+		/*set fpga to vme bus access*/
+		iowrite32(CORE_CFG_EN_VME_BUS, bridge->core_cfg_base);
+	}
+		
+	
+	if ((uintptr_t)addr & 0x1) {
+		if(dwidth == VME_D8){
+			DEBUGF("%s:addr:0x1:D8\n",__func__);
+			do{
+				*(u8 *)(buf + done) = ioread8(addr+done);
+				done++;
+			}while(--count);
+			count = done;
+		}
+		
+		if(count != done)
+			count = 0;
+			
+		goto out;
+	}
+	
+	if ((uintptr_t)addr & 0x2) {
+	
+		if(dwidth == VME_D8){
+			DEBUGF("%s:addr:0x2:D8\n",__func__);
+			do{
+				*(u8 *)(buf + done) = ioread8(addr+done);
+				done++;
+			}while(--count);
+			count = done;
+		}else if(dwidth == VME_D16){
+			DEBUGF("%s:addr:0x2:D16\n",__func__);
+			if(count % 2 == 0) {
+				count = count/2;
+				do{
+					*(u16 *)(buf + done) = ioread16(addr + done);
+					done += 2;
+				}while(--count);		
+				count = done;
+			}
+		}
+		
+		if(count != done)
+			count = 0;
+		
+		goto out;
+	}
+
+	if(dwidth == VME_D32){				
+		DEBUGF("%s:addr:0x0:D32\n",__func__);
+		if(count % 4 == 0) {
+			count = count/4;
+			do{
+				*(u32 *)(buf + done) = ioread32(addr + done);
+				done += 4;
+			}while(--count);
+			count = done;
+		}
+	}else if(dwidth == VME_D16){
+		DEBUGF("%s:addr:0x0:D16\n",__func__);
+		if(count % 2 == 0) {
+			count = count/2;
+			do{
+				*(u16 *)(buf + done) = ioread16(addr + done);
+				done += 2;
+			}while(--count);
+			count = done;
+		}
+	}else if(dwidth == VME_D8){
+		DEBUGF("%s:addr:0x0:D8\n",__func__);
+		do{
+			*(u8 *)(buf + done) = ioread8(addr+done);
+			done++;
+		}while(--count);
+		count = done;
+	}
+	
+	if(count != done)
+		count = 0;
+out:		
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+	
+	retval = count;
+	
+	if (err_chk) {
+		if (handler->num_errors) {
+			dev_err(image->parent->parent,
+				"First VME read error detected an at address 0x%llx\n",
+				handler->first_error);
+			retval = handler->first_error - (vme_base + offset);
+		}
+		vme_unregister_error_handler(handler);
+	}
+
+	spin_unlock_irqrestore(&image->lock, flags);
+	return retval;
+}
+
+
+static ssize_t inicore_master_write(struct vme_master_resource *image, void *buf,
+	size_t count, loff_t offset)
+{
+	int retval = 0, enabled;
+	unsigned long long vme_base, size;
+	u32 aspace, cycle, dwidth, tmp;
+	void __iomem *addr = image->kern_base + offset;
+	unsigned int done = 0;
+	struct vme_error_handler *handler = NULL;
+	struct vme_bridge *inicore_bridge;
+	struct inicore_driver *bridge;
+	unsigned long flags;
+
+	dwidth = image->width_sel;
+	aspace = image->address_sel;
+	
+	inicore_bridge = image->parent;
+	bridge = inicore_bridge->driver_priv;
+	
+	if(count == 0){
+		return -EINVAL;
+	}
+
+
+	spin_lock_irqsave(&image->lock, flags);
+
+	if (err_chk) {
+		inicore_master_get(image, &enabled, &vme_base, &size, &aspace,
+				   &cycle, &dwidth);
+		handler = vme_register_error_handler(inicore_bridge, aspace,
+						     vme_base + offset, count);
+		if (!handler) {
+			spin_unlock_irqrestore(&image->lock, flags);
+			return -ENOMEM;
+		}
+	}
+
+	if(aspace == VME_CRCSR){
+		
+		switch (dwidth) {
+			case VME_D8:
+				tmp = CORE_CFG_SET_DSIZE_8BIT;
+				break;
+			case VME_D16:
+				tmp = CORE_CFG_SET_DSIZE_16BIT;
+				break;
+			case VME_D32:
+				tmp = CORE_CFG_SET_DSIZE_32BIT;
+				break;
+			default:
+				tmp = CORE_CFG_SET_DSIZE_8BIT;
+		}
+		/*set fpga to ext csr access*/
+		iowrite32(tmp|CORE_CFG_EN_EXT_CSR, bridge->core_cfg_base);
+		
+	}else{
+		/*set fpga to vme bus access*/
+		iowrite32(CORE_CFG_EN_VME_BUS, bridge->core_cfg_base);
+	}
+
+	if ((uintptr_t)addr & 0x1) {
+		if(dwidth == VME_D8){
+			DEBUGF("%s:addr:0x1:D8\n",__func__);
+			do{
+				iowrite8(*(u8 *)(buf + done),addr+done);
+				done++;
+			}while(--count);
+			count = done;
+		}
+		
+		if(count != done)
+			count = 0;
+			
+		goto out;
+	}
+	
+	if ((uintptr_t)addr & 0x2) {
+	
+		if(dwidth == VME_D8){
+			DEBUGF("%s:addr:0x2:D8\n",__func__);
+			do{
+				iowrite8(*(u8 *)(buf + done),addr+done);
+				done++;
+			}while(--count);
+			count = done;
+		}else if(dwidth == VME_D16){
+			DEBUGF("%s:addr:0x2:D16\n",__func__);
+			if(count % 2 == 0) {
+				count = count/2;
+				do{
+					iowrite16(*(u16 *)(buf + done),addr+done);
+					done += 2;
+				}while(--count);		
+				count = done;
+			}
+		}
+		
+		if(count != done)
+			count = 0;
+		
+		goto out;
+	}
+
+	if(dwidth == VME_D32){				
+		DEBUGF("%s:addr:0x0:D32\n",__func__);
+		if(count % 4 == 0) {
+			count = count/4;
+			do{
+				iowrite32(*(u32 *)(buf + done),addr+done);
+				done += 4;
+			}while(--count);
+			count = done;
+		}
+	}else if(dwidth == VME_D16){
+		DEBUGF("%s:addr:0x0:D16\n",__func__);
+		if(count % 2 == 0) {
+			count = count/2;
+			do{
+				iowrite16(*(u16 *)(buf + done),addr+done);
+				done += 2;
+			}while(--count);
+			count = done;
+		}
+	}else if(dwidth == VME_D8){
+		DEBUGF("%s:addr:0x0:D8\n",__func__);
+		do{
+			iowrite8(*(u8 *)(buf + done),addr+done);
+			done++;
+		}while(--count);
+		count = done;
+	}
+	
+	if(count != done)
+		count = 0;
+
+out:
+			
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);	
+	
+	retval = done;
+	
+	/*
+	 * Writes are posted. We need to do a read on the VME bus to flush out
+	 * all of the writes before we check for errors. We can't guarantee
+	 * that reading the data we have just written is safe. It is believed
+	 * that there isn't any read, write re-ordering, so we can read any
+	 * location in VME space, so lets read the Device ID from the inicore's
+	 * own registers as mapped into CR/CSR space.
+	 *
+	 * We check for saved errors in the written address range/space.
+	 */
+
+	if (err_chk) {
+		/*TODO: Not sure why we need to read from 7F00*/
+		ioread16(bridge->flush_image->kern_base + 0x7F000);
+
+		if (handler->num_errors) {
+			dev_warn(inicore_bridge->parent,
+				 "First VME write error detected an at address 0x%llx\n",
+				 handler->first_error);
+			retval = handler->first_error - (vme_base + offset);
+		}
+		vme_unregister_error_handler(handler);
+	}
+
+	spin_unlock_irqrestore(&image->lock, flags);
+	return retval;
+}
+
+/*
+ * Determine Geographical Addressing
+ */
+static int inicore_slot_get(struct vme_bridge *inicore_bridge)
+{
+	u32 slot = 0;
+	u32 tmp = 0;
+	struct inicore_driver *bridge;
+
+	bridge = inicore_bridge->driver_priv;
+
+	tmp = CORE_CFG_EN_LOCAL_CSR|CORE_CFG_SET_DSIZE_32BIT;
+	
+	/*enable local csr access*/
+	iowrite32(tmp, bridge->core_cfg_base);
+	
+	if (!geoid) {
+		slot = ioread32be(bridge->port + INICORE_LCSR_SYS_CTRL);
+		slot = slot & INICORE_LCSR_SYSC_GA_M;
+	} else {
+		slot = geoid;
+	}
+	
+	/*clear fpga to csr access*/
+	iowrite32(CORE_CFG_CLEAR, bridge->core_cfg_base);
+
+
+	return (int)slot;
+}
+
+static int inicore_dtb(struct vme_bridge *bridge, struct device *dev){
+	
+	int retval = 0;
+	int irq = 0;
+	u8 time;
+	struct device_node *parentnode, *childnode;
+	int childnodecount = 0;
+	struct inicore_driver *inicore_device = bridge->driver_priv; 
+	void __iomem *tmp;
+	const char *desc;
+	
+	parentnode = of_find_compatible_node(NULL, NULL, "nai,inicore");
+	if (!parentnode) {
+		pr_err("%s:Unable to find nai,inicore in dtb\n",__func__);
+		retval = -EAGAIN;
+		goto err;
+	}
+		
+	//read master slot from dtb property
+	retval = of_property_read_u8(parentnode, "berr_time", &time);
+	if ( retval < 0 ){
+		pr_err("%s: unable to find berr_time in dtb\n",__func__);
+		/*default to 0*/
+		time = 0;
+	}
+	
+	inicore_device->berr_time = time;
+	DEBUGF("%s:timeout:%d us\n",__func__,inicore_device->berr_time);
+	
+	/*get IRQ*/
+	irq = irq_of_parse_and_map(parentnode,0);
+	
+	if (irq == 0){
+		pr_err("%s: Unable to find IRQ in dtb\n",__func__);
+		retval = -EAGAIN;
+		goto err;
+	}
+	inicore_device->irq = irq;
+	
+	childnodecount = of_get_child_count(parentnode);
+	
+	/* map fpga vme core register */
+	childnode = of_get_child_by_name(parentnode,"port");
+	desc = of_get_property(childnode, "label", NULL);
+	
+	tmp = of_iomap(childnode,0);
+	if (!tmp) {
+		pr_err("%s port iomap failed\n",__func__);
+		retval = -ENOMEM;
+		goto err_port;
+	}
+	
+	inicore_device->port = tmp;
+	
+	/* map fpga core config register */
+	childnode = of_get_child_by_name(parentnode,"core_cfg_base");
+	desc = of_get_property(childnode, "label", NULL);
+	
+	tmp = of_iomap(childnode,0);
+	if (!tmp){
+		pr_err("%s: core_cfg_base ioremap failed\n",__func__);
+		retval = -ENOMEM;
+		goto err_core_cfg;
+	}
+	
+	inicore_device->core_cfg_base = tmp;
+	
+	/* map fpga master window register */			 
+	childnode = of_get_child_by_name(parentnode,"master_win_base");
+	desc = of_get_property(childnode, "label", NULL);
+	
+	tmp = of_iomap(childnode,0);
+	if (!tmp) {
+		pr_err("%s: master_win_base ioremap failed\n",__func__);
+		retval = -ENOMEM;
+		goto err_master_win;
+	}
+	
+	inicore_device->master_win_base = tmp;
+		
+	return 0;
+
+err_master_win:
+	iounmap(inicore_device->core_cfg_base);	
+err_core_cfg:
+	iounmap(inicore_device->port);
+err_port:	
+err:	
+	return retval;
+}
+
+static int inicore_probe(struct platform_device *pdev)
+{
+	int retval, i, master_num;
+	struct list_head *pos = NULL, *n;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct vme_bridge *inicore_bridge = NULL;
+	struct inicore_driver *inicore_device = NULL;
+	struct vme_master_resource *master_image = NULL;
+	struct vme_slave_resource *slave_image = NULL;
+
+	inicore_bridge = kzalloc(sizeof(struct vme_bridge), GFP_KERNEL);
+	if (inicore_bridge == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate memory for device "
+			"structure\n");
+		retval = -ENOMEM;
+		goto err_struct;
+	}
+	vme_init_bridge(inicore_bridge);
+
+	inicore_device = kzalloc(sizeof(struct inicore_driver), GFP_KERNEL);
+	if (inicore_device == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate memory for device "
+			"structure\n");
+		retval = -ENOMEM;
+		goto err_driver;
+	}
+
+	inicore_bridge->parent = dev;
+	inicore_bridge->driver_priv = inicore_device;
+
+	
+	/*get DTB*/
+	retval = inicore_dtb(inicore_bridge, dev);
+	
+	if(retval < 0){
+		retval = -ENOMEM;
+		goto  err_dtb;
+	}
+	
+		
+	/*TODO Check to see if the mapping worked out */
+	/* Initialize wait queues & mutual exclusion flags */
+	mutex_init(&inicore_device->vme_int);
+	mutex_init(&inicore_device->vme_rmw);
+
+	strcpy(inicore_bridge->name, driver_name);
+	
+	__set_vme_local_bus_lendian(inicore_bridge);
+	
+	__set_vme_bus_err_timeout(inicore_bridge);
+	
+	/* Setup IRQ */
+	retval = inicore_irq_init(inicore_bridge);
+	if (retval != 0) {
+		dev_err(&pdev->dev, "Chip Initialization failed.\n");
+		goto err_irq;
+	}
+
+	/* If we are going to flush writes, we need to read from the VME bus.
+	 * We need to do this safely, thus we read the devices own CR/CSR
+	 * register. To do this we must set up a window in CR/CSR space and
+	 * hence have one less master window resource available.
+	 */
+	master_num = INICORE_MAX_MASTER;
+	if (err_chk) {
+		master_num--;
+
+		inicore_device->flush_image =
+			kmalloc(sizeof(struct vme_master_resource), GFP_KERNEL);
+		if (inicore_device->flush_image == NULL) {
+			dev_err(&pdev->dev, "Failed to allocate memory for "
+			"flush resource structure\n");
+			retval = -ENOMEM;
+			goto err_master;
+		}
+		inicore_device->flush_image->parent = inicore_bridge;
+		spin_lock_init(&inicore_device->flush_image->lock);
+		inicore_device->flush_image->locked = 1;
+		inicore_device->flush_image->number = master_num;
+		memset(&inicore_device->flush_image->bus_resource, 0,
+			sizeof(struct resource));
+		inicore_device->flush_image->kern_base  = NULL;
+	}
+
+	/* Add master windows to list */
+	for (i = 0; i < master_num; i++) {
+		master_image = kmalloc(sizeof(struct vme_master_resource),
+			GFP_KERNEL);
+		if (master_image == NULL) {
+			dev_err(&pdev->dev, "Failed to allocate memory for "
+			"master resource structure\n");
+			retval = -ENOMEM;
+			goto err_master;
+		}
+		master_image->parent = inicore_bridge;
+		spin_lock_init(&master_image->lock);
+		master_image->locked = 0;
+		master_image->number = i;
+		master_image->address_attr = VME_A16 | VME_A24 | VME_A32 | VME_CRCSR;
+		master_image->cycle_attr = VME_SUPER | VME_USER |
+			VME_PROG | VME_DATA | VME_CRCSR;
+		master_image->width_attr = VME_D8 | VME_D16 | VME_D32;
+		memset(&master_image->bus_resource, 0,
+			sizeof(struct resource));
+		master_image->kern_base  = NULL;
+		list_add_tail(&master_image->list,
+			&inicore_bridge->master_resources);
+	}
+
+	/* Add slave windows to list */
+	for (i = 0; i < INICORE_MAX_SLAVE; i++) {
+		slave_image = kmalloc(sizeof(struct vme_slave_resource),
+			GFP_KERNEL);
+		if (slave_image == NULL) {
+			dev_err(&pdev->dev, "Failed to allocate memory for "
+			"slave resource structure\n");
+			retval = -ENOMEM;
+			goto err_slave;
+		}
+		slave_image->parent = inicore_bridge;
+		mutex_init(&slave_image->mtx);
+		slave_image->locked = 0;
+		slave_image->number = i;
+		slave_image->address_attr = VME_A16 | VME_A24 | VME_A32;
+		slave_image->cycle_attr = VME_BLT | VME_SUPER | VME_USER |
+			VME_PROG | VME_DATA;
+		list_add_tail(&slave_image->list,
+			&inicore_bridge->slave_resources);
+	}
+
+	inicore_bridge->slave_get = inicore_slave_get;
+	inicore_bridge->slave_set = inicore_slave_set;
+	inicore_bridge->master_get = inicore_master_get;
+	inicore_bridge->master_set = inicore_master_set;
+	inicore_bridge->master_read = inicore_master_read;
+	inicore_bridge->master_write = inicore_master_write;
+	inicore_bridge->master_reset_window = inicore_master_rst_win;
+
+	inicore_bridge->master_rmw = NULL;
+	inicore_bridge->dma_list_add = NULL;
+	inicore_bridge->dma_list_exec = NULL;
+	inicore_bridge->dma_list_empty = NULL;
+	inicore_bridge->irq_set = inicore_irq_set;
+	inicore_bridge->irq_generate = inicore_irq_generate;
+	inicore_bridge->lm_set = NULL;
+	inicore_bridge->lm_get = NULL;
+	inicore_bridge->lm_attach = NULL;
+	inicore_bridge->lm_detach = NULL;
+	inicore_bridge->slot_get = inicore_slot_get;
+	inicore_bridge->alloc_consistent = NULL;
+	inicore_bridge->free_consistent = NULL;
+
+	/*allocated device resource*/
+	res = kzalloc(sizeof(*res), GFP_KERNEL);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to allocated memory for device\n");
+		retval = -ENOMEM;
+		goto err_res_alloc;
+	}
+	
+	res->name  = inicore_bridge->name;
+	res->start = (resource_size_t)VME_BUS_BASE_ADDR;
+	res->end   = (resource_size_t)(VME_BUS_BASE_ADDR +
+				       VNME_BUS_SIZE - 1);
+	res->flags = IORESOURCE_MEM;
+	
+	retval = request_resource(&iomem_resource, res);
+	
+	if (retval) {
+		dev_err(&pdev->dev, "failed to allocated resource\n");
+		goto err_req_res;
+	}
+	
+	inicore_device->win_resource = res;
+	
+	retval = vme_register_bridge(inicore_bridge);
+	if (retval != 0) {
+		dev_err(&pdev->dev, "Chip Registration failed.\n");
+		goto err_reg;
+	}
+	
+	platform_set_drvdata(pdev, inicore_bridge);
+	
+	return 0;
+
+err_reg:
+	release_resource(res);
+err_req_res:
+	kfree(res);
+err_res_alloc:
+err_slave:
+	/* resources are stored in link list */
+	list_for_each_safe(pos, n, &inicore_bridge->slave_resources) {
+		slave_image = list_entry(pos, struct vme_slave_resource, list);
+		list_del(pos);
+		kfree(slave_image);
+	}
+err_master:
+	/* resources are stored in link list */
+	list_for_each_safe(pos, n, &inicore_bridge->master_resources) {
+		master_image = list_entry(pos, struct vme_master_resource,
+			list);
+		list_del(pos);
+		kfree(master_image);
+	}
+	inicore_irq_exit(inicore_bridge);
+err_irq:
+err_dtb:
+	kfree(inicore_device);
+err_driver:
+	kfree(inicore_bridge);
+err_struct:
+	return retval;
+
+}
+
+static int inicore_remove(struct platform_device *pdev)
+{
+	struct list_head *pos = NULL;
+	struct list_head *tmplist;
+	struct vme_master_resource *master_image;
+	struct vme_slave_resource *slave_image;
+	struct inicore_driver *bridge;
+	struct vme_bridge *inicore_bridge = platform_get_drvdata(pdev);
+
+	bridge = inicore_bridge->driver_priv;
+
+	dev_dbg(&pdev->dev, "Driver is being unloaded.\n");
+
+	/*
+	 *  TODO: clear slave and master windows
+	 */
+
+	inicore_irq_exit(inicore_bridge);
+
+	release_resource(bridge->win_resource);
+	
+	kfree(bridge->win_resource);
+	
+	/* resources are stored in link list */
+	list_for_each_safe(pos, tmplist, &inicore_bridge->slave_resources) {
+		slave_image = list_entry(pos, struct vme_slave_resource, list);
+		list_del(pos);
+		kfree(slave_image);
+	}
+
+	/* resources are stored in link list */
+	list_for_each_safe(pos, tmplist, &inicore_bridge->master_resources) {
+		master_image = list_entry(pos, struct vme_master_resource,
+			list);
+		list_del(pos);
+		kfree(master_image);
+	}
+	
+	
+	iounmap(bridge->master_win_base);
+	iounmap(bridge->core_cfg_base);	
+	iounmap(bridge->port);
+	
+	kfree(bridge);
+
+	vme_unregister_bridge(inicore_bridge);
+	
+	kfree(inicore_bridge);
+	
+	return 0;
+	
+}
+
+static struct of_device_id inicore_of_match[] = {
+	{ .compatible = "nai,inicore", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, inicore_of_match);
+
+static struct platform_driver inicore_drv = {
+	.probe    = inicore_probe,
+	.remove   = inicore_remove,
+	.driver   = {
+		.name  = "inicore",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(inicore_of_match),
+	},
+};
+
+static int __init inicore_init(void) {
+	return platform_driver_register(&inicore_drv);
+}
+
+static void __exit inicore_exit(void) {
+	platform_driver_unregister(&inicore_drv);
+}
+
+subsys_initcall(inicore_init);
+module_exit(inicore_exit);
+
+MODULE_PARM_DESC(err_chk, "Check for VME errors on reads and writes");
+module_param(err_chk, bool, 0);
+
+MODULE_PARM_DESC(geoid, "Override geographical addressing");
+module_param(geoid, int, 1);
+
+MODULE_DESCRIPTION("Inicore VME system control driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/vme/bridges/vme_inicore.h b/drivers/vme/bridges/vme_inicore.h
new file mode 100644
index 0000000..8a08b58
--- /dev/null
+++ b/drivers/vme/bridges/vme_inicore.h
@@ -0,0 +1,453 @@
+/*
+ * vme_inicore.h
+ *
+ * Support for the Inicore VME SystemController 
+ *
+ * Author: 
+
+ * Copyright
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef VME_INCORE_H
+#define VME_INCORE_H
+
+/*
+ *  Define the number of each that the Tsi148 supports.
+ */
+#define INICORE_MAX_MASTER		22	/* Max Master Windows */
+#define INICORE_MAX_SLAVE		1	/* Max Slave Windows */
+
+
+/* Structure used to hold driver specific information */
+struct inicore_driver {
+	void __iomem	*port;
+	void __iomem	*core_cfg_base;
+	void __iomem 	*master_win_base;
+	wait_queue_head_t iack_queue;
+	struct vme_master_resource *flush_image;
+	struct resource* win_resource;
+	int				irq;
+	u8				berr_time;		/* Bus error timeout*/
+	struct mutex vme_rmw;		/* Only one RMW cycle at a time */
+	struct mutex vme_int;		
+					/*
+					 * Only one VME interrupt can be
+					 * generated at a time, provide locking
+					 */
+};
+
+/*
+ *
+ *      Note:   INICORE Register Group (CRG) consists of the following
+ *              combination of registers:
+ *                      LCSR    - Local Control and Status Registers
+ *                      GCSR    - Global Control and Status Registers
+ *                      CR/CSR  - Subset of Configuration ROM /
+ *                                Control and Status Registers
+ */
+
+
+/* FPGA VME Port Base address 0x80000000 */
+/* FPGA VME BASE ADDRESS 0x43C8 0000 */
+#define VME_BUS_BASE_ADDR							0x80000000
+#define VNME_BUS_SIZE                     			0x20000000 /*512 MB*/
+#define VME_CORE_REG_OFFSET							0x4
+#define	VME_MS_WIN1_ST_ADDR_OFFSET 					0x0
+#define VME_MS_WIN2_ST_ADDR_OFFSET					0x4
+#define VME_MS_WIN3_ST_ADDR_OFFSET					0x8
+#define VME_MS_WIN4_ST_ADDR_OFFSET					0xC
+#define VME_MS_WIN5_ST_ADDR_OFFSET					0x10
+#define VME_MS_WIN6_ST_ADDR_OFFSET					0x14
+#define VME_MS_WIN7_ST_ADDR_OFFSET					0x18
+#define VME_MS_WIN8_ST_ADDR_OFFSET					0x1C
+#define VME_MS_WIN9_ST_ADDR_OFFSET					0x20
+#define VME_MS_WIN10_ST_ADDR_OFFSET					0x24
+#define VME_MS_WIN11_ST_ADDR_OFFSET					0x28
+#define VME_MS_WIN12_ST_ADDR_OFFSET					0x2C
+#define VME_MS_WIN13_ST_ADDR_OFFSET					0x30
+#define VME_MS_WIN14_ST_ADDR_OFFSET					0x34
+#define VME_MS_WIN15_ST_ADDR_OFFSET					0x38
+#define VME_MS_WIN16_ST_ADDR_OFFSET					0x3C
+#define VME_MS_WIN17_ST_ADDR_OFFSET					0x40
+#define VME_MS_WIN18_ST_ADDR_OFFSET					0x44
+#define VME_MS_WIN19_ST_ADDR_OFFSET					0x48
+#define VME_MS_WIN20_ST_ADDR_OFFSET					0x4C
+#define VME_MS_WIN21_ST_ADDR_OFFSET					0x50
+
+#define VME_MS_WIN1_ED_ADDR_OFFSET					0x54
+#define VME_MS_WIN2_ED_ADDR_OFFSET					0x58
+#define	VME_MS_WIN3_ED_ADDR_OFFSET 					0x5C
+#define	VME_MS_WIN4_ED_ADDR_OFFSET 					0x60
+#define	VME_MS_WIN5_ED_ADDR_OFFSET 					0x64
+#define	VME_MS_WIN6_ED_ADDR_OFFSET 					0x68
+#define	VME_MS_WIN7_ED_ADDR_OFFSET 					0x6C
+#define	VME_MS_WIN8_ED_ADDR_OFFSET 					0x70
+#define	VME_MS_WIN9_ED_ADDR_OFFSET 					0x74
+#define	VME_MS_WIN10_ED_ADDR_OFFSET 				0x78
+#define	VME_MS_WIN11_ED_ADDR_OFFSET 				0x7C
+#define	VME_MS_WIN12_ED_ADDR_OFFSET 				0x80
+#define	VME_MS_WIN13_ED_ADDR_OFFSET 				0x84
+#define	VME_MS_WIN14_ED_ADDR_OFFSET 				0x88
+#define	VME_MS_WIN15_ED_ADDR_OFFSET 				0x8C
+#define	VME_MS_WIN16_ED_ADDR_OFFSET 				0x90
+#define	VME_MS_WIN17_ED_ADDR_OFFSET 				0x94
+#define	VME_MS_WIN18_ED_ADDR_OFFSET 				0x98
+#define	VME_MS_WIN19_ED_ADDR_OFFSET 				0x9C
+#define	VME_MS_WIN20_ED_ADDR_OFFSET 				0xA0
+#define	VME_MS_WIN21_ED_ADDR_OFFSET 				0xA4
+
+#define	VME_MS_WINn_ST_AM_M 						(0x3F << 0) /*Address Modifer Shift*/
+#define	VME_MS_WINn_ST_AM_S(x) 						(x << 0) /*Address Modifer Shift*/
+#define	VME_MS_WINn_ST_DW_M 						(0x3 << 6) /*Data Width MSK*/
+#define	VME_MS_WINn_ST_DW_S(x) 						(x << 6) /*Data Width Shift*/
+#define	VME_MS_WINn_XX_ADDR_M 						(0xFFFFFF << 8) /*VME Address Mask*/
+#define	VME_MS_WINn_XX_ADDR_S(x) 					(x << 8) /*VME Address Shift*/
+
+
+#define VME_MIN_IOMEM 								0x4000
+#define VME_MAX_IOMEM								0x20000
+
+static const int VME_MS_WIN_ST[21] = { VME_MS_WIN1_ST_ADDR_OFFSET,
+				VME_MS_WIN2_ST_ADDR_OFFSET, VME_MS_WIN3_ST_ADDR_OFFSET,
+				VME_MS_WIN4_ST_ADDR_OFFSET, VME_MS_WIN5_ST_ADDR_OFFSET,
+				VME_MS_WIN6_ST_ADDR_OFFSET, VME_MS_WIN7_ST_ADDR_OFFSET,
+				VME_MS_WIN8_ST_ADDR_OFFSET, VME_MS_WIN9_ST_ADDR_OFFSET,
+				VME_MS_WIN10_ST_ADDR_OFFSET, VME_MS_WIN11_ST_ADDR_OFFSET,
+				VME_MS_WIN12_ST_ADDR_OFFSET, VME_MS_WIN13_ST_ADDR_OFFSET,
+				VME_MS_WIN14_ST_ADDR_OFFSET, VME_MS_WIN15_ST_ADDR_OFFSET,
+				VME_MS_WIN16_ST_ADDR_OFFSET, VME_MS_WIN17_ST_ADDR_OFFSET,
+				VME_MS_WIN18_ST_ADDR_OFFSET, VME_MS_WIN19_ST_ADDR_OFFSET,
+				VME_MS_WIN20_ST_ADDR_OFFSET, VME_MS_WIN21_ST_ADDR_OFFSET };
+
+static const int VME_MS_WIN_ED[21] = { VME_MS_WIN1_ED_ADDR_OFFSET,
+				VME_MS_WIN2_ED_ADDR_OFFSET, VME_MS_WIN3_ED_ADDR_OFFSET,
+				VME_MS_WIN4_ED_ADDR_OFFSET, VME_MS_WIN5_ED_ADDR_OFFSET,
+				VME_MS_WIN6_ED_ADDR_OFFSET, VME_MS_WIN7_ED_ADDR_OFFSET,
+				VME_MS_WIN8_ED_ADDR_OFFSET, VME_MS_WIN9_ED_ADDR_OFFSET,
+				VME_MS_WIN10_ED_ADDR_OFFSET, VME_MS_WIN11_ED_ADDR_OFFSET,
+				VME_MS_WIN12_ED_ADDR_OFFSET, VME_MS_WIN13_ED_ADDR_OFFSET,
+				VME_MS_WIN14_ED_ADDR_OFFSET, VME_MS_WIN15_ED_ADDR_OFFSET,
+				VME_MS_WIN16_ED_ADDR_OFFSET, VME_MS_WIN17_ED_ADDR_OFFSET,
+				VME_MS_WIN18_ED_ADDR_OFFSET, VME_MS_WIN19_ED_ADDR_OFFSET,
+				VME_MS_WIN20_ED_ADDR_OFFSET, VME_MS_WIN21_ED_ADDR_OFFSET  };			
+
+/*FPGA VME CORE CFG MODE */
+#define CORE_CFG_BUSLOCK_MODE 						0x10
+#define CORE_CFG_LOCAL_CSR_MODE 					0x20
+#define CORE_CFG_EXT_CSR_MODE						0x40
+#define CORE_CFG_VME_BUS_MODE						0x50
+#define CORE_CFG_CLEAR_MODE							0x60
+#define CORE_CFG_UPPER_3BIT_VMEADDR_MODE  			0x80
+#define CORE_CFG_MODE_MASK  						0xF0
+#define CORE_CFG_DSIZE_8BIT_MODE 					0x01
+#define CORE_CFG_DSIZE_16BIT_MODE	 				0x02
+#define CORE_CFG_DSIZE_32BIT_MODE	 				0x03
+#define CORE_CFG_CORE_VAL_MASK  					0x0F
+#define CORE_CFG_CLEAR								0x0
+#define CORE_CFG_EN_VME_BUS							0x0
+#define CORE_CFG_EN_BUSLOCK          				(1 << 8)
+#define CORE_CFG_EN_LOCAL_CSR          				(1 << 9)
+#define CORE_CFG_EN_EXT_CSR          				(1 << 10)
+#define CORE_CFG_SET_DSIZE_8BIT         			(1 << 20)
+#define CORE_CFG_SET_DSIZE_16BIT         			(2 << 20)
+#define CORE_CFG_SET_DSIZE_32BIT         			(3 << 20)
+#define CORE_CFG_SET_DSIZE(x)	         			(x << 20)
+#define CORE_CFG_SET_UPPER_3BIT_VMEADDR_MASK        (3 << 29)
+#define CORE_CFG_SET_UPPER_3BIT_VMEADDR(x)      	(x << 29)
+
+
+#define INICORE_AM_A32					0x00		/* A32 Address Space */
+#define INICORE_AM_A24					0x30		/* A24 Address Space */
+#define INICORE_AM_A16					0x20		/* A16 Address Space */
+#define INICORE_AM_CRCSR				0x2F		/* CRCSR Address Space */
+#define INICORE_AM_MBLT					0x00		/* MBLT data cycle */
+#define INICORE_AM_DAT					0x01		/* DATA Access */
+#define INICORE_AM_PGM					0x02		/* Program Access */
+#define INICORE_AM_BLT					0x03		/* BLT data cycle */
+#define INICORE_AM_NPRIV				0x08		/* Non-Priv (User) Access */
+#define INICORE_AM_SURP					0x0C		/* Supervisor Access */
+
+#define INICORE_DW32					0x03		/* 32 Data Width */
+#define INICORE_DW16					0x02		/* 16 Data Width */
+#define INICORE_DW08					0x01		/* 8 Data Width */
+
+/*
+ * LCSR definitions
+ */
+
+#define INICORE_LCSR_DEV_CTRL			0x0F0
+#define INICORE_LCSR_DEV_VER			0x0FC
+#define INICORE_LCSR_SYS_CTRL			0x0D0
+#define INICORE_LCSR_VME_MSTR			0x0B0
+
+#define INICORE_LCSR_SLV_ACC_DEC1		0x0A8
+#define INICORE_LCSR_SLV_ACC_CMP1		0x0A4
+#define INICORE_LCSR_SLV_ACC_MSK1		0x0A0
+#define INICORE_LCSR_SLV_ACC_DEC2		0x098
+#define INICORE_LCSR_SLV_ACC_CMP2		0x094
+#define INICORE_LCSR_SLV_ACC_MSK2		0x090
+#define INICORE_LCSR_SLV_ACC_DEC3		0x088
+#define INICORE_LCSR_SLV_ACC_CMP3		0x084
+#define INICORE_LCSR_SLV_ACC_MSK3		0x080
+#define INICORE_LCSR_SLV_ACC_DEC4		0x078
+#define INICORE_LCSR_SLV_ACC_CMP4		0x074
+#define INICORE_LCSR_SLV_ACC_MSK4		0x070
+
+#define INICORE_LCSR_DMA_STAT			0x06C 
+#define INICORE_LCSR_DMA_CMD			0x068
+#define INICORE_LCSR_DMA_LADDR			0x064
+#define INICORE_LCSR_DMA_VADDR			0x060
+
+#define INICORE_LCSR_MAILBOX1			0x05C
+#define INICORE_LCSR_MAILBOX2			0x058
+#define INICORE_LCSR_MAILBOX3			0x054
+#define INICORE_LCSR_MAILBOX4			0x050
+#define INICORE_LCSR_SEMAPHORE			0x040
+
+#define INICORE_LCSR_VINT_STAT_SW		0x03C
+#define INICORE_LCSR_VINT_MAP			0x038
+#define INICORE_LCSR_VINT_STAT			0x034
+#define INICORE_LCSR_VINT				0x030
+#define INICORE_LCSR_VME_IRQ1_STAT		0x02C
+#define INICORE_LCSR_VME_IRQ2_STAT		0x028
+#define INICORE_LCSR_VME_IRQ3_STAT		0x024
+#define INICORE_LCSR_VME_IRQ4_STAT		0x020
+#define INICORE_LCSR_VME_IRQ5_STAT		0x01C
+#define INICORE_LCSR_VME_IRQ6_STAT		0x018
+#define INICORE_LCSR_VME_IRQ7_STAT		0x014
+
+static const int INICORE_LCSR_VME_IRQn_STAT[8] = { 0, INICORE_LCSR_VME_IRQ1_STAT,
+				INICORE_LCSR_VME_IRQ2_STAT, INICORE_LCSR_VME_IRQ3_STAT,
+				INICORE_LCSR_VME_IRQ4_STAT, INICORE_LCSR_VME_IRQ5_STAT,
+				INICORE_LCSR_VME_IRQ6_STAT, INICORE_LCSR_VME_IRQ7_STAT };
+
+#define INICORE_LCSR_VME_IRQn_STAT_D08_VINTHn_ERR   0x100
+#define INICORE_LCSR_VME_IRQn_STAT_D16_VINTHn_ERR   0x10000
+
+#define INICORE_LCSR_VINT_IRQH_CMD		0x010
+#define INICORE_LCSR_VINT_STATUS		0x00C
+#define INICORE_LCSR_VINT_EBL			0x008
+#define INICORE_LCSR_INT_STATUS			0x004
+#define INICORE_LCSR_INT_EBL			0x000
+
+
+
+/*
+ * CR/CSR
+ */
+
+/*
+ *        CR/CSR   LCR/LCSR
+ * offset  7FFF4   FF4 - CSRBCR
+ * offset  7FFF8   FF8 - CSRBSR
+ * offset  7FFFC   FFC - CBAR
+ */
+#define INICORE_CSRBAR				0x7FC /* CR/CSR BAR */
+#define INICORE_CSRBSR				0x7F8 /* Bit Set Regiseter */
+#define INICORE_CSRBCR				0x7F4 /* Bit Clear Register */
+#define INICORE_CSRCRAM				0x7F0 /* Config RAM Onwer Register */
+#define INICORE_CSRUBSR				0x7EC /* User Bit-set register */
+#define INICORE_CSRUBCR				0x7E8 /* User Bit-Clear register */
+#define INICORE_CSRADER3			0x790 /* Function 3 ADER */
+#define INICORE_CSRADER2			0x780 /* Function 2 ADER */
+#define INICORE_CSRADER1			0x770 /* Function 1 ADER */
+#define INICORE_CSRADER0			0x760 /* Function 0 ADER */
+#define INICORE_CSRADERn_0_OFFSET 	0x000 /*[31:24]offset of CSRADERn register*/			
+#define INICORE_CSRADERn_4_OFFSET 	0x004 /*[23:16]offset of CSRADERn register*/				
+#define INICORE_CSRADERn_8_OFFSET 	0x008 /*[15:8]offset of CSRADERn register*/			
+#define INICORE_CSRADERn_C_OFFSET 	0x00C /*[7:0]offset of CSRADERn register*/			
+	
+/*
+ *  Inicore CSR Register Bit Definitions
+ * 
+ */
+
+/*
+ *  CSR ADER Window[1~4]
+ * 	CRG +  0x760
+ * 	CRG +  0x770
+ * 	CRG +  0x780
+ * 	CRG +  0x790
+ */
+#define INICORE_CSRADERn_ADDRCB_M				(0xFF<<24)	/* Address bus compare bit*/
+#define INICORE_CSRADERn_AM_M					(0x3F<<2)	/* Address Modifer Mask */
+#define INICORE_CSRADERn_AM_S(x)				(x<<2)		/* Address Modifer Shift */
+
+#define INICORE_CSRADERn_AM_AS_M				(7<<5)	/* Address Space Mask */
+#define INICORE_CSRADERn_AM_A24					(7<<5)	/* A24 Address Space */
+#define INICORE_CSRADERn_AM_A32					(1<<5)	/* A32 Address Space */
+#define INICORE_CSRADERn_AM_AC_M				(7<<2)	/* Access Mask */
+#define INICORE_CSRADERn_AM_SUPR				(4<<2)	/* Supervisor Access */
+#define INICORE_CSRADERn_AM_BLT					(3<<2)	/* BLT Cycle */
+#define INICORE_CSRADERn_AM_PGM					(2<<2)	/* Program Access */
+#define INICORE_CSRADERn_AM_DAT					(1<<2)	/* Data Access */
+#define INICORE_CSRADERn_AM_NPRIV				(0<<2)	/* Non-Priv (User) Access */
+
+/*
+ *  Inicore Register Bit Definitions
+ */
+
+/*
+ *  Device Control DEV_CTRL + 0F0
+ */ 
+#define INICORE_LCSR_DEV_CTRL_LENDIAN	(0x1<<0)	/* little endian local bus*/
+
+/*
+ *  System Contoller SYS_CTRL + 0D0
+ */ 
+
+#define INICORE_LCSR_SYSC_BERRTIMER(x)	(x << 16) /* Bus Error Timeout*/
+#define INICORE_LCSR_SYSC_ACFALEN		(1<<12)	/* Sys reset upon ACFAIL */
+#define INICORE_LCSR_SYSC_LRESET		(1<<11)	/* Local Reset */
+#define INICORE_LCSR_SYSC_SRESET		(1<<10)	/* VME System reset */
+#define INICORE_LCSR_SYSC_BUSARB		(1<<9)	/* Bus Arbiter*/
+#define INICORE_LCSR_SYSC_SCONEN		(1<<8)	/* Enable System Cont*/
+#define INICORE_LCSR_SYSC_SCONS			(1<<6)	/* System Cont Status */
+#define INICORE_LCSR_SYSC_GAP			(1<<5)	/* Geographic Addr Parity */
+#define INICORE_LCSR_SYSC_GA_M			(0x1F<<0)  /* Geographic Addr Mask */
+
+
+/*
+ *  Slave Access Address Decoder Mask Window[1~4]
+ * 	CRG +  0x0A0
+ * 	CRG +  0x0A4
+ * 	CRG +  0x0A8
+ * 	CRG +  0x0AC
+ */
+#define INICORE_LCSR_SLVW_ADEM_M		(0xFFFFFF << 8) /*Address Decoder Mask Mask*/
+#define INICORE_LCSR_SLVW_ADEM_S(x)		(x << 8) 		/*Address Decoder Mask Shift*/
+
+/*
+ *  Slave Access Decoding Window[1~4] 
+ * 	CRG +  0x0A8
+ * 	CRG +  0x098
+ * 	CRG +  0x088
+ * 	CRG +  0x078
+ */
+#define INICORE_LCSR_SLVW_EBL			(1 << 31) 		/*Slave Window Enable*/
+#define INICORE_LCSR_SLVW_OFFSET_M		(0xFFFF << 8) 	/*Address Offset*/
+
+/*
+ *  VME Interrupt Map CRG + 038
+ */
+#define INICORE_LCSR_VINT_MAP_D32			(1<<9) /* VMEbus SW IRQ D32 */
+#define INICORE_LCSR_VINT_MAP_D16			(1<<8) /* VMEbus SW IRQ D16 */
+#define INICORE_LCSR_VINT_MAP_D8			(0<<8) /* VMEbus SW IRQ D08 */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_M    	(7<<4)	/* VMEbus USR IRQ Level Mask */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_1		(1<<4)	/* VMEbus USR IRQ Level 1 */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_2		(2<<4)	/* VMEbus USR IRQ Level 2 */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_3		(3<<4)	/* VMEbus USR IRQ Level 3 */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_4		(4<<4)	/* VMEbus USR IRQ Level 4 */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_5		(5<<4)	/* VMEbus USR IRQ Level 5 */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_6		(6<<4)	/* VMEbus USR IRQ Level 6 */
+#define INICORE_LCSR_VINT_MAP_USRIRQL_7		(7<<4)	/* VMEbus USR IRQ Level 7 */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_M    	(7<<0)	/* VMEbus SW IRQ Level Mask */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_1		(1<<0)	/* VMEbus SW IRQ Level 1 */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_2		(2<<0)	/* VMEbus SW IRQ Level 2 */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_3		(3<<0)	/* VMEbus SW IRQ Level 3 */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_4		(4<<0)	/* VMEbus SW IRQ Level 4 */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_5		(5<<0)	/* VMEbus SW IRQ Level 5 */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_6		(6<<0)	/* VMEbus SW IRQ Level 6 */
+#define INICORE_LCSR_VINT_MAP_SWIRQL_7		(7<<0)	/* VMEbus SW IRQ Level 7 */
+
+static const int INICORE_LCSR_VINT_MAP_SWIRQL[8] = { 0, INICORE_LCSR_VINT_MAP_SWIRQL_1,
+			INICORE_LCSR_VINT_MAP_SWIRQL_2, INICORE_LCSR_VINT_MAP_SWIRQL_3,
+			INICORE_LCSR_VINT_MAP_SWIRQL_4, INICORE_LCSR_VINT_MAP_SWIRQL_5,
+			INICORE_LCSR_VINT_MAP_SWIRQL_6, INICORE_LCSR_VINT_MAP_SWIRQL_7 };
+
+static const int INICORE_LCSR_VINT_MAP_USRIRQL[8] = { 0, INICORE_LCSR_VINT_MAP_USRIRQL_1,
+			INICORE_LCSR_VINT_MAP_USRIRQL_2, INICORE_LCSR_VINT_MAP_USRIRQL_3,
+			INICORE_LCSR_VINT_MAP_USRIRQL_4, INICORE_LCSR_VINT_MAP_USRIRQL_5,
+			INICORE_LCSR_VINT_MAP_USRIRQL_6, INICORE_LCSR_VINT_MAP_USRIRQL_7 };
+/*
+ *  VME Interrupt Status/ID CRG + 0014
+ */
+
+/*
+ *  VME Interrupt Handler Command CRG + 0010
+ */
+#define INICORE_LCSR_VINT_IRQH_INTx_TYP_D32			(1<<9) /* interrupt status/id D32 */
+#define INICORE_LCSR_VINT_IRQH_INTx_TYP_D16			(1<<8) /* interrupt status/id D16 */
+#define INICORE_LCSR_VINT_IRQH_INTx_TYP_D8			(0<<8) /* interrupt status/id D8 */
+#define INICORE_LCSR_VINT_IRQH_INT1_ERR	(1<<6)
+#define INICORE_LCSR_VINT_IRQH_INT2_ERR	(1<<5)
+#define INICORE_LCSR_VINT_IRQH_INT3_ERR	(1<<4)
+#define INICORE_LCSR_VINT_IRQH_INT4_ERR	(1<<3)
+#define INICORE_LCSR_VINT_IRQH_INT5_ERR	(1<<2)
+#define INICORE_LCSR_VINT_IRQH_INT6_ERR	(1<<1)
+#define INICORE_LCSR_VINT_IRQH_INT7_ERR	(1<<0)
+/*
+ *  VME Interrupt Status CRG + 00C
+ */
+
+#define INICORE_LCSR_VINT_STATUS_UIRQ	(1<<1)
+#define INICORE_LCSR_VINT_STATUS_SWIRQ	(1<<0)
+
+/*
+ *  Interrupt Status INT_STATUS CRG + 004
+ */
+#define INICORE_LCSR_IS_MBOX3			(1<<17)	/* Mail Box 3 */
+#define INICORE_LCSR_IS_MBOX2       	(1<<16)	/* Mail Box 2 */
+#define INICORE_LCSR_IS_MBOX1       	(1<<15)	/* Mail Box 1 */
+#define INICORE_LCSR_IS_MBOX0       	(1<<14)	/* Mail Box 0 */
+#define INICORE_LCSR_IS_VTIERR        	(1<<13)	/* VME Arbiter temer error */
+#define INICORE_LCSR_IS_VBERR			(1<<12)	/* VMEbus Error */
+#define INICORE_LCSR_IS_DMAERR			(1<<11)	/* DMA error */
+#define INICORE_LCSR_IS_DMADONE			(1<<10)	/* DMA Done */
+#define INICORE_LCSR_IS_SWIACK     		(1<<9)	/* SW Interrupt Ack (IACK) */
+#define INICORE_LCSR_IS_IRQ1       		(1<<8)	/* IRQ1 */
+#define INICORE_LCSR_IS_IRQ2       		(1<<7)	/* IRQ2 */
+#define INICORE_LCSR_IS_IRQ3       		(1<<6)	/* IRQ3 */
+#define INICORE_LCSR_IS_IRQ4       		(1<<5)	/* IRQ4 */
+#define INICORE_LCSR_IS_IRQ5       		(1<<4)	/* IRQ5 */
+#define INICORE_LCSR_IS_IRQ6       		(1<<3)	/* IRQ6 */
+#define INICORE_LCSR_IS_IRQ7       		(1<<2)	/* IRQ7 */
+#define INICORE_LCSR_IS_SYSFAL     		(1<<1)	/* System Fail */
+#define INICORE_LCSR_IS_ACFAL		 	(1<<0)	/* AC Fail */
+
+static const int INICORE_LCSR_IS_IRQn[8] = { 0, INICORE_LCSR_IS_IRQ1,
+					INICORE_LCSR_IS_IRQ2,
+					INICORE_LCSR_IS_IRQ3,
+					INICORE_LCSR_IS_IRQ4,
+					INICORE_LCSR_IS_IRQ5,
+					INICORE_LCSR_IS_IRQ6,
+					INICORE_LCSR_IS_IRQ7 };
+
+/*
+ *  Interrupt Enable INT_ENBL CRG + 000
+ */
+#define INICORE_LCSR_IE_MBOX3		(1<<17)	/* Mail Box 3 */
+#define INICORE_LCSR_IE_MBOX2       (1<<16)	/* Mail Box 2 */
+#define INICORE_LCSR_IE_MBOX1       (1<<15)	/* Mail Box 1 */
+#define INICORE_LCSR_IE_MBOX0       (1<<14)	/* Mail Box 0 */
+#define INICORE_LCSR_IE_VTIERR		(1<<13)	/* VME Arbiter temer error */
+#define INICORE_LCSR_IE_VBERR		(1<<12)	/* VMEbus Error */
+#define INICORE_LCSR_IE_DMAERR		(1<<11)	/* DMA error */
+#define INICORE_LCSR_IE_DMADONE		(1<<10)	/* DMA Done */
+#define INICORE_LCSR_IE_SWIACK     	(1<<9)	/* SW Interrupt Ack (IACK) */
+#define INICORE_LCSR_IE_IRQ1       	(1<<8)	/* IRQ1 */
+#define INICORE_LCSR_IE_IRQ2       	(1<<7)	/* IRQ2 */
+#define INICORE_LCSR_IE_IRQ3       	(1<<6)	/* IRQ3 */
+#define INICORE_LCSR_IE_IRQ4       	(1<<5)	/* IRQ4 */
+#define INICORE_LCSR_IE_IRQ5       	(1<<4)	/* IRQ5 */
+#define INICORE_LCSR_IE_IRQ6       	(1<<3)	/* IRQ6 */
+#define INICORE_LCSR_IE_IRQ7       	(1<<2)	/* IRQ7 */
+#define INICORE_LCSR_IE_SYSFAL     	(1<<1)	/* System Fail */
+#define INICORE_LCSR_IE_ACFAL		 	(1<<0)	/* AC Fail */
+
+static const int INICORE_LCSR_IE_IRQn[8] = { 0, INICORE_LCSR_IE_IRQ1,
+					INICORE_LCSR_IE_IRQ2,
+					INICORE_LCSR_IE_IRQ3,
+					INICORE_LCSR_IE_IRQ4,
+					INICORE_LCSR_IE_IRQ5,
+					INICORE_LCSR_IE_IRQ6,
+					INICORE_LCSR_IE_IRQ7 };
+
+
+
+#endif				/* TSI148_H */
diff --git a/drivers/vme/devices/Kconfig b/drivers/vme/devices/Kconfig
new file mode 100644
index 0000000..0b199a8
--- /dev/null
+++ b/drivers/vme/devices/Kconfig
@@ -0,0 +1,8 @@
+comment "VME Device Drivers"
+
+config NAI_VME_USER
+	tristate "NAI VME user space access driver"
+	help
+	  If you say Y here you want to be able to access VME windows.
+
+
diff --git a/drivers/vme/devices/Makefile b/drivers/vme/devices/Makefile
new file mode 100644
index 0000000..7d0af31
--- /dev/null
+++ b/drivers/vme/devices/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the VME device drivers.
+#
+
+obj-$(CONFIG_NAI_VME_USER) += nai_vme_user.o
+nai_vme_user-y		   := nai_vme_usr.o nai_vme_int.o ring_buffer.o
diff --git a/drivers/vme/devices/nai_vme_int.c b/drivers/vme/devices/nai_vme_int.c
new file mode 100644
index 0000000..bfc7a1e
--- /dev/null
+++ b/drivers/vme/devices/nai_vme_int.c
@@ -0,0 +1,343 @@
+//#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#define pr_fmt(fmt) "%s:%d>" fmt,strrchr(__FILE__,'/'),__LINE__
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/pagemap.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/syscalls.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/vme.h>
+
+#include "ring_buffer.h" 
+#include "nai_vme_int.h"
+#include "nai_vme_usr.h"
+
+//#define    DEBUG_IT
+
+
+#ifdef DEBUG_IT
+static void printk_hex_info(const char* func_name,int line_nu,const u8* hex_info,unsigned int info_size)
+{
+   #define COLUMN_NUM 16
+   #define DELIMITER ','
+   #define ELEMENT_SIZE 3  /*including 2 bytes hex num and 1 byte field delimiter ',' or '\n'*/
+   char work_buf[ELEMENT_SIZE*COLUMN_NUM+sizeof(int)/*sizeof(int) is used for last str delimiter '\0' and mem alignment*/];
+   unsigned int i;
+
+   memset(work_buf,0,sizeof(work_buf));
+   for(i=0;i<info_size;i++)
+   {
+      sprintf(work_buf+(i*ELEMENT_SIZE)%(COLUMN_NUM*ELEMENT_SIZE),"%02x%c",hex_info[i],(i==(info_size-1)||(i+1)%COLUMN_NUM==0)?'\n':DELIMITER);
+      if(i==(info_size-1)||(i+1)%COLUMN_NUM==0)
+      {
+         printk(KERN_INFO"%s",work_buf);
+         memset(work_buf,0,sizeof(work_buf));
+      }
+   }
+}
+#endif /*DEBUG_IT*/
+
+static int vme_int_dev_open(struct inode *inode, struct file *filp)
+{
+   /*
+    * setup filp->private_data for other funcs such as file_operations.read, file_operations.write and file_operations.ioctl to access
+    * fields in struct dev_file_mgr_info
+    */
+   filp->private_data=(struct dev_file_mgr_info*)container_of(inode->i_cdev,struct dev_file_mgr_info,char_dev);
+
+   ((struct dev_file_mgr_info*)(filp->private_data))->device_file_opend=DEVICE_FILE_OPENED;
+   ((struct dev_file_mgr_info*)(filp->private_data))->naii_int_ring_buf_mgr_ptr->rd_nonblock=(filp->f_flags&O_NONBLOCK)!=0;   //!=0->0,it is what we want
+
+#ifdef DEV_FILE_WR_OP
+   ((struct dev_file_mgr_info*)(filp->private_data))->naii_int_ring_buf_mgr_ptr->wr_nonblock=(filp->f_flags&O_NONBLOCK)!=0;
+#endif /* DEV_FILE_WR_OP */
+
+#ifdef DEBUG_IT
+   pr_info("\tfile name:\"%s\",vir_addr:0x%p\n",filp->f_path.dentry->d_iname,filp->private_data);
+   pr_info("((struct dev_file_mgr_info*)(filp->private_data))->naii_int_ring_buf_mgr_ptr->rd_nonblock=%d\n",((struct dev_file_mgr_info*)(filp->private_data))->naii_int_ring_buf_mgr_ptr->rd_nonblock);
+#endif
+
+   return nonseekable_open(inode, filp);
+}
+
+static int vme_int_dev_close(struct inode *i, struct file *filp)
+{
+#ifdef DEBUG_IT
+   pr_info("\tfile name:\"%s\",vir_addr:0x%p\n",filp->f_path.dentry->d_iname,filp->private_data);
+#endif
+   ((struct dev_file_mgr_info*)(filp->private_data))->device_file_opend=!DEVICE_FILE_OPENED;
+   return 0;
+}
+EXPORT_SYMBOL(vme_int_dev_close);
+
+static ssize_t vme_int_dev_read(struct file *filp, char __user *usr_buf, size_t count, loff_t *off)
+{
+#ifdef DEBUG_IT
+   pr_info("\tfile name:\"%s\",vir_addr:0x%p\n",filp->f_path.dentry->d_iname,filp->private_data);
+#endif
+
+   struct dev_file_mgr_info *dev_file_mgr_info_ptr=filp->private_data;
+
+   return naii_ring_buffer_read(dev_file_mgr_info_ptr->naii_int_ring_buf_mgr_ptr,usr_buf,count);
+}
+
+#ifdef DEV_FILE_WR_OP
+static ssize_t vme_int_dev_write(struct file* filp,const char __user *usr_buf,size_t count,loff_t* off)
+{
+   struct dev_file_mgr_info *dev_file_mgr_info_ptr=filp->private_data;
+   return naii_ring_buffer_write(dev_file_mgr_info_ptr->naii_int_ring_buf_mgr_ptr,usr_buf,count);
+#else /* !DEV_FILE_WR_OP */
+static int vme_int_dev_write(struct dev_file_mgr_info* dev_file_mgr_info_ptr,const char* in_buf,size_t count)
+{
+   #ifdef DEBUG_IT
+   pr_info("count:%d,dev_file_mgr_info_ptr:0x%p\n",count,dev_file_mgr_info_ptr);
+   #endif /* DEBUG_IT */
+
+   if(dev_file_mgr_info_ptr->device_file_opend!=DEVICE_FILE_OPENED)
+   {
+      pr_err("DEVICE FILE \"%s\" IS NOT OPENED!!!\n",dev_file_mgr_info_ptr->nai_vme_int_class->name);
+      return -ERESTARTSYS;
+   }
+
+   return naii_ring_buffer_write(dev_file_mgr_info_ptr->naii_int_ring_buf_mgr_ptr,in_buf,count);
+#endif /* DEV_FILE_WR_OP */
+}
+
+#ifdef DEV_FILE_WR_OP
+/* TBD test it if it is uesed */
+static int vme_int_fasync(int fd, struct file *filp, int mode)
+{
+   struct dev_file_mgr_info *dev_file_mgr_info_ptr=filp->private_data;
+   return fasync_helper(fd, filp, mode, &dev_file_mgr_info_ptr->naii_int_ring_buf_mgr_ptr->async_queue);
+}
+
+static int vme_int_release(struct inode *inode, struct file *filp)
+{
+   struct dev_file_mgr_info *dev_file_mgr_info_ptr=filp->private_data;
+   vme_int_fasync(-1,filp,0);
+}
+#endif /* DEV_FILE_WR_OP */
+
+static struct file_operations nai_vme_int_dev_file_ops =
+{
+   .owner =   THIS_MODULE,
+   .open =    vme_int_dev_open,
+   .release = vme_int_dev_close,
+   .read =    vme_int_dev_read,
+#ifdef DEV_FILE_WR_OP
+   .write =   vme_int_dev_write,
+   .fasync =  vme_int_fasync,
+   .release = vme_int_release,
+#endif /* DEV_FILE_WR_OP */
+};
+
+static int delete_dev_fs(struct dev_file_mgr_info *dev_file_mgr_info_ptr)
+{
+   int status=0;
+
+   device_destroy(dev_file_mgr_info_ptr->nai_vme_int_class, dev_file_mgr_info_ptr->first);
+
+   class_destroy(dev_file_mgr_info_ptr->nai_vme_int_class);
+
+   unregister_chrdev_region(dev_file_mgr_info_ptr->first,1);
+
+   return status;
+}
+
+static int create_dev_fs
+(
+   struct dev_file_mgr_info* dev_file_mgr_info_ptr,
+   const char* dev_file_name,
+   const char* parent_name,
+   struct file_operations* file_ops,
+   short ring_buf_sz,
+   int* status
+)
+{
+   *status=0;
+   memset( dev_file_mgr_info_ptr, 0, sizeof(*dev_file_mgr_info_ptr) );
+#ifdef DEBUG_IT
+   pr_info("dev_file_mgr_info_ptr vir_addr=0x%p\n",dev_file_mgr_info_ptr);
+#endif
+
+   if ((*status = alloc_chrdev_region(&dev_file_mgr_info_ptr->first, 0, 1, parent_name)) < 0) /*parent_name is in the file /proc/devices more than ones*/
+   {
+      pr_err("alloc_chrdev_region() err=%d\n",*status);
+      goto err_step_1;
+   }
+
+   /* creating "/sys/class/dev_file_name/dev_file_name" and "/sys/class/dev_file_name" */
+   if (IS_ERR(dev_file_mgr_info_ptr->nai_vme_int_class = class_create(THIS_MODULE, dev_file_name)))
+   {
+      pr_err("class_create() err=%ld for file \"%s\"\n",PTR_ERR(dev_file_mgr_info_ptr->nai_vme_int_class),dev_file_name);
+      *status=PTR_ERR(dev_file_mgr_info_ptr->nai_vme_int_class);
+      goto err_step_2;
+   }
+
+   if (IS_ERR(device_create(dev_file_mgr_info_ptr->nai_vme_int_class, NULL, dev_file_mgr_info_ptr->first, NULL, dev_file_name)))
+   {
+      *status = PTR_ERR(device_create(dev_file_mgr_info_ptr->nai_vme_int_class, NULL, dev_file_mgr_info_ptr->first, NULL, dev_file_name));
+      pr_err("device_create() err=%d, for file \"%s\"\n",*status,dev_file_name);
+      goto err_step_3;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("device file \"%s\" created\n",dev_file_name);
+#endif
+   /* char_dev is the member of dev_file_mgr_info_ptr points to, the address of dev_file_mgr_info_ptr can be gotten from address of char_dev with container_of(...)*/
+   cdev_init(&dev_file_mgr_info_ptr->char_dev,file_ops); /*make the link from address of struct cdev to address of struct struct dev_file_mgr_info*/
+   if ((*status = cdev_add(&dev_file_mgr_info_ptr->char_dev, dev_file_mgr_info_ptr->first, 1)) < 0)
+   {
+      pr_err("cdev_add() err=%d\n",*status);
+      goto err_step_4;
+   }
+
+#ifdef DEV_FILE_WR_OP
+   naii_ring_buffer_init(&dev_file_mgr_info_ptr->naii_int_ring_buf_mgr_ptr,ring_buf_sz,g_read_time_out_msecs,g_write_time_out_msecs);
+#else /*!DEV_FILE_WR_OP*/
+   naii_ring_buffer_init(&dev_file_mgr_info_ptr->naii_int_ring_buf_mgr_ptr,ring_buf_sz,g_read_time_out_msecs,g_write_time_out_msecs,g_non_block_wr_flag);
+#endif /*!DEV_FILE_WR_OP*/
+   return *status;
+
+err_step_4:
+   device_destroy(dev_file_mgr_info_ptr->nai_vme_int_class, dev_file_mgr_info_ptr->first);
+
+err_step_3:
+   class_destroy(dev_file_mgr_info_ptr->nai_vme_int_class);
+
+err_step_2:
+   unregister_chrdev_region(dev_file_mgr_info_ptr->first,1);
+
+err_step_1:
+
+   return *status;
+}
+/*EXPORT_SYMBOL(create_dev_fs);*/
+
+int create_nai_vme_int_dev_file(struct dev_file_mgr_info** dev_file_mgr_info_ptr,int int_level,short ring_buf_sz,int* status)
+{
+   *status=0;
+
+   *dev_file_mgr_info_ptr=kzalloc(sizeof(struct dev_file_mgr_info),GFP_KERNEL);
+
+   if(*dev_file_mgr_info_ptr==NULL)
+   {
+      pr_err("kzalloc(sizeof(struct dev_file_mgr_info),GFP_KERNEL) err\n");
+      *status = -ENOMEM;
+      goto err_step_1;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("**dev_file_mgr_info_ptr=0x%p,*dev_file_mgr_info_ptr=0x%p\n",**dev_file_mgr_info_ptr,*dev_file_mgr_info_ptr);
+#endif
+
+   *status=create_dev_fs
+           (
+              *dev_file_mgr_info_ptr,
+              kasprintf(GFP_KERNEL,"nai_vme_int_%d",int_level),
+              "nai_vme_int_parent_name",
+              &nai_vme_int_dev_file_ops,
+              ring_buf_sz,
+              status
+           );
+
+#ifdef DEBUG_IT
+   pr_info("ring_buf_sz:%d\n",ring_buf_sz);
+#endif
+
+   if((*status)!=0)
+   {
+       goto err_step_2;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("*dev_file_mgr_info_ptr=0x%p\n",*dev_file_mgr_info_ptr);
+#endif
+
+   return *status;
+
+err_step_2:
+   kfree(*dev_file_mgr_info_ptr);
+
+err_step_1:
+   return *status;
+}
+EXPORT_SYMBOL(create_nai_vme_int_dev_file);
+
+void vme_isr_bottom_half(struct work_struct* work_struct_ptr)
+{
+   int status=0;
+   struct int_work_q* int_work_q_ptr=container_of(work_struct_ptr,struct int_work_q,work_q);
+
+#ifdef DEBUG_IT
+   pr_info("dev_file_mgr_info_ptr=0x%p\n",int_work_q_ptr->dev_file_mgr_info_ptr);
+
+   printk(KERN_INFO"l:%d,v:0x%02x\n",int_work_q_ptr->int_level,int_work_q_ptr->int_vec);
+#endif
+
+#ifndef DEV_FILE_WR_OP
+   status=vme_int_dev_write(int_work_q_ptr->dev_file_mgr_info_ptr,((char*)(&int_work_q_ptr->int_vec)),sizeof(int_work_q_ptr->int_vec));
+#endif /*#ifndef DEV_FILE_WR_OP*/
+
+   if (status==-EAGAIN)
+   {
+      pr_err("INT LEVEL<%d>RING BUFFER WITH <%d> BYTES SIZE IS FULL,\"int_vec:0x%02x\" lost!!!\n",int_work_q_ptr->int_level,int_work_q_ptr->dev_file_mgr_info_ptr->naii_int_ring_buf_mgr_ptr->ring_buf_sz,int_work_q_ptr->int_vec);
+   }
+#ifdef DEBUG_IT
+   else
+   {
+      pr_info("vme_int_dev_write(...) successfully for \"int_vec:0x%02x\".\n",int_work_q_ptr->int_vec);
+   }
+#endif
+
+  /*
+   * The mem was allocated by the work queue's creator by calling
+   * struct int_work_q* int_work_q_ptr=(struct int_work_q*)kmalloc(sizeof(struct int_work_q),GFP_ATOMIC);
+   */
+   kfree((void*)int_work_q_ptr);
+}
+EXPORT_SYMBOL(vme_isr_bottom_half);
+
+int delete_nai_vme_int_dev_file(struct dev_file_mgr_info** dev_file_mgr_info_ptr,bool force)
+{
+   int status=0;
+
+#ifdef DEBUG_IT
+   pr_info("*dev_file_mgr_info_ptr:%p\n",*dev_file_mgr_info_ptr);
+#endif
+   if(*dev_file_mgr_info_ptr!=NULL)
+   {
+      if
+      (
+         (*dev_file_mgr_info_ptr)->device_file_opend==DEVICE_FILE_OPENED
+         &&
+         force!=true
+      )
+      {
+        pr_err("can't delete dev file \"%s\", it is still opened\n",(*dev_file_mgr_info_ptr)->nai_vme_int_class->name); 
+        status=-EBUSY;
+      }
+      else
+      {
+        naii_ring_buffer_release(&(*dev_file_mgr_info_ptr)->naii_int_ring_buf_mgr_ptr);
+        delete_dev_fs(*dev_file_mgr_info_ptr);
+        kfree(*dev_file_mgr_info_ptr);
+      }
+   }
+
+   return status;
+}
+EXPORT_SYMBOL(delete_nai_vme_int_dev_file);
diff --git a/drivers/vme/devices/nai_vme_int.h b/drivers/vme/devices/nai_vme_int.h
new file mode 100644
index 0000000..c2157d4
--- /dev/null
+++ b/drivers/vme/devices/nai_vme_int.h
@@ -0,0 +1,33 @@
+#ifndef _NAI_VME_INT_H_
+#define _NAI_VME_INT_H_
+
+static int g_read_time_out_msecs=WAIT_FOREVER;
+static int g_write_time_out_msecs=60*60*1000;            // 1 hour
+
+#ifndef DEV_FILE_WR_OP
+static int g_non_block_wr_flag=false;
+#endif /*!DEV_FILE_WR_OP*/
+
+struct dev_file_mgr_info
+{
+  struct ring_buf_mgr* naii_int_ring_buf_mgr_ptr;
+  u64  device_file_opend: 1;               /* device file opened. */
+
+  dev_t first;                             /* for the first device number */
+
+  struct class *nai_vme_int_class;         /* device class */
+  struct cdev char_dev;                    /* char device structure */
+};
+
+struct int_work_q
+{
+  struct work_struct work_q;               /* for "Top Half and Bottom Half" implementation */
+  struct dev_file_mgr_info* dev_file_mgr_info_ptr;
+  u8 int_vec;
+  u8 int_level;
+};
+
+void vme_isr_bottom_half(struct work_struct* work_struct_ptr);
+int create_nai_vme_int_dev_file(struct dev_file_mgr_info** int_mgr_ptr,int int_level,short ring_buf_sz,int* status);
+int delete_nai_vme_int_dev_file(struct dev_file_mgr_info** dev_file_mgr_info_ptr,bool force);
+#endif /* _NAI_VME_INT_H_*/
diff --git a/drivers/vme/devices/nai_vme_usr.c b/drivers/vme/devices/nai_vme_usr.c
new file mode 100644
index 0000000..4da6428
--- /dev/null
+++ b/drivers/vme/devices/nai_vme_usr.c
@@ -0,0 +1,1226 @@
+/*
+ * VMEbus User access driver
+ *
+ *
+ * Author: NAII
+ * Copyright 2015 North Atlantic Industries
+ *
+ * Based on work by Martyn Welch <martyn.welch@ge.com>
+ * Copyright 2008 GE Intelligent Platforms Embedded Systems, Inc. 
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/syscalls.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/vme.h>
+
+#include "ring_buffer.h"
+#include "nai_vme_int.h"
+#include "nai_vme_usr.h"
+
+//#define  DEBUG_IT
+
+#define TRACE_VME_INT_CNT
+
+#ifdef TRACE_VME_INT_CNT
+/* This number is used to compare the interrupt count 
+ * in ISR bottom half passing to user space through the 
+ * ring buffer
+ */
+static uint32_t int_cnt=0;
+#endif /*TRACE_VME_INT_CNT*/
+
+static short g_ring_buffer_size=DEFAULT_RING_BUFFER_SIZE;
+
+module_param(g_ring_buffer_size,short,S_IRUGO);
+module_param(g_read_time_out_msecs,int,S_IRUGO);
+module_param(g_write_time_out_msecs,int,S_IRUGO);
+
+#ifndef DEV_FILE_WR_OP
+module_param(g_non_block_wr_flag,int,S_IRUGO);
+#endif /*!DEV_FILE_WR_OP*/
+
+static DEFINE_MUTEX(vme_user_mutex);
+static const char driver_name[] = "vme_user";
+
+static int bus[VME_USER_BUS_MAX];
+//static unsigned int bus_num;
+static int bus_num = 1;
+
+/* Currently Documentation/devices.txt defines the following for VME:
+ *
+ * 221 char	VME bus
+ *		  0 = /dev/bus/vme/m0		First master image
+ *		  1 = /dev/bus/vme/m1		Second master image
+ *		  2 = /dev/bus/vme/m2		Third master image
+ *		  3 = /dev/bus/vme/m3		Fourth master image
+ *		  4 = /dev/bus/vme/s0		First slave image
+ *		  5 = /dev/bus/vme/ctl		Control
+ *
+ *		It is expected that all VME bus drivers will use the
+ *		same interface.  For interface documentation see
+ *		http://www.vmelinux.org/.
+ *
+ * However the VME driver at http://www.vmelinux.org/ is rather old and doesn't
+ * even support the tsi148 chipset (which has 8 master and 8 slave windows).
+ * We'll run with this for now as far as possible, however it probably makes
+ * sense to get rid of the old mappings and just do everything dynamically.
+ *
+ * So for now, we'll restrict the driver to providing 4 masters and 4 slaves as
+ * defined above and try to support at least some of the interface from
+ * http://www.vmelinux.org/ as an alternative the driver can be written
+ * providing a saner interface later.
+ *
+ * The vmelinux.org driver never supported slave images, the devices reserved
+ * for slaves were repurposed to support all 8 master images on the UniverseII!
+ * We shall support 4 masters and 4 slaves with this driver.
+ */
+#define VME_MAJOR	221	/* VME Major Device Number */
+#define VME_DEVS	23 /* Number of dev entries */
+
+#define MASTER_MINOR	0
+#define MASTER_MAX	20
+#define SLAVE_MINOR	21
+/*TODO: Change Slave Max to 4 because we only have 1 slave window*/
+/*#define SLAVE_MAX	7*/
+#define SLAVE_MAX	21
+#define CONTROL_MINOR	22
+
+#define PCI_BUF_SIZE  0x20000	/* Size of one slave image buffer */
+
+/*
+ * Structure to handle image related parameters.
+ */
+struct image_desc {
+	void *kern_buf;	/* Buffer address in kernel space */
+	dma_addr_t pci_buf;	/* Buffer address in PCI address space */
+	unsigned long long size_buf;	/* Buffer size */
+	struct mutex mutex;	/* Mutex for locking image */
+	struct device *device;	/* Sysfs device */
+	struct vme_resource *resource;	/* VME resource */
+	int users;		/* Number of current users */
+};
+
+static struct image_desc image[VME_DEVS];
+
+struct driver_stats {
+	unsigned long reads;
+	unsigned long writes;
+	unsigned long ioctls;
+	unsigned long irqs;
+	unsigned long berrs;
+	unsigned long dmaerrors;
+	unsigned long timeouts;
+	unsigned long external;
+};
+
+static struct driver_stats statistics;
+
+static struct cdev *vme_user_cdev;		/* Character device */
+static struct class *vme_user_sysfs_class;	/* Sysfs class */
+static struct vme_dev *vme_user_bridge;		/* Pointer to user device */
+
+/*21 master 1 slave 1 control*/
+static const int type[VME_DEVS] = { MASTER_MINOR, MASTER_MINOR,
+					MASTER_MINOR, MASTER_MINOR, MASTER_MINOR,
+					MASTER_MINOR, MASTER_MINOR, MASTER_MINOR,
+					MASTER_MINOR, MASTER_MINOR, MASTER_MINOR,
+					MASTER_MINOR, MASTER_MINOR, MASTER_MINOR,
+					MASTER_MINOR, MASTER_MINOR, MASTER_MINOR,
+					MASTER_MINOR, MASTER_MINOR, MASTER_MINOR,
+					MASTER_MINOR, SLAVE_MINOR, CONTROL_MINOR
+				};
+
+static int vme_user_open(struct inode *, struct file *);
+static int vme_user_release(struct inode *, struct file *);
+static ssize_t vme_user_read(struct file *, char __user *, size_t, 
+	loff_t *);
+static ssize_t vme_user_write(struct file *, const char __user *, size_t,
+	loff_t *);
+static loff_t vme_user_llseek(struct file *, loff_t, int);
+static long vme_user_unlocked_ioctl(struct file *, unsigned int, 
+	unsigned long);
+
+static int vme_user_match(struct vme_dev *);
+static int vme_user_probe(struct vme_dev *);
+static int vme_user_remove(struct vme_dev *);
+
+static const struct file_operations vme_user_fops = {
+	.open = vme_user_open,
+	.release = vme_user_release,
+	.read = vme_user_read,
+	.write = vme_user_write,
+	.llseek = vme_user_llseek,
+	.unlocked_ioctl = vme_user_unlocked_ioctl,
+	.compat_ioctl = vme_user_unlocked_ioctl,
+};
+
+struct int_sysfs_entry
+{
+  struct kobj_attribute kobj_attr;
+  struct vme_dev *vdev;
+  struct dev_file_mgr_info *dev_file_mgr_info_ptr;
+  int level;
+  int enabled;
+};
+static void vme_isr_top_half_callback(int level, int status_id, void *priv);
+
+static int enable_vme_int(struct int_sysfs_entry* entry,u16 ring_buf_sz)
+{
+   int status;
+   create_nai_vme_int_dev_file(&entry->dev_file_mgr_info_ptr,entry->level,ring_buf_sz,&status);
+   if(status==0)
+   {
+#ifdef DEBUG_IT
+      pr_info("&entry->dev_file_mgr_info_ptr=0x%p\n",&entry->dev_file_mgr_info_ptr);
+#endif
+      status = vme_irq_request(entry->vdev, entry->level, vme_isr_top_half_callback, entry->dev_file_mgr_info_ptr);
+      if (status)
+      {
+         delete_nai_vme_int_dev_file(&entry->dev_file_mgr_info_ptr,false);
+         entry->enabled = 0;
+      }
+   }
+   else
+   {
+      entry->enabled = 0;
+   }
+   return status;
+}
+
+static void vme_isr_top_half_callback(int level, int status_id, void *priv)
+{
+  int result=0;
+
+  struct dev_file_mgr_info *dev_file_mgr_info_ptr=priv;
+
+#ifdef TRACE_VME_INT_CNT
+int_cnt++;
+#endif /*TRACE_VME_INT_CNT*/
+
+#ifdef DEBUG_IT
+  pr_info("level:%d,vec:0x%02x,dev_file_mgr_info_ptr:0x%p\n",level,status_id,dev_file_mgr_info_ptr);
+#endif
+
+  if(dev_file_mgr_info_ptr!=NULL)
+  { 
+     struct int_work_q* int_work_q_ptr=(struct int_work_q*)kmalloc(sizeof(struct int_work_q),GFP_ATOMIC);
+     if(int_work_q_ptr!=NULL)
+     {
+        //int_work_q_ptr->dev_file_mgr_info_ptr=&dev_file_mgr_info_ptr[level-1]; //complex pointer //keep this line
+        int_work_q_ptr->dev_file_mgr_info_ptr=dev_file_mgr_info_ptr;
+
+        int_work_q_ptr->int_vec=status_id;
+        int_work_q_ptr->int_level=level;
+
+        INIT_WORK(&int_work_q_ptr->work_q,vme_isr_bottom_half);
+
+#define CPU0        0
+#define CPU1        1
+       /*
+        * In the end of fuction vme_isr_bottom_half(struct work_struct* work_struct_ptr),
+        * int_work_q_ptr will be released by calling kfree((void*)int_work_q_ptr);
+        */
+        //result=schedule_work(&int_work_q_ptr->work_q);
+        result=schedule_work_on(CPU1,&int_work_q_ptr->work_q);
+        //result=schedule_work_on(CPU0,&int_work_q_ptr->work_q);
+
+        if(result!=true)
+        {
+           pr_err("work was already on the kernel-global workqueue\n");
+        }
+#ifdef DEBUG_IT
+        else
+        {
+           pr_info("work q created for \"level:%d\", \"vec:0x%02x\".\n",level,status_id);
+        }
+#endif
+     }
+     else
+     {
+         pr_err("kmalloc(sizeof(struct int_work_q),GFP_ATOMIC) failed\n");
+     }
+  }
+  else
+  {
+     pr_err("interrupt level %d in not enabled\n",level);
+  }
+
+}
+
+static ssize_t int_enabled_show
+(
+  struct kobject *kobj,
+  struct kobj_attribute *attr,
+  char *buf
+)
+{
+   struct int_sysfs_entry *entry;
+
+   entry = container_of(attr, struct int_sysfs_entry, kobj_attr);
+
+#ifdef TRACE_VME_INT_CNT
+pr_info("caught %u interrupts in the top half.\n",int_cnt);
+#endif
+
+   return sprintf(buf, "%d\n", entry->enabled);
+}
+
+//'echo -n [0/1] > /sys/bus/vme/devices/vme_user.0-1/irq/7/ff/enabled' calls it
+static ssize_t int_enabled_store
+(
+   struct kobject *kobj,
+   struct kobj_attribute *attr,
+   const char *buf,
+   size_t count
+)
+{
+   int enabled;
+   struct int_sysfs_entry *entry;
+   int ret;
+
+   entry = container_of(attr, struct int_sysfs_entry, kobj_attr);
+
+   ret = kstrtoint(buf, 0, &enabled);
+   
+   if (ret)
+   {
+      return ret;
+   }
+
+   /* Make sure enabled is ether 0 or 1 */
+   enabled = !!enabled;
+
+   if (enabled == entry->enabled)
+   {
+#ifdef DEBUG_IT
+      pr_info("level %d already set to %d\n",entry->level,entry->enabled);
+#endif
+      return count;
+   }
+
+#ifdef DEBUG_IT
+   pr_info("enabled:%d,entry->level:%d,entry:0x%p\n",enabled,entry->level,entry);
+#endif
+
+   if (enabled)
+   {
+      ret = enable_vme_int(entry,g_ring_buffer_size);
+   }
+   else
+   {
+      ret=delete_nai_vme_int_dev_file(&entry->dev_file_mgr_info_ptr,false);
+      
+      if(ret==0)
+      {
+         vme_irq_free(entry->vdev, entry->level);
+      }
+   }
+
+   if(ret==0)
+   {
+      entry->enabled = enabled;
+   }
+
+#ifdef DEBUG_IT
+pr_info("count=%d\n",count); 
+#endif
+   return ret==0?count:ret;
+}
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+static struct kobj_attribute int_enabled_attribute =
+{
+   .attr =
+   {
+      .name = "enabled",
+      .mode = 0644,
+   },
+   .store = int_enabled_store,
+   .show = int_enabled_show,
+};
+#else
+static struct kobj_attribute int_enabled_attribute =
+   __ATTR(stat_id, 0644, int_statid_show, int_statid_store);
+#endif
+
+/*
+ * Reset all the statistic counters
+ */
+static void reset_counters(void)
+{
+   statistics.reads = 0;
+   statistics.writes = 0;
+   statistics.ioctls = 0;
+   statistics.irqs = 0;
+   statistics.berrs = 0;
+   statistics.dmaerrors = 0;
+   statistics.timeouts = 0;
+}
+
+static int vme_user_open(struct inode *inode, struct file *file)
+{
+  int err;
+  unsigned int minor = MINOR(inode->i_rdev);
+
+  mutex_lock(&image[minor].mutex);
+  /* Allow device to be opened if a resource is needed and allocated. */
+  if (minor < CONTROL_MINOR && image[minor].resource == NULL)
+  {
+    pr_err("No resources allocated for device\n");
+    err = -EINVAL;
+    goto err_res;
+  }
+
+	/* Increment user count */
+	image[minor].users++;
+
+	mutex_unlock(&image[minor].mutex);
+
+	return 0;
+
+err_res:
+	mutex_unlock(&image[minor].mutex);
+
+	return err;
+}
+
+static int vme_user_release(struct inode *inode, struct file *file)
+{
+	unsigned int minor = MINOR(inode->i_rdev);
+
+	mutex_lock(&image[minor].mutex);
+
+	/* Decrement user count */
+	image[minor].users--;
+
+	mutex_unlock(&image[minor].mutex);
+
+	return 0;
+}
+
+/*
+ * We are going to alloc a page during init per window for small transfers.
+ * Small transfers will go VME -> buffer -> user space. Larger (more than a
+ * page) transfers will lock the user space buffer into memory and then
+ * transfer the data directly into the user space buffers.
+ */
+static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
+	loff_t *ppos)
+{
+	ssize_t retval;
+	ssize_t copied = 0;
+
+	if (count <= image[minor].size_buf) {
+		/* We copy to kernel buffer */
+		copied = vme_master_read(image[minor].resource,
+			image[minor].kern_buf, count, *ppos);
+		if (copied < 0)
+			return (int)copied;
+
+		retval = __copy_to_user(buf, image[minor].kern_buf,
+			(unsigned long)copied);
+		if (retval != 0) {
+			copied = (copied - retval);
+#ifdef DEBUG_IT
+         pr_info("User copy failed\n");
+#endif
+			return -EINVAL;
+		}
+
+	} else {
+		/* XXX Need to write this */
+#ifdef DEBUG_IT
+      pr_info("Currently don't support large transfers\n");
+#endif
+		/* Map in pages from userspace */
+
+		/* Call vme_master_read to do the transfer */
+		return -EINVAL;
+	}
+
+	return copied;
+}
+
+/*
+ * We are going to alloc a page during init per window for small transfers.
+ * Small transfers will go user space -> buffer -> VME. Larger (more than a
+ * page) transfers will lock the user space buffer into memory and then
+ * transfer the data directly from the user space buffers out to VME.
+ */
+static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	ssize_t retval;
+	ssize_t copied = 0;
+
+	if (count <= image[minor].size_buf) {
+		retval = __copy_from_user(image[minor].kern_buf, buf,
+			(unsigned long)count);
+		if (retval != 0)
+			copied = (copied - retval);
+		else
+			copied = count;
+
+		copied = vme_master_write(image[minor].resource,
+			image[minor].kern_buf, copied, *ppos);
+	} else {
+		/* XXX Need to write this */
+#ifdef DEBUG_IT
+		pr_info("Currently don't support large transfers\n");
+#endif
+		/* Map in pages from userspace */
+
+		/* Call vme_master_write to do the transfer */
+		return -EINVAL;
+	}
+
+	return copied;
+}
+
+static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	void *image_ptr;
+	ssize_t retval;
+
+	image_ptr = image[minor].kern_buf + *ppos;
+
+	retval = __copy_to_user(buf, image_ptr, (unsigned long)count);
+	if (retval != 0) {
+		retval = (count - retval);
+		pr_warn("Partial copy to userspace\n");
+	} else
+		retval = count;
+
+	/* Return number of bytes successfully read */
+	return retval;
+}
+
+static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	void *image_ptr;
+	size_t retval;
+
+	image_ptr = image[minor].kern_buf + *ppos;
+
+	retval = __copy_from_user(image_ptr, buf, (unsigned long)count);
+	if (retval != 0) {
+		retval = (count - retval);
+		pr_warn("Partial copy to userspace\n");
+	} else
+		retval = count;
+
+	/* Return number of bytes successfully read */
+	return retval;
+}
+
+static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
+			loff_t *ppos)
+{
+	unsigned int minor = MINOR(file_inode(file)->i_rdev);
+	ssize_t retval;
+	size_t image_size;
+	size_t okcount;
+
+	if (minor == CONTROL_MINOR)
+		return 0;
+
+	mutex_lock(&image[minor].mutex);
+
+	/* XXX Do we *really* want this helper - we can use vme_*_get ? */
+	image_size = vme_get_size(image[minor].resource);
+
+	/* Ensure we are starting at a valid location */
+	if ((*ppos < 0) || (*ppos > (image_size - 1))) {
+		mutex_unlock(&image[minor].mutex);
+		return 0;
+	}
+
+	/* Ensure not reading past end of the image */
+	if (*ppos + count > image_size)
+		okcount = image_size - *ppos;
+	else
+		okcount = count;
+
+	switch (type[minor]) {
+	case MASTER_MINOR:
+		retval = resource_to_user(minor, buf, okcount, ppos);
+		break;
+	case SLAVE_MINOR:
+		retval = buffer_to_user(minor, buf, okcount, ppos);
+		break;
+	default:
+		retval = -EINVAL;
+	}
+
+	mutex_unlock(&image[minor].mutex);
+	if (retval > 0)
+		*ppos += retval;
+
+	return retval;
+}
+
+static ssize_t vme_user_write(struct file *file, const char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	unsigned int minor = MINOR(file_inode(file)->i_rdev);
+	ssize_t retval;
+	size_t image_size;
+	size_t okcount;
+
+	if (minor == CONTROL_MINOR)
+		return 0;
+
+	mutex_lock(&image[minor].mutex);
+
+	image_size = vme_get_size(image[minor].resource);
+
+	/* Ensure we are starting at a valid location */
+	if ((*ppos < 0) || (*ppos > (image_size - 1))) {
+		mutex_unlock(&image[minor].mutex);
+		return 0;
+	}
+
+	/* Ensure not reading past end of the image */
+	if (*ppos + count > image_size)
+		okcount = image_size - *ppos;
+	else
+		okcount = count;
+
+	switch (type[minor]) {
+	case MASTER_MINOR:
+		retval = resource_from_user(minor, buf, okcount, ppos);
+		break;
+	case SLAVE_MINOR:
+		retval = buffer_from_user(minor, buf, okcount, ppos);
+		break;
+	default:
+		retval = -EINVAL;
+	}
+
+	mutex_unlock(&image[minor].mutex);
+
+	if (retval > 0)
+		*ppos += retval;
+
+	return retval;
+}
+
+static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
+{
+	loff_t absolute = -1;
+	unsigned int minor = MINOR(file_inode(file)->i_rdev);
+	size_t image_size;
+
+	if (minor == CONTROL_MINOR)
+		return -EINVAL;
+
+	mutex_lock(&image[minor].mutex);
+	image_size = vme_get_size(image[minor].resource);
+
+	switch (whence) {
+	case SEEK_SET:
+		absolute = off;
+		break;
+	case SEEK_CUR:
+		absolute = file->f_pos + off;
+		break;
+	case SEEK_END:
+		absolute = image_size + off;
+		break;
+	default:
+		mutex_unlock(&image[minor].mutex);
+		return -EINVAL;
+		break;
+	}
+
+	if ((absolute < 0) || (absolute >= image_size)) {
+		mutex_unlock(&image[minor].mutex);
+		return -EINVAL;
+	}
+
+	file->f_pos = absolute;
+
+	mutex_unlock(&image[minor].mutex);
+
+	return absolute;
+}
+
+/*
+ * The ioctls provided by the old VME access method (the one at vmelinux.org)
+ * are most certainly wrong as the effectively push the registers layout
+ * through to user space. Given that the VME core can handle multiple bridges,
+ * with different register layouts this is most certainly not the way to go.
+ *
+ * We aren't using the structures defined in the Motorola driver either - these
+ * are also quite low level, however we should use the definitions that have
+ * already been defined.
+ */
+static int vme_user_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	struct vme_master master;
+	struct vme_slave slave;
+	struct vme_irq_id irq_req;
+	unsigned long copied;
+	unsigned int minor = MINOR(inode->i_rdev);
+	int retval;
+	dma_addr_t pci_addr;
+	void __user *argp = (void __user *)arg;
+
+	statistics.ioctls++;
+
+	switch (type[minor]) {
+	case CONTROL_MINOR:
+		switch (cmd) {
+		case VME_IRQ_GEN:
+			copied = copy_from_user(&irq_req, argp,
+						sizeof(struct vme_irq_id));
+			if (copied != 0) {
+				pr_warn("Partial copy from userspace\n");
+				return -EFAULT;
+			}
+
+			retval = vme_irq_generate(vme_user_bridge,
+						  irq_req.level,
+						  irq_req.statid);
+
+			return retval;
+		}
+		break;
+	case MASTER_MINOR:
+		switch (cmd) {
+		case VME_GET_MASTER:
+			memset(&master, 0, sizeof(struct vme_master));
+
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			retval = vme_master_get(image[minor].resource,
+				&master.enable, &master.vme_addr,
+				&master.size, &master.aspace,
+				&master.cycle, &master.dwidth);
+
+			copied = copy_to_user(argp, &master,
+				sizeof(struct vme_master));
+			if (copied != 0) {
+				pr_warn("Partial copy to userspace\n");
+				return -EFAULT;
+			}
+
+			return retval;
+			break;
+
+		case VME_SET_MASTER:
+
+			copied = copy_from_user(&master, argp, sizeof(master));
+			if (copied != 0) {
+				pr_warn("Partial copy from userspace\n");
+				return -EFAULT;
+			}
+
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			return vme_master_set(image[minor].resource,
+				master.enable, master.vme_addr, master.size,
+				master.aspace, master.cycle, master.dwidth);
+
+			break;
+		case VME_RESET_MASTER_WINDOW:
+			retval = vme_master_reset_window(image[minor].resource);
+			return retval;
+			break;
+		}
+		break;
+	case SLAVE_MINOR:
+		switch (cmd) {
+		case VME_GET_SLAVE:
+			memset(&slave, 0, sizeof(struct vme_slave));
+
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			retval = vme_slave_get(image[minor].resource,
+				&slave.enable, &slave.vme_addr,
+				&slave.size, &pci_addr, &slave.aspace,
+				&slave.cycle);
+
+			copied = copy_to_user(argp, &slave,
+				sizeof(struct vme_slave));
+			if (copied != 0) {
+				pr_warn("Partial copy to userspace\n");
+				return -EFAULT;
+			}
+
+			return retval;
+			break;
+
+		case VME_SET_SLAVE:
+
+			copied = copy_from_user(&slave, argp, sizeof(slave));
+			if (copied != 0) {
+				pr_warn("Partial copy from userspace\n");
+				return -EFAULT;
+			}
+
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			return vme_slave_set(image[minor].resource,
+				slave.enable, slave.vme_addr, slave.size,
+				image[minor].pci_buf, slave.aspace,
+				slave.cycle);
+
+			break;
+		}
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static long vme_user_unlocked_ioctl(struct file *file, unsigned int cmd, 
+										unsigned long arg)
+{
+	long ret;
+
+	mutex_lock(&vme_user_mutex);
+	ret = vme_user_ioctl(file_inode(file), file, cmd, arg);
+	mutex_unlock(&vme_user_mutex);
+
+	return ret;
+}
+
+
+/*
+ * Unallocate a previously allocated buffer
+ */
+static void buf_unalloc(int num)
+{
+	if (image[num].kern_buf) {
+
+#ifdef VME_DEBUG
+		pr_debug("Releasing buffer at %p\n",
+			 image[num].pci_buf);
+#endif
+
+		vme_free_consistent(image[num].resource, image[num].size_buf,
+			image[num].kern_buf, image[num].pci_buf);
+
+		image[num].kern_buf = NULL;
+		image[num].pci_buf = 0;
+		image[num].size_buf = 0;
+
+#ifdef VME_DEBUG
+	} else {
+		pr_debug("Buffer not allocated\n");
+#endif
+	}
+}
+
+static struct vme_driver vme_user_driver = {
+	.name = driver_name,
+	.match = vme_user_match,
+	.probe = vme_user_probe,
+	.remove = vme_user_remove,
+};
+
+
+static int __init vme_user_init(void)
+{
+	int retval = 0;
+	struct vme_driver *driver;
+	pr_info("VME User Space Access Driver %d\n",bus_num);
+
+	if (bus_num == 0) {
+		pr_err("No cards, skipping registration\n");
+		retval = -ENODEV;
+		goto err_nocard;
+	}
+#if 0
+   /*
+    * This part is not necessary, it can cause memory leak because driver is re assigned value to  &vme_user_driver.
+    *
+    * fully tested by configuring the kernel module nai_vme_user to M, and run
+    * insmod nai_vme_user.ko
+    * rmmod nai_vme_user.ko
+    * after the board is booted. no kernel panic 10/31/2017
+    */
+   driver = kzalloc(sizeof(struct vme_driver), GFP_KERNEL);
+
+   if (driver == NULL) {
+      pr_err("Failed to allocate memory for device\n");
+      retval = -ENOMEM;
+      goto err_struct;
+   }
+#endif
+	
+	driver = &vme_user_driver;
+		
+	/* Let's start by supporting one bus, we can support more than one
+	 * in future revisions if that ever becomes necessary.
+	 */
+	if (bus_num > VME_USER_BUS_MAX) {
+		pr_err("Driver only able to handle %d buses\n",
+		       VME_USER_BUS_MAX);
+		bus_num = VME_USER_BUS_MAX;
+	}
+	
+	/*
+	 * Here we just register the maximum number of devices we can and
+	 * leave vme_user_match() to allow only 1 to go through to probe().
+	 * This way, if we later want to allow multiple user access devices,
+	 * we just change the code in vme_user_match().
+	 */
+	retval = vme_register_driver(driver, 1);
+	
+	if (retval != 0){
+		pr_err("Failed to register VME driver\n");
+		goto err_reg;
+	}
+	return retval;
+
+err_reg:
+//kfree(driver);
+//err_struct:
+err_nocard:
+	return retval;
+}
+
+static int vme_user_match(struct vme_dev *vdev)
+{
+	int i;
+	int cur_bus;
+	int cur_slot;
+	
+	cur_bus = vme_bus_num(vdev);
+	
+	cur_slot = vme_slot_num(vdev);
+	
+	for (i = 0; i < bus_num; i++)
+		if ((cur_bus == bus[i]) && (cur_slot == vdev->num))
+			return 1;
+
+	return 0;
+}
+
+static int vme_init_int_dev_file(struct vme_dev *vdev)
+{
+   
+   int err=0, level;
+   char *level_node_name;
+   struct kobject *level_node;
+   struct kobject *kobj;
+
+
+   kobj = kobject_create_and_add("irq", &vdev->dev.kobj);
+   
+   if(!kobj)
+      return -ENOMEM;
+   
+   for (level = 1; level <= VME_INT_LEVELS; level++)
+   {
+      struct int_sysfs_entry *entry;
+      
+      level_node_name = kasprintf(GFP_KERNEL, "%d", level);
+      
+      if (!level_node_name)
+         return -ENOMEM;
+      
+      level_node = kobject_create_and_add(level_node_name, kobj);
+      
+      if (!level_node)
+      {
+         kfree(level_node_name);
+         return -ENOMEM;
+      }
+
+      /*
+       * When the device is detached from the system or the driver for the device
+       * is unloaded, that memory is freed automatically.
+       */
+      entry = devm_kzalloc(&vdev->dev,sizeof(*entry), GFP_KERNEL); 
+      if (!entry)
+      {
+
+         return -ENOMEM;
+      }
+
+      entry->level = level;
+      entry->vdev = vdev;
+      entry->kobj_attr = int_enabled_attribute;
+      err = sysfs_create_file(level_node,&entry->kobj_attr.attr);
+      if (err)
+      {
+
+         return err;
+      }
+
+      if(err==0)
+      {
+         vdev->int_sysfs_entry[level-1]=entry;
+      }
+   }
+   
+
+   return err;
+	
+}
+
+/*
+ * In this simple access driver, the old behaviour is being preserved as much
+ * as practical. We will therefore reserve the buffers and request the images
+ * here so that we don't have to do it later.
+ */
+static int vme_user_probe(struct vme_dev *vdev)
+{
+	int i, err;
+	char name[12];
+
+	/* Save pointer to the bridge device */
+	if (vme_user_bridge != NULL) {
+		dev_err(&vdev->dev, "Driver can only be loaded for 1 device\n");
+		err = -EINVAL;
+		goto err_dev;
+	}
+	vme_user_bridge = vdev;
+
+	/* Initialise descriptors */
+	for (i = 0; i < VME_DEVS; i++) {
+		image[i].kern_buf = NULL;
+		image[i].pci_buf = 0;
+		mutex_init(&image[i].mutex);
+		image[i].device = NULL;
+		image[i].resource = NULL;
+		image[i].users = 0;
+	}
+
+	/* Initialise statistics counters */
+	reset_counters();
+
+	/* Assign major and minor numbers for the driver */
+	err = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,
+		driver_name);
+	if (err) {
+		dev_warn(&vdev->dev, "Error getting Major Number %d for driver.\n",
+			 VME_MAJOR);
+		goto err_region;
+	}
+
+	/* Register the driver as a char device */
+	vme_user_cdev = cdev_alloc();
+	if (!vme_user_cdev) {
+		err = -ENOMEM;
+		goto err_char;
+	}
+	vme_user_cdev->ops = &vme_user_fops;
+	vme_user_cdev->owner = THIS_MODULE;
+	err = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);
+	if (err) {
+		dev_warn(&vdev->dev, "cdev_all failed\n");
+		goto err_char;
+	}
+
+	/* Request slave resources and allocate buffers (128kB wide) */
+	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
+		image[i].resource = vme_slave_request(vme_user_bridge,
+			VME_A24, VME_DATA);
+		if (image[i].resource == NULL) {
+			dev_warn(&vdev->dev,
+				 "Unable to allocate slave resource\n");
+			err = -ENOMEM;
+			goto err_slave;
+		}
+	}
+
+	/*
+	 * Request master resources allocate page sized buffers for small
+	 * reads and writes
+	 */
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {
+		/* XXX Need to properly request attributes */
+		image[i].resource = vme_master_request(vme_user_bridge,
+			VME_A32, VME_DATA, VME_D32);
+		if (image[i].resource == NULL) {
+			dev_warn(&vdev->dev,
+				 "Unable to allocate master resource\n");
+			err = -ENOMEM;
+			goto err_master;
+		}
+		image[i].size_buf = PCI_BUF_SIZE;
+		image[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);
+		if (image[i].kern_buf == NULL) {
+			err = -ENOMEM;
+			goto err_master_buf;
+		}
+	}
+
+	/* Create sysfs entries - on udev systems this creates the dev files */
+	vme_user_sysfs_class = class_create(THIS_MODULE, driver_name);
+	if (IS_ERR(vme_user_sysfs_class)) {
+		dev_err(&vdev->dev, "Error creating vme_user class.\n");
+		err = PTR_ERR(vme_user_sysfs_class);
+		goto err_class;
+	}
+
+	/* Add sysfs Entries */
+	for (i = 0; i < VME_DEVS; i++) {
+		int num;
+		switch (type[i]) {
+		case MASTER_MINOR:
+			sprintf(name, "bus/vme/m%%d");
+			break;
+		case CONTROL_MINOR:
+			sprintf(name, "bus/vme/ctl");
+			break;
+		case SLAVE_MINOR:
+			sprintf(name, "bus/vme/s%%d");
+			break;
+		default:
+			err = -EINVAL;
+			goto err_sysfs;
+			break;
+		}
+
+		num = (type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i;
+		image[i].device = device_create(vme_user_sysfs_class, NULL,
+					MKDEV(VME_MAJOR, i), NULL, name, num);
+		if (IS_ERR(image[i].device)) {
+			dev_info(&vdev->dev, "Error creating sysfs device\n");
+			err = PTR_ERR(image[i].device);
+			goto err_sysfs;
+		}
+	}
+
+	err = vme_init_int_dev_file(vdev);
+	if(err)
+		return err;
+
+	return 0;
+
+	/* Ensure counter set correcty to destroy all sysfs devices */
+	i = VME_DEVS;
+err_sysfs:
+	while (i > 0) {
+		i--;
+		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
+	}
+	class_destroy(vme_user_sysfs_class);
+
+	/* Ensure counter set correcty to unalloc all master windows */
+	i = MASTER_MAX + 1;
+err_master_buf:
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++)
+		kfree(image[i].kern_buf);
+err_master:
+	while (i > MASTER_MINOR) {
+		i--;
+		vme_master_free(image[i].resource);
+	}
+
+	/*
+	 * Ensure counter set correcty to unalloc all slave windows and buffers
+	 */
+	i = SLAVE_MAX + 1;
+err_slave:
+	while (i > SLAVE_MINOR) {
+		i--;
+		buf_unalloc(i);
+		vme_slave_free(image[i].resource);
+	}
+err_class:
+	cdev_del(vme_user_cdev);
+err_char:
+	unregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);
+err_region:
+err_dev:
+	return err;
+}
+
+static int vme_user_remove(struct vme_dev *dev)
+{
+	int i;
+
+	/* Remove sysfs Entries */
+	for (i = 0; i < VME_DEVS; i++) {
+		mutex_destroy(&image[i].mutex);
+		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
+	}
+	class_destroy(vme_user_sysfs_class);
+
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {
+		kfree(image[i].kern_buf);
+		vme_master_free(image[i].resource);
+	}
+
+	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
+		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);
+		buf_unalloc(i);
+		vme_slave_free(image[i].resource);
+	}
+
+	/* Unregister device driver */
+	cdev_del(vme_user_cdev);
+
+	/* Unregiser the major and minor device numbers */
+	unregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);
+
+	/* Release resources bound to /dev/nai_vme_int_[1:7] and ring buffers */
+	for ( i = 0; i < VME_INT_LEVELS; i++ )
+	{
+		delete_nai_vme_int_dev_file(&((struct int_sysfs_entry*)(dev->int_sysfs_entry[i]))->dev_file_mgr_info_ptr,true);
+		/* resouces in dev->int_sysfs_entry[i] should be freed automatically, since
+		* devm_kzalloc(&vdev->dev,sizeof(*entry), GFP_KERNEL) is used to allocate them.
+		*/
+
+		/* for insmod/rmmod nai_vme_user.ko, tested 09/28/2017 */
+		vme_irq_free(dev,i+1);
+	}
+
+	return 0;
+}
+
+static void __exit vme_user_exit(void)
+{
+	vme_unregister_driver(&vme_user_driver);
+}
+
+
+MODULE_PARM_DESC(bus, "Enumeration of VMEbus to which the driver is connected");
+module_param_array(bus, int, &bus_num, 1);
+
+MODULE_PARM_DESC(bus_num, "VMEBus Number");
+module_param(bus_num, int, 1);
+
+MODULE_DESCRIPTION("VME User Space Access Driver");
+MODULE_AUTHOR("NAII");
+MODULE_LICENSE("GPL");
+
+module_init(vme_user_init);
+module_exit(vme_user_exit);
diff --git a/drivers/vme/devices/nai_vme_usr.h b/drivers/vme/devices/nai_vme_usr.h
new file mode 100644
index 0000000..3299501
--- /dev/null
+++ b/drivers/vme/devices/nai_vme_usr.h
@@ -0,0 +1,60 @@
+#ifndef _VME_USR_H_
+#define _VME_USR_H_
+
+#define VME_USER_BUS_MAX	1
+
+/*
+ * VMEbus Master Window Configuration Structure
+ */
+struct vme_master {
+	__u32 enable;		/* State of Window */
+	__u64 vme_addr;		/* Starting Address on the VMEbus */
+	__u64 size;			/* Window Size */
+	__u32 aspace;		/* Address Space */
+	__u32 cycle;		/* Cycle properties */
+	__u32 dwidth;		/* Maximum Data Width */
+#if 0
+	char prefetchenable;	/* Prefetch Read Enable State */
+	int prefetchsize;		/* Prefetch Read Size (Cache Lines) */
+	char wrpostenable;		/* Write Post State */
+#endif
+};
+
+
+/*
+ * IOCTL Commands and structures
+ */
+
+/* Magic number for use in ioctls */
+#define VME_IOC_MAGIC 0xAE
+
+
+/* VMEbus Slave Window Configuration Structure */
+struct vme_slave {
+	__u32 enable;		/* State of Window */
+	__u64 vme_addr;		/* Starting Address on the VMEbus */
+	__u64 size;		/* Window Size */
+	__u32 aspace;		/* Address Space */
+	__u32 cycle;		/* Cycle properties */
+#if 0
+	char wrpostenable;		/* Write Post State */
+	char rmwlock;			/* Lock PCI during RMW Cycles */
+	char data64bitcapable;		/* non-VMEbus capable of 64-bit Data */
+#endif
+};
+
+struct vme_irq_id {
+	__u8 level;
+	__u8 statid;
+};
+
+#define VME_GET_SLAVE _IOR(VME_IOC_MAGIC, 1, struct vme_slave)
+#define VME_SET_SLAVE _IOW(VME_IOC_MAGIC, 2, struct vme_slave)
+#define VME_GET_MASTER _IOR(VME_IOC_MAGIC, 3, struct vme_master)
+#define VME_SET_MASTER _IOW(VME_IOC_MAGIC, 4, struct vme_master)
+#define VME_RESET_MASTER_WINDOW _IOW(VME_IOC_MAGIC, 5, struct vme_master)
+
+#define VME_IRQ_GEN _IOW(VME_IOC_MAGIC, 5, struct vme_irq_id)
+
+#endif /* _VME_USR_H_ */
+
diff --git a/drivers/vme/devices/ring_buffer.c b/drivers/vme/devices/ring_buffer.c
new file mode 100644
index 0000000..725d84f
--- /dev/null
+++ b/drivers/vme/devices/ring_buffer.c
@@ -0,0 +1,828 @@
+//#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#define pr_fmt(fmt) "%s:%d>" fmt,strrchr(__FILE__,'/'),__LINE__
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/pagemap.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/syscalls.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/vme.h>
+
+#include "ring_buffer.h" 
+
+//#define    DEBUG_IT
+
+enum POINTER_TYPE
+{
+   WRITE_PTR,
+   READ_PTR
+};
+
+#ifdef DEBUG_IT
+static void printk_hex_info(const char* func_name,int line_nu,const u8* hex_info,unsigned int info_size);
+static void check_ring_buffer(const char* calling_func,unsigned int calling_line,struct ring_buf_mgr* ring_buf_mgr_ptr);
+#endif
+
+static int ring_buf_data_size(struct ring_buf_mgr* ring_buf_mgr_ptr);
+static int ring_buf_free_space(struct ring_buf_mgr* ring_buf_mgr_ptr);
+static int ring_buf_get_linux_read_available_size(struct ring_buf_mgr* ring_buf_mgr_ptr);
+static int ring_buf_get_linux_write_available_size(struct ring_buf_mgr* ring_buf_mgr_ptr);
+static void ring_buf_modulus_ptr(struct ring_buf_mgr* ring_buf_mgr_ptr,size_t delta,char** access_ptr);
+static void ring_buf_increase_ptr(struct ring_buf_mgr* ring_buf_mgr_ptr,size_t delta,enum POINTER_TYPE pointer_type);
+#ifdef DEV_FILE_WR_OP
+static int ring_buf_wrap_copy_from_user(struct ring_buf_mgr* ring_buf_mgr_ptr,const char __user *buf,size_t count);
+#else /* !DEV_FILE_WR_OP */
+static int ring_buf_wrap_kernel_copy(struct ring_buf_mgr* ring_buf_mgr_ptr,const char *buf,size_t count);
+#endif /* DEV_FILE_WR_OP */
+#define CHECK_BUFFER(RING_BUF_PTR) /*check_ring_buffer(__func__,__LINE__,RING_BUF_PTR)*/
+
+/**************************************************************************************************************************
+           ********* public functins implemetations *********
+**************************************************************************************************************************/
+#ifdef DEV_FILE_WR_OP
+int naii_ring_buffer_init(struct ring_buf_mgr **ring_buf_mgr_ptr,short ring_buf_sz,int rd_time_out,int wr_time_out)
+#else /*!DEV_FILE_WR_OP*/
+int naii_ring_buffer_init(struct ring_buf_mgr **ring_buf_mgr_ptr,short ring_buf_sz,int rd_time_out,int wr_time_out,bool non_block_wr)
+#endif /*DEV_FILE_WR_OP*/
+{
+  int status=0;
+
+  *ring_buf_mgr_ptr=kmalloc(sizeof(struct ring_buf_mgr),GFP_KERNEL);
+  if(*ring_buf_mgr_ptr==NULL)
+  {
+     pr_err("kmalloc(izeof(struct ring_buf_mgr)GFP_KERNEL) err!!!\n");
+     status= -ENOMEM;
+     goto func_exit;
+  }
+
+  memset(*ring_buf_mgr_ptr,0,sizeof(struct ring_buf_mgr));
+
+#ifdef DEBUG_IT
+  pr_info("*ring_buf_mgr_ptr:0x%p\n",*ring_buf_mgr_ptr);
+#endif
+
+  init_waitqueue_head(&(*ring_buf_mgr_ptr)->rd_wait_q);
+  init_waitqueue_head(&(*ring_buf_mgr_ptr)->wr_wait_q);
+
+  sema_init(&(*ring_buf_mgr_ptr)->sem,1);
+
+  (*ring_buf_mgr_ptr)->ring_buf_sz=ring_buf_sz;
+
+  (*ring_buf_mgr_ptr)->read_time_out_msecs = rd_time_out;
+  (*ring_buf_mgr_ptr)->write_time_out_msecs = wr_time_out;
+
+  (*ring_buf_mgr_ptr)->ring_buf=kmalloc((*ring_buf_mgr_ptr)->ring_buf_sz,GFP_KERNEL);
+  if((*ring_buf_mgr_ptr)->ring_buf==NULL)
+  {
+     kfree(*ring_buf_mgr_ptr);
+     pr_err("kmalloc((*ring_buf_mgr_ptr)->ring_buf_sz,GFP_KERNEL) err!!!\n");
+     status= -ENOMEM;
+     goto func_exit;
+  }
+
+#ifdef DEBUG_IT
+  pr_info("(*ring_buf_mgr_ptr)->ring_buf:0x%p\n",(*ring_buf_mgr_ptr)->ring_buf);
+#endif
+
+  memset((*ring_buf_mgr_ptr)->ring_buf,0,(*ring_buf_mgr_ptr)->ring_buf_sz);
+  (*ring_buf_mgr_ptr)->wrap_flag&=~SET_WRAP_FLAG;
+  (*ring_buf_mgr_ptr)->rd_ptr=(*ring_buf_mgr_ptr)->wr_ptr=(*ring_buf_mgr_ptr)->ring_buf; // rd and wr from the beginning
+
+#ifndef DEV_FILE_WR_OP
+  /* to keep logic simple and to avoid creating large work queue when user space read op is suspended, set write op to non-block mode */
+  //dev_file_mgr_info_ptr->int_mgr_ring_buf.wr_nonblock=NON_BLOCK_WR_MODE;
+  (*ring_buf_mgr_ptr)->rd_nonblock=non_block_wr;
+#endif /* DEV_FILE_WR_OP */
+
+func_exit:
+  return status;
+}
+EXPORT_SYMBOL(naii_ring_buffer_init);
+
+int naii_ring_buffer_release(struct ring_buf_mgr** ring_buf_mgr_ptr)
+{
+   int status=0;
+#ifdef DEBUG_IT
+   pr_info("passed test kfree, (*ring_buf_mgr_ptr)->ring_buf:%p\n",(*ring_buf_mgr_ptr)->ring_buf);
+#endif
+   kfree((*ring_buf_mgr_ptr)->ring_buf);
+#ifdef DEBUG_IT
+   pr_info("passed test kfree, (*ring_buf_mgr_ptr)->ring_buf:%p OK\n",(*ring_buf_mgr_ptr)->ring_buf);
+#endif
+
+#ifdef DEBUG_IT
+   pr_info("passed test kfree, *ring_buf_mgr_ptr:%p\n",*ring_buf_mgr_ptr);
+#endif
+   kfree(*ring_buf_mgr_ptr);
+#ifdef DEBUG_IT
+   pr_info("passed test kfree, *ring_buf_mgr_ptr:%p OK\n",*ring_buf_mgr_ptr);
+#endif
+   return status;
+}
+EXPORT_SYMBOL(naii_ring_buffer_release);
+
+int naii_ring_buffer_read(struct ring_buf_mgr* ring_buf_mgr_ptr,char __user *usr_buf, size_t count)
+{
+   int result;
+   if(count==0)
+      return 0;
+//pr_info("count=%d\n",count);
+   if(down_interruptible(&ring_buf_mgr_ptr->sem))
+      return -ERESTARTSYS;
+
+   result=ring_buf_get_linux_read_available_size(ring_buf_mgr_ptr);
+   if(result<0)
+   {
+      return result;
+   }
+   CHECK_BUFFER(ring_buf_mgr_ptr);
+
+   if(count>result) //read all data in current buffer
+   {
+      count=result; 
+   }
+
+   if(ring_buf_mgr_ptr->wr_ptr>ring_buf_mgr_ptr->rd_ptr)
+   {
+#if 0
+              --------------- <-ring_buf
+              .             .
+              .             .
+              .             .
+            - --------------- <-rd_ptr
+            ^ ./////////////.
+            | ./////////////.
+        count ./////////////.
+            | ./////////////.
+            v ./////////////.
+            - ---------------
+              ./////////////.
+              ./////////////.
+              --------------- <-wr_ptr
+              .             .
+              .             .
+              .             .
+              --------------- <-ring_buf+ring_buf_sz
+pattern "/" is existing data in the buffer
+#endif//#if 0
+
+      if(copy_to_user(usr_buf,ring_buf_mgr_ptr->rd_ptr,count)!=0)
+      {
+         up(&ring_buf_mgr_ptr->sem);
+         return -EFAULT;
+      }
+
+#ifdef DEBUG_IT
+printk_hex_info(__func__,__LINE__,ring_buf_mgr_ptr->rd_ptr,count);
+#endif
+   CHECK_BUFFER(ring_buf_mgr);
+      ring_buf_increase_ptr(ring_buf_mgr_ptr,count,READ_PTR);
+   CHECK_BUFFER(ring_buf_mgr);
+   }
+   else//(ring_buf_mgr_ptr->wr_ptr<=ring_buf_mgr_ptr->rd_ptr),wr_ptr wrapped and rd_ptr not wrapped
+   {
+      if((size_t)(ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz-ring_buf_mgr_ptr->rd_ptr)>=count)
+      {
+#ifdef DEBUG_IT
+         pr_info("rd_ptr idx=%lu,count=%lu\n",(size_t)(ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz-ring_buf_mgr_ptr->rd_ptr),count);
+#endif
+#if 0
+              --------------- <-ring_buf
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              --------------- <-wr_ptr
+              .             .
+              .             .
+            - --------------- <-rd_ptr
+            ^ ./////////////.
+            | ./////////////.
+        count ./////////////.
+            | ./////////////.
+            v ./////////////.
+            - ---------------
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              --------------- <-ring_buf+buffer_size
+pattern "/" is existing data in the buffer
+#endif//#if 0
+
+         if(copy_to_user(usr_buf,ring_buf_mgr_ptr->rd_ptr,count)!=0)
+         {
+            up(&ring_buf_mgr_ptr->sem);
+            return -EFAULT;
+         }
+
+         ring_buf_increase_ptr(ring_buf_mgr_ptr,count,READ_PTR);
+      }
+      else
+      {
+         size_t part_1=ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz-ring_buf_mgr_ptr->rd_ptr;
+#ifdef DEBUG_IT
+         pr_info("(capacity-rd_ptr)=%lu,count=%lu\n",(size_t)(ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz-ring_buf_mgr_ptr->rd_ptr),count);
+#endif
+#if 0
+              --------------- <-ring_buf
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              --------------- <-wr_ptr
+              .             .
+              .             .
+            - --------------- <-rd_ptr
+            ^ ./////////////.
+            | ./////////////.
+       part_1 ./////////////.
+            | ./////////////.
+            v ./////////////.
+            - --------------- <-ring_buf+ring_buf_sz
+pattern "/" is existing data in the ring_buf
+#endif//#if 0
+
+            if(copy_to_user(usr_buf,ring_buf_mgr_ptr->rd_ptr,part_1)!=0)
+            {
+               up(&ring_buf_mgr_ptr->sem);
+               return -EFAULT;
+            }
+            ring_buf_increase_ptr(ring_buf_mgr_ptr,part_1,READ_PTR);
+#if 0
+            - --------------- <-ring_buf
+            ^ ./////////////.
+            | ./////////////.
+            | ./////////////.
+ count-part_1 ./////////////.
+            | ./////////////.
+            v ./////////////.
+            - .-------------.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              --------------- <-wr_ptr
+              .             .
+              .             .
+            - --------------- <-rd_ptr
+            ^ ./////////////.
+            | ./////////////.
+       part_1 ./////////////.
+            | ./////////////.
+            v ./////////////.
+            - --------------- <-ring_buf+ring_buf_sz
+pattern "/" is existing data in the ring_buf
+#endif//#if 0
+
+            if(copy_to_user(usr_buf+part_1,ring_buf_mgr_ptr->ring_buf,count-part_1)!=0)
+            {
+               up(&ring_buf_mgr_ptr->sem);
+               return -EFAULT;
+            }
+            ring_buf_increase_ptr(ring_buf_mgr_ptr,count-part_1,READ_PTR);
+      }
+   }
+
+   up(&ring_buf_mgr_ptr->sem);
+
+   // finally, awake any writers and return
+   wake_up_interruptible(&ring_buf_mgr_ptr->wr_wait_q);
+
+#ifdef DEBUG_IT
+   pr_info("\"%s\" did read %li bytes\n",current->comm,(long)count);
+#endif
+/////////////////////////////////////////////////////////////////////////////////////////
+
+   return count;
+}
+EXPORT_SYMBOL(naii_ring_buffer_read);
+
+#ifdef DEV_FILE_WR_OP
+int naii_ring_buffer_write(struct ring_buf_mgr* ring_buf_mgr_ptr,const char __user *usr_buf,size_t count)
+{
+#else /*!DEV_FILE_WR_OP*/
+int naii_ring_buffer_write(struct ring_buf_mgr* ring_buf_mgr_ptr,const char *in_buf,size_t count)
+{
+#ifdef DEBUG_IT
+   pr_info("count:%d,ring_buf_mgr_ptr:0x%p\n",count,ring_buf_mgr_ptr);
+#endif /* DEBUG_IT */
+#endif /* DEV_FILE_WR_OP */
+   int result;
+
+   if(count==0)
+   {
+      return 0;
+   }
+
+   if(down_interruptible(&ring_buf_mgr_ptr->sem))
+   {
+      pr_err("down_interruptible(&ring_buf_mgr_ptr->sem) err!!!\n");
+      return -ERESTARTSYS;
+   }
+
+   result=ring_buf_get_linux_write_available_size(ring_buf_mgr_ptr);
+
+   if(result<0)
+   {
+      //if result less than 0, the sem was released by ring_buf_get_linux_write_available_size(struct ring_buf_mgr*)
+      pr_err("no wrte_space,result:%d\n",result);
+      return result; 
+   }
+
+#ifdef DEBUG_IT
+   pr_info("count=%lu,freespace=%d,rd_ptr=%u,wr_ptr=%u\n",count,result,ring_buf_mgr_ptr->rd_ptr-ring_buf_mgr_ptr->ring_buf,ring_buf_mgr_ptr->wr_ptr-ring_buf_mgr_ptr->ring_buf);
+#endif
+   if(count>result)
+   {
+      up(&ring_buf_mgr_ptr->sem);
+//#ifdef DEBUG_IT
+      pr_err("\"%s\" DID NOT WRITE %li BYTES DUE TO NO ENOUGH SPACE\n",current->comm,(long)count);
+//#endif
+      return -EAGAIN; //PAY MORE ATTENTION IN HERE
+   }
+
+   if(ring_buf_mgr_ptr->wr_ptr>=ring_buf_mgr_ptr->rd_ptr)
+   {
+      if(ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz-ring_buf_mgr_ptr->wr_ptr>count)
+      {
+#if 0
+              --------------- <-ring_buf
+              .             .
+              .             .
+              .             .
+            - .-------------. <-wr_ptr=wr_ptr
+            ^ .             .
+            | .             .
+        count .             .
+            | .             .
+            v .             .
+            - .             .
+              .             .
+              --------------- <-ring_buf+ring_buf_sz
+the current buffer is empty
+
+or
+              --------------- <-ring_buf
+              .             .
+              .             .
+              .             .
+              --------------- <-rd_ptr
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+            - --------------- <-wr_ptr
+            ^ .+++++++++++++.
+            | .+++++++++++++.
+        count .+++++++++++++.
+            | .+++++++++++++.
+            v .+++++++++++++.
+            - .+++++++++++++.
+              .             .
+              .             .
+              .             .
+              --------------- <-ring_buf+ring_buf_sz
+
+the current buffer is not empty
+pattern "/" is existing data in the buffer
+pattern "+" is new inserted data in the buffer
+#endif//#if 0
+
+         CHECK_BUFFER(ring_buf_mgr_ptr);
+#ifdef DEV_FILE_WR_OP
+         if(copy_from_user(ring_buf_mgr_ptr->wr_ptr,usr_buf,count)!=0)
+#else /* !DEV_FILE_WR_OP */
+         if(memcpy(ring_buf_mgr_ptr->wr_ptr,in_buf,count)!=ring_buf_mgr_ptr->wr_ptr)
+#endif /* DEV_FILE_WR_OP */
+         {
+            pr_err("ring_buf_mgr_ptr->wr_ptr:0x%p,ring_buf_mgr_ptr->ring_buf:0x%p\n",ring_buf_mgr_ptr->wr_ptr,ring_buf_mgr_ptr->ring_buf);
+#ifdef DEV_FILE_WR_OP
+            pr_err("(copy_from_user(ring_buf_mgr_ptr->wr_ptr,usr_buf,count) err!!!\n");
+#else /* !DEV_FILE_WR_OP */
+            pr_err("(memcpy(ring_buf_mgr_ptr->wr_ptr,in_buf,count) err!!!\n");
+#endif /* DEV_FILE_WR_OP */
+            up(&ring_buf_mgr_ptr->sem);
+            return -EFAULT;
+         }
+         ring_buf_increase_ptr(ring_buf_mgr_ptr,count,WRITE_PTR);
+         CHECK_BUFFER(ring_buf_mgr_ptr);
+      }
+      else
+      {
+#if 0
+            - --------------- <-ring_buf
+            ^ .             .
+            | .             .
+      count_2 .             .
+            | .             .
+            v .             .
+            - .-------------. <-wr_ptr=wr_ptr
+            ^ .             .
+            | .             .
+      count_1 .             .
+            | .             .
+            v .             .
+            - --------------- <-ring_buf+ring_buf_sz
+the current buffer is empty, and write_count is equal to or less than the buffer capacity
+count=count_1+count2
+
+or
+            - --------------- <-ring_buf
+            ^ .+++++++++++++.
+            | .+++++++++++++.
+      count_2 .+++++++++++++.
+            | .+++++++++++++.
+            v .+++++++++++++.
+            - ---------------
+              .             .
+              .             .
+              .             .
+              --------------- <-rd_ptr
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+            - --------------- <-wr_ptr
+            ^ .+++++++++++++.
+            | .+++++++++++++.
+      count_1 .+++++++++++++.
+            | .+++++++++++++.
+            v .+++++++++++++.
+            - --------------- <-ring_buf+ring_buf_sz
+the current buffer is not empty
+count=count_1+count2
+pattern "/" is existing data in the buffer
+pattern "+" is new inserted data in the buffer
+#endif//#if 0
+
+#ifdef DEV_FILE_WR_OP
+         int sub_result=ring_buf_wrap_copy_from_user(ring_buf_mgr_ptr,usr_buf,count);
+#else /* !DEV_FILE_WR_OP */
+         int sub_result=ring_buf_wrap_kernel_copy(ring_buf_mgr_ptr,in_buf,count);
+#endif /* DEV_FILE_WR_OP */
+         if(sub_result!=0)
+         {
+           /*ring_buf_wrap_copy_from_user/ring_buf_wrap_kernel_copy(ring_buf_mgr_ptr,in_buf,count) already released semaphore if any error happened*/
+#ifdef DEV_FILE_WR_OP
+           pr_err("ring_buf_wrap_copy_from_user(ring_buf_mgr_ptr,usnr_buf,count) err.\n");
+#else /* !DEV_FILE_WR_OP */
+           pr_err("ring_buf_wrap_kernel_copy(ring_buf_mgr_ptr,in_buf,count) err.\n");
+#endif /* DEV_FILE_WR_OP */
+           return sub_result;
+         }
+      }
+   }
+   else
+   {
+#if 0
+              --------------- <-ring_buf
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+            - --------------- <-wr_ptr
+            ^ .+++++++++++++.
+            | .+++++++++++++.
+        count .+++++++++++++.
+            | .+++++++++++++.
+            v .+++++++++++++.
+            - .+++++++++++++. 
+              .             .
+              .             .
+              .             .
+              --------------- <-rd_ptr
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              ./////////////.
+              --------------- <-ring_buf+ring_buf_sz
+
+pattern "/" is existing data in the buffer
+pattern "+" is new inserted data in the buffer
+#endif//#if 0
+
+      CHECK_BUFFER(ring_buf_mgr_ptr);
+#ifdef DEV_FILE_WR_OP
+      if(copy_from_user(ring_buf_mgr_ptr->wr_ptr,usr_buf,count)!=0)
+#else /* !DEV_FILE_WR_OP */
+      if(memcpy(ring_buf_mgr_ptr->wr_ptr,in_buf,count)!=ring_buf_mgr_ptr->wr_ptr)
+#endif /* DEV_FILE_WR_OP */
+      {
+         up(&ring_buf_mgr_ptr->sem);
+#ifdef DEV_FILE_WR_OP
+         pr_err("copy_from_user err.\n");
+#else /* !DEV_FILE_WR_OP */
+         pr_err("memcpy err.\n");
+#endif /* DEV_FILE_WR_OP */
+         return -EFAULT;
+      }
+      ring_buf_increase_ptr(ring_buf_mgr_ptr,count,WRITE_PTR);
+   }
+
+   CHECK_BUFFER(ring_buf_mgr_ptr);
+   up(&ring_buf_mgr_ptr->sem);
+
+   // finally, awake any reader
+   wake_up_interruptible(&ring_buf_mgr_ptr->rd_wait_q);  // blocked in read() and select()
+
+#ifdef DEV_FILE_WR_OP
+   // TBD and signal asynchronous readers, explained in chapter 5
+   if(ring_buf_mgr_ptr->async_queue)
+   {
+      kill_fasync(&ring_buf_mgr_ptr->async_queue,SIGIO,POLL_IN);
+   }
+#endif /* DEV_FILE_WR_OP */
+
+#ifdef DEBUG_IT
+   pr_info("\"%s\" did write %li bytes.\n",current->comm,(long)count);
+#endif
+
+   return result;
+}
+EXPORT_SYMBOL(naii_ring_buffer_write);
+
+/**************************************************************************************************************************
+ *                         static/private functions
+ ***************************************************************************************************************************/
+#ifdef DEBUG_IT
+static void printk_hex_info(const char* func_name,int line_nu,const u8* hex_info,unsigned int info_size)
+{
+   #define COLUMN_NUM 16
+   #define DELIMITER ','
+   #define ELEMENT_SIZE 3  /*including 2 bytes hex num and 1 byte field delimiter ',' or '\n'*/
+   char work_buf[ELEMENT_SIZE*COLUMN_NUM+sizeof(int)/*sizeof(int) is used for last str delimiter '\0' and mem alignment*/];
+   unsigned int i;
+
+   memset(work_buf,0,sizeof(work_buf));
+   for(i=0;i<info_size;i++)
+   {
+      sprintf(work_buf+(i*ELEMENT_SIZE)%(COLUMN_NUM*ELEMENT_SIZE),"%02x%c",hex_info[i],(i==(info_size-1)||(i+1)%COLUMN_NUM==0)?'\n':DELIMITER);
+      if(i==(info_size-1)||(i+1)%COLUMN_NUM==0)
+      {
+         printk(KERN_INFO"%s",work_buf);
+         memset(work_buf,0,sizeof(work_buf));
+      }
+   }
+}
+
+static void check_ring_buffer(const char* calling_func,unsigned int calling_line,struct ring_buf_mgr* ring_buf_mgr_ptr)
+{
+   printk(KERN_INFO"\n%s:%u:",calling_func,calling_line);
+   printk(KERN_INFO"free_space=%u,data_size=%u,",ring_buf_free_space(ring_buf_mgr_ptr),ring_buf_data_size(ring_buf_mgr_ptr));
+   printk(KERN_INFO"rd_ptr_idx=%u,wr_ptr_idx=%u\n",ring_buf_mgr_ptr->rd_ptr-ring_buf_mgr_ptr->ring_buf,ring_buf_mgr_ptr->wr_ptr-ring_buf_mgr_ptr->    ring_buf);
+   printk_hex_info(NULL,calling_line,ring_buf_mgr_ptr->ring_buf,ring_buf_mgr_ptr->ring_buf_sz);
+}
+#endif
+
+static void ring_buf_modulus_ptr(struct ring_buf_mgr* ring_buf_mgr_ptr,size_t delta,char** access_ptr)
+{
+   delta+=(*access_ptr-ring_buf_mgr_ptr->ring_buf);
+   *access_ptr=ring_buf_mgr_ptr->ring_buf+delta%ring_buf_mgr_ptr->ring_buf_sz;
+#ifdef DEBUG_IT
+   pr_info("access_inx=%lu,delta=%lu\n",*access_ptr-ring_buf_mgr_ptr->ring_buf,delta);
+#endif
+}
+
+//the caller must make sure the buffer is not overflow after the write/read pointer is modified
+//by checking the writen size is less than free size and read size is less than data size in the buffer
+static void ring_buf_increase_ptr(struct ring_buf_mgr* ring_buf_mgr_ptr,size_t delta,enum POINTER_TYPE pointer_type)
+{
+   if(pointer_type==WRITE_PTR)
+   {
+      if(ring_buf_mgr_ptr->wr_ptr+delta>=ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz)
+      {
+         ring_buf_mgr_ptr->wrap_flag|=SET_WRAP_FLAG;
+      }
+      ring_buf_modulus_ptr(ring_buf_mgr_ptr,delta,&ring_buf_mgr_ptr->wr_ptr);
+#ifdef DEBUG_IT
+      pr_info("wr_ptr_idx=%lu,delta=%lu\n",ring_buf_mgr_ptr->wr_ptr-ring_buf_mgr_ptr->ring_buf,delta);
+#endif
+   }
+   else
+   {
+      if(ring_buf_mgr_ptr->rd_ptr+delta>=ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz)
+      {
+         ring_buf_mgr_ptr->wrap_flag&=~SET_WRAP_FLAG;
+      }
+      ring_buf_modulus_ptr(ring_buf_mgr_ptr,delta,&ring_buf_mgr_ptr->rd_ptr);
+#ifdef DEBUG_IT
+      pr_info("rd_ptr_idx=%lu,delta=%lu\n",ring_buf_mgr_ptr->rd_ptr-ring_buf_mgr_ptr->ring_buf,delta);
+#endif
+   }
+}
+
+static int ring_buf_free_space(struct ring_buf_mgr* ring_buf_mgr_ptr)
+{
+   int result=0;
+   if(ring_buf_mgr_ptr->rd_ptr==ring_buf_mgr_ptr->wr_ptr)//if the buffer is full ring_buf_mgr_ptr->rd_ptr is also equal to ring_buf_mgr_ptr->wr_ptr
+   {
+      if(ring_buf_mgr_ptr->wrap_flag==SET_WRAP_FLAG)
+      {
+         result=0;
+      }
+      else
+      {
+         result=ring_buf_mgr_ptr->ring_buf_sz;
+      }
+   }
+   else
+   {
+      /// modulus % is an effective way to calculate buffer size
+      /// an easy way to think this algorithm: 
+      /// if wr_ptr>rd_ptr: ring_buf_mgr_ptr->buffer_size-ring_buf_mgr_ptr->wr_ptr+ring_buf_mgr_ptr->rd_ptr
+      /// if rd_ptr>wr_ptr: ring_buf_mgr_ptr->rd_ptr-ring_buf_mgr_ptr->wr_ptr+ring_buf_mgr_ptr->buffer_size
+      /// TBD drawing a picture
+      result=(ring_buf_mgr_ptr->rd_ptr+ring_buf_mgr_ptr->ring_buf_sz-ring_buf_mgr_ptr->wr_ptr)%ring_buf_mgr_ptr->ring_buf_sz;
+   }
+
+   return result; 
+}
+
+static int ring_buf_data_size(struct ring_buf_mgr* ring_buf_mgr_ptr)
+{
+   return ring_buf_mgr_ptr->ring_buf_sz-ring_buf_free_space(ring_buf_mgr_ptr);
+}
+
+#ifdef DEV_FILE_WR_OP
+int ring_buf_wrap_copy_from_user(struct ring_buf_mgr* ring_buf_mgr_ptr,const char __user *buf,size_t count)
+#else /* DEV_FILE_WR_OP */
+int ring_buf_wrap_kernel_copy(struct ring_buf_mgr* ring_buf_mgr_ptr,const char *buf,size_t count)
+#endif /* DEV_FILE_WR_OP */
+{
+   size_t count_1=ring_buf_mgr_ptr->ring_buf+ring_buf_mgr_ptr->ring_buf_sz-ring_buf_mgr_ptr->wr_ptr;
+
+#ifdef DEV_FILE_WR_OP
+   if(copy_from_user(ring_buf_mgr_ptr->wr_ptr,buf,count_1)!=0)
+#else /* DEV_FILE_WR_OP */
+   if(memcpy(ring_buf_mgr_ptr->wr_ptr,buf,count_1)!=ring_buf_mgr_ptr->wr_ptr)
+#endif /* DEV_FILE_WR_OP */
+   {
+      up(&ring_buf_mgr_ptr->sem);
+      return -EFAULT;
+   }
+
+   ring_buf_increase_ptr(ring_buf_mgr_ptr,count_1,WRITE_PTR);
+
+#ifdef DEV_FILE_WR_OP
+   if(copy_from_user(ring_buf_mgr_ptr->wr_ptr,buf+count_1,count-count_1)!=0)
+#else /* DEV_FILE_WR_OP */
+   if(memcpy(ring_buf_mgr_ptr->wr_ptr,buf+count_1,count-count_1)!=ring_buf_mgr_ptr->wr_ptr)
+#endif /* DEV_FILE_WR_OP */
+   {
+      up(&ring_buf_mgr_ptr->sem);
+      return -EFAULT;
+   }
+   ring_buf_increase_ptr(ring_buf_mgr_ptr,count-count_1,WRITE_PTR);
+   return 0;
+}
+
+// wait for space for writing; caller must hold device semaphore.
+// on error the semaphore will be released before returning.
+static int ring_buf_get_linux_read_available_size(struct ring_buf_mgr* ring_buf_mgr_ptr)
+{
+   int result=0;
+   while((result=ring_buf_data_size(ring_buf_mgr_ptr))==0)
+   { // nothing to read
+      int wait_result;
+      up(&ring_buf_mgr_ptr->sem); // release the lock
+      //if(filp->f_flags&O_NONBLOCK)
+      if(ring_buf_mgr_ptr->rd_nonblock==true)
+      {
+         return -EAGAIN;
+      }
+
+#ifdef DEBUG_IT
+      pr_info("\"%s\" reading: going to wait queue\n", current->comm);
+#endif
+
+      if(ring_buf_mgr_ptr->read_time_out_msecs==WAIT_FOREVER)
+      {
+         if(wait_event_interruptible(ring_buf_mgr_ptr->rd_wait_q,ring_buf_data_size(ring_buf_mgr_ptr)>0))
+         {
+            return -ERESTARTSYS; // signal: tell the fs layer to handle it
+         }
+      }
+      else
+      {
+         wait_result=wait_event_interruptible_timeout(ring_buf_mgr_ptr->rd_wait_q,ring_buf_data_size(ring_buf_mgr_ptr)>0,msecs_to_jiffies(ring_buf_mgr_ptr->read_time_out_msecs));
+         if(wait_result==0)
+         {
+            return -EIO;
+         }
+         else if(wait_result==-ERESTARTSYS)
+         {
+            return -ERESTARTSYS; // signal: tell the fs layer to handle it
+         }
+      }
+
+      // otherwise loop, but first reacquire the lock which released on line 340
+      if(down_interruptible(&ring_buf_mgr_ptr->sem))
+      {
+         return -ERESTARTSYS;
+      }
+   }
+   return result;
+}
+
+// wait for space for writing; caller must hold device semaphore.
+// on error the semaphore will be released before returning.
+static int ring_buf_get_linux_write_available_size(struct ring_buf_mgr* ring_buf_mgr_ptr)
+{
+   int result;
+
+#ifdef DEBUG_IT
+   pr_info("dev_file_mgr_info_ptr:0x%p\n",dev_file_mgr_info_ptr);
+#endif
+   /* the semaphore is held when ing_buf_free_space(dev_file_mgr_info_ptr) is called */
+   while((result=ring_buf_free_space(ring_buf_mgr_ptr))==0)
+   {
+      DEFINE_WAIT(wait); 
+      up(&ring_buf_mgr_ptr->sem);
+
+      if(ring_buf_mgr_ptr->wr_nonblock==true)
+      {
+#ifdef DEBUG_IT
+         pr_info("no blk wr\n");
+#endif
+         return -EAGAIN;
+      }
+#ifdef DEBUG_IT
+      pr_info("blk wr\n");
+#endif
+     /*
+      *one reason is the write task dominate CPU resource and the read task does not have chance to kick in.
+      *if schedule() is called, the write task can yield the CPU resource and the read task can kick in.
+      *if schedule() is not used, the user program should call usleep(useconds_t usec)
+      *after write(int fd, const void *buf, size_t count) returns -1 with errno=EAGAIN, then calls
+      *write(int fd, const void *buf, size_t count) again. 01/09/2015
+      */
+
+#ifdef DEBUG_IT
+      pr_info("\"%s\" writing: going to wait queue,result=%d\n",current->comm,result);
+#endif
+      prepare_to_wait(&ring_buf_mgr_ptr->wr_wait_q,&wait,TASK_INTERRUPTIBLE);
+
+      if((result=ring_buf_free_space(ring_buf_mgr_ptr))==0)
+      {
+#ifdef DEBUG_IT
+         pr_info("\"%s\" writing: sleeping at here\n",current->comm);
+#endif
+
+#ifdef DEV_FILE_WR_OP
+         schedule(); //schedule_timeout(WRITE_WAIT_TIME_OUT_JIFFIES) or udelay(unsigned long); an enhanced solution
+#else /* !DEV_FILE_WR_OP */
+         /*
+          * using schedule() or schedule_timeout(signed long) will change the order of tast in the work queue,
+          * so the sequence of vectors generated from ISR top half will be changed.
+          * using udelay(signed long) instead of schedule_timeout(signed long)
+          */
+         udelay(1);
+#endif /* DEV_FILE_WR_OP */
+
+#ifdef DEBUG_IT
+         pr_info("\"%s\" writing: not sleeping\n",current->comm);
+#endif
+      }
+
+#ifdef DEBUG_IT
+      pr_info("\"%s\" writing: not waking up sleep at here\n",current->comm);
+#endif
+      finish_wait(&ring_buf_mgr_ptr->wr_wait_q,&wait);
+#ifdef DEBUG_IT
+      pr_info("\"%s\" writing: waking up sleep at here\n",current->comm);
+#endif
+      if(signal_pending(current))
+      {
+         pr_err("signal_pending(current) err!!!\n");
+         return -ERESTARTSYS; // signal: tell the fs layer to handle it
+      }
+
+      if(down_interruptible(&ring_buf_mgr_ptr->sem))
+      {
+         pr_err("down_interruptible(&dev_file_mgr_info_ptr->sem) err!!!\n");
+         return -ERESTARTSYS;
+      }
+   }
+
+   return result;
+}
diff --git a/drivers/vme/devices/ring_buffer.h b/drivers/vme/devices/ring_buffer.h
new file mode 100644
index 0000000..802f944
--- /dev/null
+++ b/drivers/vme/devices/ring_buffer.h
@@ -0,0 +1,47 @@
+#ifndef _RING_BUFFER_H_
+#define _RING_BUFFER_H_
+
+//#define DEV_FILE_WR_OP
+
+#define WAIT_FOREVER                               -1
+
+#define DEFAULT_RING_BUFFER_SIZE                   512
+
+struct ring_buf_mgr
+{
+  wait_queue_head_t rd_wait_q,wr_wait_q;  /* write and read queues */
+
+  char *ring_buf;                      /* begin of buf, end of buf */
+  char *rd_ptr,*wr_ptr;                /* where to read, where to write */
+  short ring_buf_sz;                   /* short not unit16_t/u16 type is used due to module_param(g_ring_buffer_size,short,S_IRUGO) */
+#define SET_WRAP_FLAG           1
+#define NON_BLOCK_WR_MODE       1
+#define NON_BLOCK_RD_MODE       1
+#define DEVICE_FILE_OPENED      1
+
+  u64  wrap_flag: 1;                   /* set to 1 when wr_ptr wraps, set to 0 when rd_ptr wraps. */
+  u64  wr_nonblock: 1;                 /* non-blocking write mode. */
+  u64  rd_nonblock: 1;                 /* non-blocking read mode. */
+  struct semaphore sem;                /* mutual exclusion semaphore */
+
+  struct fasync_struct *async_queue;   /* asynchronous readers */
+
+  int read_time_out_msecs;
+  int write_time_out_msecs;
+};
+
+#ifdef DEV_FILE_WR_OP
+int naii_ring_buffer_init(struct ring_buf_mgr** ring_buf_mgr_ptr,short ring_buf_sz,int read_time_out,int write_time_out);
+#else /*!DEV_FILE_WR_OP*/
+int naii_ring_buffer_init(struct ring_buf_mgr** ring_buf_mgr_ptr,short ring_buf_sz,int rd_time_out,int wr_time_out,bool non_block_wr);
+#endif /*DEV_FILE_WR_OP*/
+int naii_ring_buffer_release(struct ring_buf_mgr** ring_buf_mgr_ptr);
+
+int naii_ring_buffer_read(struct ring_buf_mgr* ring_buf_mgr_ptr,char __user *usr_buf, size_t count);
+#ifdef DEV_FILE_WR_OP
+int naii_ring_buffer_write(struct ring_buf_mgr* ring_buf_mgr_ptr,const char __user *usr_buf,size_t count);
+#else /*!DEV_FILE_WR_OP*/
+int naii_ring_buffer_write(struct ring_buf_mgr* ring_buf_mgr_ptr,const char *in_buf,size_t count);
+#endif /*DEV_FILE_WR_OP*/
+
+#endif /*_RING_BUFFER_H_*/
diff --git a/drivers/vme/vme.c b/drivers/vme/vme.c
index 6a3ead4..08a62f6 100644
--- a/drivers/vme/vme.c
+++ b/drivers/vme/vme.c
@@ -503,6 +503,7 @@ struct vme_resource *vme_master_request(struct vme_dev *vdev, u32 address,
 	struct vme_master_resource *allocated_image = NULL;
 	struct vme_master_resource *master_image = NULL;
 	struct vme_resource *resource = NULL;
+	unsigned long flags;
 
 	bridge = vdev->bridge;
 	if (bridge == NULL) {
@@ -521,18 +522,18 @@ struct vme_resource *vme_master_request(struct vme_dev *vdev, u32 address,
 		}
 
 		/* Find an unlocked and compatible image */
-		spin_lock(&master_image->lock);
+		spin_lock_irqsave(&master_image->lock, flags);
 		if (((master_image->address_attr & address) == address) &&
 			((master_image->cycle_attr & cycle) == cycle) &&
 			((master_image->width_attr & dwidth) == dwidth) &&
 			(master_image->locked == 0)) {
 
 			master_image->locked = 1;
-			spin_unlock(&master_image->lock);
+			spin_unlock_irqrestore(&master_image->lock, flags);
 			allocated_image = master_image;
 			break;
 		}
-		spin_unlock(&master_image->lock);
+		spin_unlock_irqrestore(&master_image->lock, flags);
 	}
 
 	/* Check to see if we found a resource */
@@ -553,9 +554,9 @@ struct vme_resource *vme_master_request(struct vme_dev *vdev, u32 address,
 
 err_alloc:
 	/* Unlock image */
-	spin_lock(&master_image->lock);
+	spin_lock_irqsave(&master_image->lock, flags);
 	master_image->locked = 0;
-	spin_unlock(&master_image->lock);
+	spin_unlock_irqrestore(&master_image->lock, flags);
 err_image:
 err_bus:
 	return NULL;
@@ -838,6 +839,7 @@ int vme_master_mmap(struct vme_resource *resource, struct vm_area_struct *vma)
 void vme_master_free(struct vme_resource *resource)
 {
 	struct vme_master_resource *master_image;
+	unsigned long flags;
 
 	if (resource->type != VME_MASTER) {
 		printk(KERN_ERR "Not a master resource\n");
@@ -852,18 +854,41 @@ void vme_master_free(struct vme_resource *resource)
 	}
 
 	/* Unlock image */
-	spin_lock(&master_image->lock);
+	spin_lock_irqsave(&master_image->lock, flags);
 	if (master_image->locked == 0)
 		printk(KERN_ERR "Image is already free\n");
 
 	master_image->locked = 0;
-	spin_unlock(&master_image->lock);
+	spin_unlock_irqrestore(&master_image->lock, flags);
 
 	/* Free up resource memory */
 	kfree(resource);
 }
 EXPORT_SYMBOL(vme_master_free);
 
+int vme_master_reset_window(struct vme_resource *resource)
+{
+	struct vme_bridge *bridge = find_bridge(resource);
+	struct vme_master_resource *image;
+
+	if (resource->type != VME_MASTER) {
+		printk(KERN_ERR "Not a master resource\n");
+		return -EINVAL;
+	}
+
+	image = list_entry(resource->entry, struct vme_master_resource, list);
+
+	if (bridge->master_reset_window == NULL) {
+		printk(KERN_WARNING "vme_master_reset_window not supported\n");
+		return -EINVAL;
+	}
+
+	pr_debug("image->number:%d\n",image->number);
+
+	return bridge->master_reset_window(image);
+}
+EXPORT_SYMBOL(vme_master_reset_window);
+
 /**
  * vme_dma_request - Request a DMA controller.
  * @vdev: Pointer to VME device struct vme_dev assigned to driver instance.
@@ -1340,8 +1365,8 @@ void vme_irq_handler(struct vme_bridge *bridge, int level, int statid)
 	void (*call)(int, int, void *);
 	void *priv_data;
 
-	call = bridge->irq[level - 1].callback[statid].func;
-	priv_data = bridge->irq[level - 1].callback[statid].priv_data;
+	call = bridge->irq[level - 1].callback.func;
+	priv_data = bridge->irq[level - 1].callback.priv_data;
 
 	if (call != NULL)
 		call(level, statid, priv_data);
@@ -1367,7 +1392,7 @@ void vme_irq_handler(struct vme_bridge *bridge, int level, int statid)
  *         function is not supported, -EBUSY if the level/statid combination is
  *         already in use. Hardware specific errors also possible.
  */
-int vme_irq_request(struct vme_dev *vdev, int level, int statid,
+int vme_irq_request(struct vme_dev *vdev, int level,
 	void (*callback)(int, int, void *),
 	void *priv_data)
 {
@@ -1391,15 +1416,15 @@ int vme_irq_request(struct vme_dev *vdev, int level, int statid,
 
 	mutex_lock(&bridge->irq_mtx);
 
-	if (bridge->irq[level - 1].callback[statid].func) {
+	if (bridge->irq[level - 1].callback.func) {
 		mutex_unlock(&bridge->irq_mtx);
 		printk(KERN_WARNING "VME Interrupt already taken\n");
 		return -EBUSY;
 	}
 
 	bridge->irq[level - 1].count++;
-	bridge->irq[level - 1].callback[statid].priv_data = priv_data;
-	bridge->irq[level - 1].callback[statid].func = callback;
+	bridge->irq[level - 1].callback.priv_data = priv_data;
+	bridge->irq[level - 1].callback.func = callback;
 
 	/* Enable IRQ level */
 	bridge->irq_set(bridge, level, 1, 1);
@@ -1418,7 +1443,7 @@ int vme_irq_request(struct vme_dev *vdev, int level, int statid,
  *
  * Remove previously attached callback from VME interrupt priority/vector.
  */
-void vme_irq_free(struct vme_dev *vdev, int level, int statid)
+void vme_irq_free(struct vme_dev *vdev, int level)
 {
 	struct vme_bridge *bridge;
 
@@ -1446,8 +1471,8 @@ void vme_irq_free(struct vme_dev *vdev, int level, int statid)
 	if (bridge->irq[level - 1].count == 0)
 		bridge->irq_set(bridge, level, 0, 1);
 
-	bridge->irq[level - 1].callback[statid].func = NULL;
-	bridge->irq[level - 1].callback[statid].priv_data = NULL;
+	bridge->irq[level - 1].callback.func = NULL;
+	bridge->irq[level - 1].callback.priv_data = NULL;
 
 	mutex_unlock(&bridge->irq_mtx);
 }
@@ -1886,8 +1911,8 @@ static int __vme_register_driver_bus(struct vme_driver *drv,
 	unsigned int i;
 	struct vme_dev *vdev;
 	struct vme_dev *tmp;
-
-	for (i = 0; i < ndevs; i++) {
+	/*Fixed: vdev->num start from 1 only*/
+	for (i = 1; i <= ndevs; i++) {
 		vdev = kzalloc(sizeof(struct vme_dev), GFP_KERNEL);
 		if (!vdev) {
 			err = -ENOMEM;
diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index 42ecf96..a21f393 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -23,6 +23,12 @@ struct vme_master_resource {
 	u32 width_attr;
 	struct resource bus_resource;
 	void __iomem *kern_base;
+	/*selected aspace*/
+	u32 address_sel;
+	/*selected cycle*/
+	u32 cycle_sel;
+	/*selected data width*/
+	u32 width_sel;
 };
 
 struct vme_slave_resource {
@@ -94,7 +100,7 @@ struct vme_callback {
 
 struct vme_irq {
 	int count;
-	struct vme_callback callback[VME_NUM_STATUSID];
+	struct vme_callback callback;
 };
 
 /* Allow 16 characters for name (including null character) */
@@ -146,6 +152,7 @@ struct vme_bridge {
 		loff_t);
 	unsigned int (*master_rmw) (struct vme_master_resource *, unsigned int,
 		unsigned int, unsigned int, loff_t);
+        int (*master_reset_window) (struct vme_master_resource *);
 
 	/* DMA Functions */
 	int (*dma_list_add) (struct vme_dma_list *, struct vme_dma_attr *,
diff --git a/include/linux/nai_input.h b/include/linux/nai_input.h
new file mode 100644
index 0000000..0b39b6e
--- /dev/null
+++ b/include/linux/nai_input.h
@@ -0,0 +1,38 @@
+#ifndef _nai_input_H
+#define _nai_input_H
+
+#define NAI_EVENT_CODE_0 0
+#define NAI_EVENT_CODE_1 1	
+#define NAI_EVENT_CODE_2 2
+#define NAI_EVENT_CODE_3 3
+/* IRQ Register Offset
+ * IRQ Base Address 0xFF21_0070 
+*/
+#define HPS_IRQ_0_VECTOR 	0x0
+#define HPS_IRQ_1_VECTOR 	0x04 	
+#define HPS_IRQ_2_VECTOR 	0x08
+#define HPS_IRQ_3_VECTOR 	0x10
+#define HPS_CLEAR_IRQ		0x0C
+struct device;
+
+struct nai_input_event {
+	/* Configuration parameters */
+	unsigned int code;	/* input event code */
+	void __iomem *vector_regs; /* IRQ Vector Register */
+	void __iomem *clear_irq_reg; /* IRQ Clear Register */
+	const char *desc;
+	unsigned int type;	/* input event type (EV_MSC) */
+	bool can_disable;
+	u32 value;		/*  vector value for EV_MSC */
+	unsigned int irq;	/* Irq number in case of interrupt keys */
+};
+
+struct nai_input_platform_data {
+	struct nai_input_event *inputevents;
+	int ninputevents;
+	int (*enable)(struct device *dev);
+	void (*disable)(struct device *dev);
+	const char *name;		/* input device name */
+};
+
+#endif
diff --git a/include/linux/nvmem-provider.h b/include/linux/nvmem-provider.h
index 497706f..ebc12b4 100644
--- a/include/linux/nvmem-provider.h
+++ b/include/linux/nvmem-provider.h
@@ -31,6 +31,7 @@ struct nvmem_config {
 	int			ncells;
 	bool			read_only;
 	bool			root_only;
+	bool			fram;
 	nvmem_reg_read_t	reg_read;
 	nvmem_reg_write_t	reg_write;
 	int	size;
diff --git a/include/linux/platform_data/at24.h b/include/linux/platform_data/at24.h
index 271a4e2..6dc90cf 100644
--- a/include/linux/platform_data/at24.h
+++ b/include/linux/platform_data/at24.h
@@ -50,6 +50,7 @@ struct at24_platform_data {
 #define AT24_FLAG_TAKE8ADDR	BIT(4)	/* take always 8 addresses (24c00) */
 #define AT24_FLAG_SERIAL	BIT(3)	/* factory-programmed serial number */
 #define AT24_FLAG_MAC		BIT(2)	/* factory-programmed mac address */
+#define AT24_FLAG_FRAM		BIT(1)	/* fram */
 
 	void		(*setup)(struct nvmem_device *nvmem, void *context);
 	void		*context;
diff --git a/include/linux/platform_data/leds-nai-pca9534a.h b/include/linux/platform_data/leds-nai-pca9534a.h
new file mode 100644
index 0000000..0ac3cbd
--- /dev/null
+++ b/include/linux/platform_data/leds-nai-pca9534a.h
@@ -0,0 +1,31 @@
+/*
+ * pca9534a LED chip driver.
+ *
+ * Copyright 2012 bct electronic GmbH
+ * Copyright 2013 Qtechnology A/S
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef __LINUX_pca9534a_H
+#define __LINUX_pca9534a_H
+#include <linux/leds.h>
+
+
+struct pca9534a_platform_data {
+	struct led_platform_data leds;
+};
+
+#endif /* __LINUX_pca9534a_H*/
diff --git a/include/linux/vme.h b/include/linux/vme.h
index 7e82bf5..2c64cce 100644
--- a/include/linux/vme.h
+++ b/include/linux/vme.h
@@ -10,6 +10,9 @@ enum vme_resource_type {
 	VME_LM
 };
 
+/* Number of VME interrupt levels */
+#define VME_INT_LEVELS	7
+
 /* VME Address Spaces */
 #define VME_A16		0x1
 #define VME_A24		0x2
@@ -106,6 +109,7 @@ struct vme_dev {
 	struct device dev;
 	struct list_head drv_list;
 	struct list_head bridge_list;
+	void * int_sysfs_entry[VME_INT_LEVELS];
 };
 
 /**
@@ -153,6 +157,7 @@ unsigned int vme_master_rmw(struct vme_resource *, unsigned int, unsigned int,
 	unsigned int, loff_t);
 int vme_master_mmap(struct vme_resource *resource, struct vm_area_struct *vma);
 void vme_master_free(struct vme_resource *);
+int vme_master_reset_window(struct vme_resource *);
 
 struct vme_resource *vme_dma_request(struct vme_dev *, u32);
 struct vme_dma_list *vme_new_dma_list(struct vme_resource *);
@@ -166,7 +171,7 @@ int vme_dma_list_add(struct vme_dma_list *, struct vme_dma_attr *,
 int vme_dma_list_free(struct vme_dma_list *);
 int vme_dma_free(struct vme_resource *);
 
-int vme_irq_request(struct vme_dev *, int, int,
+int vme_irq_request(struct vme_dev *, int,
 	void (*callback)(int, int, void *), void *);
 void vme_irq_free(struct vme_dev *, int, int);
 int vme_irq_generate(struct vme_dev *, int, int);
diff --git a/oe-logs b/oe-logs
new file mode 120000
index 0000000..1dda1c8
--- /dev/null
+++ b/oe-logs
@@ -0,0 +1 @@
+/home/jmcnicoll/projects/nai-xilinx-2018-2/nai_bsp_file/nai-75g5-x2-bsp-2018.2/build/tmp/work/plnx_zynq7-xilinx-linux-gnueabi/linux-xlnx/4.14-xilinx-v2018.2+git999-r0/temp
\ No newline at end of file
diff --git a/oe-workdir b/oe-workdir
new file mode 120000
index 0000000..134fdee
--- /dev/null
+++ b/oe-workdir
@@ -0,0 +1 @@
+/home/jmcnicoll/projects/nai-xilinx-2018-2/nai_bsp_file/nai-75g5-x2-bsp-2018.2/build/tmp/work/plnx_zynq7-xilinx-linux-gnueabi/linux-xlnx/4.14-xilinx-v2018.2+git999-r0
\ No newline at end of file
